// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/notzree/uprank-backend/inference-backend/ent/attachmentref"
	"github.com/notzree/uprank-backend/inference-backend/ent/job"
	"github.com/notzree/uprank-backend/inference-backend/ent/predicate"
	"github.com/notzree/uprank-backend/inference-backend/ent/schema"
	"github.com/notzree/uprank-backend/inference-backend/ent/upworkfreelancer"
	"github.com/notzree/uprank-backend/inference-backend/ent/upworkjob"
	"github.com/notzree/uprank-backend/inference-backend/ent/user"
	"github.com/notzree/uprank-backend/inference-backend/ent/workhistory"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAttachmentRef    = "AttachmentRef"
	TypeJob              = "Job"
	TypeUpworkFreelancer = "UpworkFreelancer"
	TypeUpworkJob        = "UpworkJob"
	TypeUser             = "User"
	TypeWorkHistory      = "WorkHistory"
)

// AttachmentRefMutation represents an operation that mutates the AttachmentRef nodes in the graph.
type AttachmentRefMutation struct {
	config
	op                Op
	typ               string
	id                *int
	name              *string
	link              *string
	clearedFields     map[string]struct{}
	freelancer        *string
	clearedfreelancer bool
	done              bool
	oldValue          func(context.Context) (*AttachmentRef, error)
	predicates        []predicate.AttachmentRef
}

var _ ent.Mutation = (*AttachmentRefMutation)(nil)

// attachmentrefOption allows management of the mutation configuration using functional options.
type attachmentrefOption func(*AttachmentRefMutation)

// newAttachmentRefMutation creates new mutation for the AttachmentRef entity.
func newAttachmentRefMutation(c config, op Op, opts ...attachmentrefOption) *AttachmentRefMutation {
	m := &AttachmentRefMutation{
		config:        c,
		op:            op,
		typ:           TypeAttachmentRef,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAttachmentRefID sets the ID field of the mutation.
func withAttachmentRefID(id int) attachmentrefOption {
	return func(m *AttachmentRefMutation) {
		var (
			err   error
			once  sync.Once
			value *AttachmentRef
		)
		m.oldValue = func(ctx context.Context) (*AttachmentRef, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AttachmentRef.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAttachmentRef sets the old AttachmentRef of the mutation.
func withAttachmentRef(node *AttachmentRef) attachmentrefOption {
	return func(m *AttachmentRefMutation) {
		m.oldValue = func(context.Context) (*AttachmentRef, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AttachmentRefMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AttachmentRefMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AttachmentRefMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AttachmentRefMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AttachmentRef.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AttachmentRefMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AttachmentRefMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AttachmentRef entity.
// If the AttachmentRef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentRefMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AttachmentRefMutation) ResetName() {
	m.name = nil
}

// SetLink sets the "link" field.
func (m *AttachmentRefMutation) SetLink(s string) {
	m.link = &s
}

// Link returns the value of the "link" field in the mutation.
func (m *AttachmentRefMutation) Link() (r string, exists bool) {
	v := m.link
	if v == nil {
		return
	}
	return *v, true
}

// OldLink returns the old "link" field's value of the AttachmentRef entity.
// If the AttachmentRef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentRefMutation) OldLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLink: %w", err)
	}
	return oldValue.Link, nil
}

// ResetLink resets all changes to the "link" field.
func (m *AttachmentRefMutation) ResetLink() {
	m.link = nil
}

// SetFreelancerID sets the "freelancer" edge to the UpworkFreelancer entity by id.
func (m *AttachmentRefMutation) SetFreelancerID(id string) {
	m.freelancer = &id
}

// ClearFreelancer clears the "freelancer" edge to the UpworkFreelancer entity.
func (m *AttachmentRefMutation) ClearFreelancer() {
	m.clearedfreelancer = true
}

// FreelancerCleared reports if the "freelancer" edge to the UpworkFreelancer entity was cleared.
func (m *AttachmentRefMutation) FreelancerCleared() bool {
	return m.clearedfreelancer
}

// FreelancerID returns the "freelancer" edge ID in the mutation.
func (m *AttachmentRefMutation) FreelancerID() (id string, exists bool) {
	if m.freelancer != nil {
		return *m.freelancer, true
	}
	return
}

// FreelancerIDs returns the "freelancer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FreelancerID instead. It exists only for internal usage by the builders.
func (m *AttachmentRefMutation) FreelancerIDs() (ids []string) {
	if id := m.freelancer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFreelancer resets all changes to the "freelancer" edge.
func (m *AttachmentRefMutation) ResetFreelancer() {
	m.freelancer = nil
	m.clearedfreelancer = false
}

// Where appends a list predicates to the AttachmentRefMutation builder.
func (m *AttachmentRefMutation) Where(ps ...predicate.AttachmentRef) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AttachmentRefMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AttachmentRefMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AttachmentRef, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AttachmentRefMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AttachmentRefMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AttachmentRef).
func (m *AttachmentRefMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AttachmentRefMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, attachmentref.FieldName)
	}
	if m.link != nil {
		fields = append(fields, attachmentref.FieldLink)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AttachmentRefMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case attachmentref.FieldName:
		return m.Name()
	case attachmentref.FieldLink:
		return m.Link()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AttachmentRefMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case attachmentref.FieldName:
		return m.OldName(ctx)
	case attachmentref.FieldLink:
		return m.OldLink(ctx)
	}
	return nil, fmt.Errorf("unknown AttachmentRef field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttachmentRefMutation) SetField(name string, value ent.Value) error {
	switch name {
	case attachmentref.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case attachmentref.FieldLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLink(v)
		return nil
	}
	return fmt.Errorf("unknown AttachmentRef field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AttachmentRefMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AttachmentRefMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttachmentRefMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AttachmentRef numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AttachmentRefMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AttachmentRefMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AttachmentRefMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AttachmentRef nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AttachmentRefMutation) ResetField(name string) error {
	switch name {
	case attachmentref.FieldName:
		m.ResetName()
		return nil
	case attachmentref.FieldLink:
		m.ResetLink()
		return nil
	}
	return fmt.Errorf("unknown AttachmentRef field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AttachmentRefMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.freelancer != nil {
		edges = append(edges, attachmentref.EdgeFreelancer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AttachmentRefMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case attachmentref.EdgeFreelancer:
		if id := m.freelancer; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AttachmentRefMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AttachmentRefMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AttachmentRefMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedfreelancer {
		edges = append(edges, attachmentref.EdgeFreelancer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AttachmentRefMutation) EdgeCleared(name string) bool {
	switch name {
	case attachmentref.EdgeFreelancer:
		return m.clearedfreelancer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AttachmentRefMutation) ClearEdge(name string) error {
	switch name {
	case attachmentref.EdgeFreelancer:
		m.ClearFreelancer()
		return nil
	}
	return fmt.Errorf("unknown AttachmentRef unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AttachmentRefMutation) ResetEdge(name string) error {
	switch name {
	case attachmentref.EdgeFreelancer:
		m.ResetFreelancer()
		return nil
	}
	return fmt.Errorf("unknown AttachmentRef edge %s", name)
}

// JobMutation represents an operation that mutates the Job nodes in the graph.
type JobMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	origin_platform  *schema.Platform
	clearedFields    map[string]struct{}
	user             *string
	cleareduser      bool
	upworkjob        map[string]struct{}
	removedupworkjob map[string]struct{}
	clearedupworkjob bool
	done             bool
	oldValue         func(context.Context) (*Job, error)
	predicates       []predicate.Job
}

var _ ent.Mutation = (*JobMutation)(nil)

// jobOption allows management of the mutation configuration using functional options.
type jobOption func(*JobMutation)

// newJobMutation creates new mutation for the Job entity.
func newJobMutation(c config, op Op, opts ...jobOption) *JobMutation {
	m := &JobMutation{
		config:        c,
		op:            op,
		typ:           TypeJob,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobID sets the ID field of the mutation.
func withJobID(id uuid.UUID) jobOption {
	return func(m *JobMutation) {
		var (
			err   error
			once  sync.Once
			value *Job
		)
		m.oldValue = func(ctx context.Context) (*Job, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Job.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJob sets the old Job of the mutation.
func withJob(node *Job) jobOption {
	return func(m *JobMutation) {
		m.oldValue = func(context.Context) (*Job, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Job entities.
func (m *JobMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Job.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOriginPlatform sets the "origin_platform" field.
func (m *JobMutation) SetOriginPlatform(s schema.Platform) {
	m.origin_platform = &s
}

// OriginPlatform returns the value of the "origin_platform" field in the mutation.
func (m *JobMutation) OriginPlatform() (r schema.Platform, exists bool) {
	v := m.origin_platform
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginPlatform returns the old "origin_platform" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldOriginPlatform(ctx context.Context) (v schema.Platform, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginPlatform: %w", err)
	}
	return oldValue.OriginPlatform, nil
}

// ResetOriginPlatform resets all changes to the "origin_platform" field.
func (m *JobMutation) ResetOriginPlatform() {
	m.origin_platform = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *JobMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *JobMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *JobMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *JobMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *JobMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *JobMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddUpworkjobIDs adds the "upworkjob" edge to the UpworkJob entity by ids.
func (m *JobMutation) AddUpworkjobIDs(ids ...string) {
	if m.upworkjob == nil {
		m.upworkjob = make(map[string]struct{})
	}
	for i := range ids {
		m.upworkjob[ids[i]] = struct{}{}
	}
}

// ClearUpworkjob clears the "upworkjob" edge to the UpworkJob entity.
func (m *JobMutation) ClearUpworkjob() {
	m.clearedupworkjob = true
}

// UpworkjobCleared reports if the "upworkjob" edge to the UpworkJob entity was cleared.
func (m *JobMutation) UpworkjobCleared() bool {
	return m.clearedupworkjob
}

// RemoveUpworkjobIDs removes the "upworkjob" edge to the UpworkJob entity by IDs.
func (m *JobMutation) RemoveUpworkjobIDs(ids ...string) {
	if m.removedupworkjob == nil {
		m.removedupworkjob = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.upworkjob, ids[i])
		m.removedupworkjob[ids[i]] = struct{}{}
	}
}

// RemovedUpworkjob returns the removed IDs of the "upworkjob" edge to the UpworkJob entity.
func (m *JobMutation) RemovedUpworkjobIDs() (ids []string) {
	for id := range m.removedupworkjob {
		ids = append(ids, id)
	}
	return
}

// UpworkjobIDs returns the "upworkjob" edge IDs in the mutation.
func (m *JobMutation) UpworkjobIDs() (ids []string) {
	for id := range m.upworkjob {
		ids = append(ids, id)
	}
	return
}

// ResetUpworkjob resets all changes to the "upworkjob" edge.
func (m *JobMutation) ResetUpworkjob() {
	m.upworkjob = nil
	m.clearedupworkjob = false
	m.removedupworkjob = nil
}

// Where appends a list predicates to the JobMutation builder.
func (m *JobMutation) Where(ps ...predicate.Job) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Job, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Job).
func (m *JobMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.origin_platform != nil {
		fields = append(fields, job.FieldOriginPlatform)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case job.FieldOriginPlatform:
		return m.OriginPlatform()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case job.FieldOriginPlatform:
		return m.OldOriginPlatform(ctx)
	}
	return nil, fmt.Errorf("unknown Job field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobMutation) SetField(name string, value ent.Value) error {
	switch name {
	case job.FieldOriginPlatform:
		v, ok := value.(schema.Platform)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginPlatform(v)
		return nil
	}
	return fmt.Errorf("unknown Job field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Job numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Job nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobMutation) ResetField(name string) error {
	switch name {
	case job.FieldOriginPlatform:
		m.ResetOriginPlatform()
		return nil
	}
	return fmt.Errorf("unknown Job field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, job.EdgeUser)
	}
	if m.upworkjob != nil {
		edges = append(edges, job.EdgeUpworkjob)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case job.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case job.EdgeUpworkjob:
		ids := make([]ent.Value, 0, len(m.upworkjob))
		for id := range m.upworkjob {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedupworkjob != nil {
		edges = append(edges, job.EdgeUpworkjob)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case job.EdgeUpworkjob:
		ids := make([]ent.Value, 0, len(m.removedupworkjob))
		for id := range m.removedupworkjob {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, job.EdgeUser)
	}
	if m.clearedupworkjob {
		edges = append(edges, job.EdgeUpworkjob)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobMutation) EdgeCleared(name string) bool {
	switch name {
	case job.EdgeUser:
		return m.cleareduser
	case job.EdgeUpworkjob:
		return m.clearedupworkjob
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobMutation) ClearEdge(name string) error {
	switch name {
	case job.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Job unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobMutation) ResetEdge(name string) error {
	switch name {
	case job.EdgeUser:
		m.ResetUser()
		return nil
	case job.EdgeUpworkjob:
		m.ResetUpworkjob()
		return nil
	}
	return fmt.Errorf("unknown Job edge %s", name)
}

// UpworkFreelancerMutation represents an operation that mutates the UpworkFreelancer nodes in the graph.
type UpworkFreelancerMutation struct {
	config
	op                                  Op
	typ                                 string
	id                                  *string
	name                                *string
	title                               *string
	description                         *string
	city                                *string
	country                             *string
	timezone                            *string
	cv                                  *string
	ai_reccomended                      *bool
	fixed_charge_amount                 *float64
	addfixed_charge_amount              *float64
	fixed_charge_currency               *string
	hourly_charge_amount                *float64
	addhourly_charge_amount             *float64
	hourly_charge_currency              *string
	invited                             *bool
	photo_url                           *string
	recent_hours                        *float64
	addrecent_hours                     *float64
	total_hours                         *float64
	addtotal_hours                      *float64
	total_portfolio_items               *int
	addtotal_portfolio_items            *int
	total_portfolio_v2_items            *int
	addtotal_portfolio_v2_items         *int
	upwork_total_feedback               *float64
	addupwork_total_feedback            *float64
	upwork_recent_feedback              *float64
	addupwork_recent_feedback           *float64
	upwork_top_rated_status             *bool
	upwork_top_rated_plus_status        *bool
	upwork_sponsored                    *bool
	upwork_job_success_score            *float64
	addupwork_job_success_score         *float64
	upwork_reccomended                  *bool
	skills                              *[]string
	appendskills                        []string
	average_recent_earnings             *float64
	addaverage_recent_earnings          *float64
	combined_average_recent_earnings    *float64
	addcombined_average_recent_earnings *float64
	combined_recent_earnings            *float64
	addcombined_recent_earnings         *float64
	combined_total_earnings             *float64
	addcombined_total_earnings          *float64
	combined_total_revenue              *float64
	addcombined_total_revenue           *float64
	recent_earnings                     *float64
	addrecent_earnings                  *float64
	total_revenue                       *float64
	addtotal_revenue                    *float64
	uprank_score                        *int
	adduprank_score                     *int
	uprank_updated_at                   *time.Time
	uprank_reccomended                  *bool
	uprank_reccomended_reasons          *string
	uprank_not_enough_data              *bool
	clearedFields                       map[string]struct{}
	upwork_job                          map[string]struct{}
	removedupwork_job                   map[string]struct{}
	clearedupwork_job                   bool
	attachments                         map[int]struct{}
	removedattachments                  map[int]struct{}
	clearedattachments                  bool
	work_histories                      map[int]struct{}
	removedwork_histories               map[int]struct{}
	clearedwork_histories               bool
	done                                bool
	oldValue                            func(context.Context) (*UpworkFreelancer, error)
	predicates                          []predicate.UpworkFreelancer
}

var _ ent.Mutation = (*UpworkFreelancerMutation)(nil)

// upworkfreelancerOption allows management of the mutation configuration using functional options.
type upworkfreelancerOption func(*UpworkFreelancerMutation)

// newUpworkFreelancerMutation creates new mutation for the UpworkFreelancer entity.
func newUpworkFreelancerMutation(c config, op Op, opts ...upworkfreelancerOption) *UpworkFreelancerMutation {
	m := &UpworkFreelancerMutation{
		config:        c,
		op:            op,
		typ:           TypeUpworkFreelancer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpworkFreelancerID sets the ID field of the mutation.
func withUpworkFreelancerID(id string) upworkfreelancerOption {
	return func(m *UpworkFreelancerMutation) {
		var (
			err   error
			once  sync.Once
			value *UpworkFreelancer
		)
		m.oldValue = func(ctx context.Context) (*UpworkFreelancer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpworkFreelancer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpworkFreelancer sets the old UpworkFreelancer of the mutation.
func withUpworkFreelancer(node *UpworkFreelancer) upworkfreelancerOption {
	return func(m *UpworkFreelancerMutation) {
		m.oldValue = func(context.Context) (*UpworkFreelancer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpworkFreelancerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpworkFreelancerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpworkFreelancer entities.
func (m *UpworkFreelancerMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpworkFreelancerMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpworkFreelancerMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpworkFreelancer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *UpworkFreelancerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UpworkFreelancerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the UpworkFreelancer entity.
// If the UpworkFreelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkFreelancerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UpworkFreelancerMutation) ResetName() {
	m.name = nil
}

// SetTitle sets the "title" field.
func (m *UpworkFreelancerMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *UpworkFreelancerMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the UpworkFreelancer entity.
// If the UpworkFreelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkFreelancerMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *UpworkFreelancerMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *UpworkFreelancerMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UpworkFreelancerMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the UpworkFreelancer entity.
// If the UpworkFreelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkFreelancerMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *UpworkFreelancerMutation) ResetDescription() {
	m.description = nil
}

// SetCity sets the "city" field.
func (m *UpworkFreelancerMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *UpworkFreelancerMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the UpworkFreelancer entity.
// If the UpworkFreelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkFreelancerMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *UpworkFreelancerMutation) ResetCity() {
	m.city = nil
}

// SetCountry sets the "country" field.
func (m *UpworkFreelancerMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *UpworkFreelancerMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the UpworkFreelancer entity.
// If the UpworkFreelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkFreelancerMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry resets all changes to the "country" field.
func (m *UpworkFreelancerMutation) ResetCountry() {
	m.country = nil
}

// SetTimezone sets the "timezone" field.
func (m *UpworkFreelancerMutation) SetTimezone(s string) {
	m.timezone = &s
}

// Timezone returns the value of the "timezone" field in the mutation.
func (m *UpworkFreelancerMutation) Timezone() (r string, exists bool) {
	v := m.timezone
	if v == nil {
		return
	}
	return *v, true
}

// OldTimezone returns the old "timezone" field's value of the UpworkFreelancer entity.
// If the UpworkFreelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkFreelancerMutation) OldTimezone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimezone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimezone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimezone: %w", err)
	}
	return oldValue.Timezone, nil
}

// ResetTimezone resets all changes to the "timezone" field.
func (m *UpworkFreelancerMutation) ResetTimezone() {
	m.timezone = nil
}

// SetCv sets the "cv" field.
func (m *UpworkFreelancerMutation) SetCv(s string) {
	m.cv = &s
}

// Cv returns the value of the "cv" field in the mutation.
func (m *UpworkFreelancerMutation) Cv() (r string, exists bool) {
	v := m.cv
	if v == nil {
		return
	}
	return *v, true
}

// OldCv returns the old "cv" field's value of the UpworkFreelancer entity.
// If the UpworkFreelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkFreelancerMutation) OldCv(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCv is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCv requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCv: %w", err)
	}
	return oldValue.Cv, nil
}

// ResetCv resets all changes to the "cv" field.
func (m *UpworkFreelancerMutation) ResetCv() {
	m.cv = nil
}

// SetAiReccomended sets the "ai_reccomended" field.
func (m *UpworkFreelancerMutation) SetAiReccomended(b bool) {
	m.ai_reccomended = &b
}

// AiReccomended returns the value of the "ai_reccomended" field in the mutation.
func (m *UpworkFreelancerMutation) AiReccomended() (r bool, exists bool) {
	v := m.ai_reccomended
	if v == nil {
		return
	}
	return *v, true
}

// OldAiReccomended returns the old "ai_reccomended" field's value of the UpworkFreelancer entity.
// If the UpworkFreelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkFreelancerMutation) OldAiReccomended(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAiReccomended is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAiReccomended requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAiReccomended: %w", err)
	}
	return oldValue.AiReccomended, nil
}

// ResetAiReccomended resets all changes to the "ai_reccomended" field.
func (m *UpworkFreelancerMutation) ResetAiReccomended() {
	m.ai_reccomended = nil
}

// SetFixedChargeAmount sets the "fixed_charge_amount" field.
func (m *UpworkFreelancerMutation) SetFixedChargeAmount(f float64) {
	m.fixed_charge_amount = &f
	m.addfixed_charge_amount = nil
}

// FixedChargeAmount returns the value of the "fixed_charge_amount" field in the mutation.
func (m *UpworkFreelancerMutation) FixedChargeAmount() (r float64, exists bool) {
	v := m.fixed_charge_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldFixedChargeAmount returns the old "fixed_charge_amount" field's value of the UpworkFreelancer entity.
// If the UpworkFreelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkFreelancerMutation) OldFixedChargeAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFixedChargeAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFixedChargeAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFixedChargeAmount: %w", err)
	}
	return oldValue.FixedChargeAmount, nil
}

// AddFixedChargeAmount adds f to the "fixed_charge_amount" field.
func (m *UpworkFreelancerMutation) AddFixedChargeAmount(f float64) {
	if m.addfixed_charge_amount != nil {
		*m.addfixed_charge_amount += f
	} else {
		m.addfixed_charge_amount = &f
	}
}

// AddedFixedChargeAmount returns the value that was added to the "fixed_charge_amount" field in this mutation.
func (m *UpworkFreelancerMutation) AddedFixedChargeAmount() (r float64, exists bool) {
	v := m.addfixed_charge_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearFixedChargeAmount clears the value of the "fixed_charge_amount" field.
func (m *UpworkFreelancerMutation) ClearFixedChargeAmount() {
	m.fixed_charge_amount = nil
	m.addfixed_charge_amount = nil
	m.clearedFields[upworkfreelancer.FieldFixedChargeAmount] = struct{}{}
}

// FixedChargeAmountCleared returns if the "fixed_charge_amount" field was cleared in this mutation.
func (m *UpworkFreelancerMutation) FixedChargeAmountCleared() bool {
	_, ok := m.clearedFields[upworkfreelancer.FieldFixedChargeAmount]
	return ok
}

// ResetFixedChargeAmount resets all changes to the "fixed_charge_amount" field.
func (m *UpworkFreelancerMutation) ResetFixedChargeAmount() {
	m.fixed_charge_amount = nil
	m.addfixed_charge_amount = nil
	delete(m.clearedFields, upworkfreelancer.FieldFixedChargeAmount)
}

// SetFixedChargeCurrency sets the "fixed_charge_currency" field.
func (m *UpworkFreelancerMutation) SetFixedChargeCurrency(s string) {
	m.fixed_charge_currency = &s
}

// FixedChargeCurrency returns the value of the "fixed_charge_currency" field in the mutation.
func (m *UpworkFreelancerMutation) FixedChargeCurrency() (r string, exists bool) {
	v := m.fixed_charge_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldFixedChargeCurrency returns the old "fixed_charge_currency" field's value of the UpworkFreelancer entity.
// If the UpworkFreelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkFreelancerMutation) OldFixedChargeCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFixedChargeCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFixedChargeCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFixedChargeCurrency: %w", err)
	}
	return oldValue.FixedChargeCurrency, nil
}

// ResetFixedChargeCurrency resets all changes to the "fixed_charge_currency" field.
func (m *UpworkFreelancerMutation) ResetFixedChargeCurrency() {
	m.fixed_charge_currency = nil
}

// SetHourlyChargeAmount sets the "hourly_charge_amount" field.
func (m *UpworkFreelancerMutation) SetHourlyChargeAmount(f float64) {
	m.hourly_charge_amount = &f
	m.addhourly_charge_amount = nil
}

// HourlyChargeAmount returns the value of the "hourly_charge_amount" field in the mutation.
func (m *UpworkFreelancerMutation) HourlyChargeAmount() (r float64, exists bool) {
	v := m.hourly_charge_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldHourlyChargeAmount returns the old "hourly_charge_amount" field's value of the UpworkFreelancer entity.
// If the UpworkFreelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkFreelancerMutation) OldHourlyChargeAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHourlyChargeAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHourlyChargeAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHourlyChargeAmount: %w", err)
	}
	return oldValue.HourlyChargeAmount, nil
}

// AddHourlyChargeAmount adds f to the "hourly_charge_amount" field.
func (m *UpworkFreelancerMutation) AddHourlyChargeAmount(f float64) {
	if m.addhourly_charge_amount != nil {
		*m.addhourly_charge_amount += f
	} else {
		m.addhourly_charge_amount = &f
	}
}

// AddedHourlyChargeAmount returns the value that was added to the "hourly_charge_amount" field in this mutation.
func (m *UpworkFreelancerMutation) AddedHourlyChargeAmount() (r float64, exists bool) {
	v := m.addhourly_charge_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearHourlyChargeAmount clears the value of the "hourly_charge_amount" field.
func (m *UpworkFreelancerMutation) ClearHourlyChargeAmount() {
	m.hourly_charge_amount = nil
	m.addhourly_charge_amount = nil
	m.clearedFields[upworkfreelancer.FieldHourlyChargeAmount] = struct{}{}
}

// HourlyChargeAmountCleared returns if the "hourly_charge_amount" field was cleared in this mutation.
func (m *UpworkFreelancerMutation) HourlyChargeAmountCleared() bool {
	_, ok := m.clearedFields[upworkfreelancer.FieldHourlyChargeAmount]
	return ok
}

// ResetHourlyChargeAmount resets all changes to the "hourly_charge_amount" field.
func (m *UpworkFreelancerMutation) ResetHourlyChargeAmount() {
	m.hourly_charge_amount = nil
	m.addhourly_charge_amount = nil
	delete(m.clearedFields, upworkfreelancer.FieldHourlyChargeAmount)
}

// SetHourlyChargeCurrency sets the "hourly_charge_currency" field.
func (m *UpworkFreelancerMutation) SetHourlyChargeCurrency(s string) {
	m.hourly_charge_currency = &s
}

// HourlyChargeCurrency returns the value of the "hourly_charge_currency" field in the mutation.
func (m *UpworkFreelancerMutation) HourlyChargeCurrency() (r string, exists bool) {
	v := m.hourly_charge_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldHourlyChargeCurrency returns the old "hourly_charge_currency" field's value of the UpworkFreelancer entity.
// If the UpworkFreelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkFreelancerMutation) OldHourlyChargeCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHourlyChargeCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHourlyChargeCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHourlyChargeCurrency: %w", err)
	}
	return oldValue.HourlyChargeCurrency, nil
}

// ResetHourlyChargeCurrency resets all changes to the "hourly_charge_currency" field.
func (m *UpworkFreelancerMutation) ResetHourlyChargeCurrency() {
	m.hourly_charge_currency = nil
}

// SetInvited sets the "invited" field.
func (m *UpworkFreelancerMutation) SetInvited(b bool) {
	m.invited = &b
}

// Invited returns the value of the "invited" field in the mutation.
func (m *UpworkFreelancerMutation) Invited() (r bool, exists bool) {
	v := m.invited
	if v == nil {
		return
	}
	return *v, true
}

// OldInvited returns the old "invited" field's value of the UpworkFreelancer entity.
// If the UpworkFreelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkFreelancerMutation) OldInvited(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvited is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvited requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvited: %w", err)
	}
	return oldValue.Invited, nil
}

// ResetInvited resets all changes to the "invited" field.
func (m *UpworkFreelancerMutation) ResetInvited() {
	m.invited = nil
}

// SetPhotoURL sets the "photo_url" field.
func (m *UpworkFreelancerMutation) SetPhotoURL(s string) {
	m.photo_url = &s
}

// PhotoURL returns the value of the "photo_url" field in the mutation.
func (m *UpworkFreelancerMutation) PhotoURL() (r string, exists bool) {
	v := m.photo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPhotoURL returns the old "photo_url" field's value of the UpworkFreelancer entity.
// If the UpworkFreelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkFreelancerMutation) OldPhotoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhotoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhotoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhotoURL: %w", err)
	}
	return oldValue.PhotoURL, nil
}

// ResetPhotoURL resets all changes to the "photo_url" field.
func (m *UpworkFreelancerMutation) ResetPhotoURL() {
	m.photo_url = nil
}

// SetRecentHours sets the "recent_hours" field.
func (m *UpworkFreelancerMutation) SetRecentHours(f float64) {
	m.recent_hours = &f
	m.addrecent_hours = nil
}

// RecentHours returns the value of the "recent_hours" field in the mutation.
func (m *UpworkFreelancerMutation) RecentHours() (r float64, exists bool) {
	v := m.recent_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldRecentHours returns the old "recent_hours" field's value of the UpworkFreelancer entity.
// If the UpworkFreelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkFreelancerMutation) OldRecentHours(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecentHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecentHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecentHours: %w", err)
	}
	return oldValue.RecentHours, nil
}

// AddRecentHours adds f to the "recent_hours" field.
func (m *UpworkFreelancerMutation) AddRecentHours(f float64) {
	if m.addrecent_hours != nil {
		*m.addrecent_hours += f
	} else {
		m.addrecent_hours = &f
	}
}

// AddedRecentHours returns the value that was added to the "recent_hours" field in this mutation.
func (m *UpworkFreelancerMutation) AddedRecentHours() (r float64, exists bool) {
	v := m.addrecent_hours
	if v == nil {
		return
	}
	return *v, true
}

// ResetRecentHours resets all changes to the "recent_hours" field.
func (m *UpworkFreelancerMutation) ResetRecentHours() {
	m.recent_hours = nil
	m.addrecent_hours = nil
}

// SetTotalHours sets the "total_hours" field.
func (m *UpworkFreelancerMutation) SetTotalHours(f float64) {
	m.total_hours = &f
	m.addtotal_hours = nil
}

// TotalHours returns the value of the "total_hours" field in the mutation.
func (m *UpworkFreelancerMutation) TotalHours() (r float64, exists bool) {
	v := m.total_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalHours returns the old "total_hours" field's value of the UpworkFreelancer entity.
// If the UpworkFreelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkFreelancerMutation) OldTotalHours(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalHours: %w", err)
	}
	return oldValue.TotalHours, nil
}

// AddTotalHours adds f to the "total_hours" field.
func (m *UpworkFreelancerMutation) AddTotalHours(f float64) {
	if m.addtotal_hours != nil {
		*m.addtotal_hours += f
	} else {
		m.addtotal_hours = &f
	}
}

// AddedTotalHours returns the value that was added to the "total_hours" field in this mutation.
func (m *UpworkFreelancerMutation) AddedTotalHours() (r float64, exists bool) {
	v := m.addtotal_hours
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalHours resets all changes to the "total_hours" field.
func (m *UpworkFreelancerMutation) ResetTotalHours() {
	m.total_hours = nil
	m.addtotal_hours = nil
}

// SetTotalPortfolioItems sets the "total_portfolio_items" field.
func (m *UpworkFreelancerMutation) SetTotalPortfolioItems(i int) {
	m.total_portfolio_items = &i
	m.addtotal_portfolio_items = nil
}

// TotalPortfolioItems returns the value of the "total_portfolio_items" field in the mutation.
func (m *UpworkFreelancerMutation) TotalPortfolioItems() (r int, exists bool) {
	v := m.total_portfolio_items
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalPortfolioItems returns the old "total_portfolio_items" field's value of the UpworkFreelancer entity.
// If the UpworkFreelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkFreelancerMutation) OldTotalPortfolioItems(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalPortfolioItems is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalPortfolioItems requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalPortfolioItems: %w", err)
	}
	return oldValue.TotalPortfolioItems, nil
}

// AddTotalPortfolioItems adds i to the "total_portfolio_items" field.
func (m *UpworkFreelancerMutation) AddTotalPortfolioItems(i int) {
	if m.addtotal_portfolio_items != nil {
		*m.addtotal_portfolio_items += i
	} else {
		m.addtotal_portfolio_items = &i
	}
}

// AddedTotalPortfolioItems returns the value that was added to the "total_portfolio_items" field in this mutation.
func (m *UpworkFreelancerMutation) AddedTotalPortfolioItems() (r int, exists bool) {
	v := m.addtotal_portfolio_items
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalPortfolioItems resets all changes to the "total_portfolio_items" field.
func (m *UpworkFreelancerMutation) ResetTotalPortfolioItems() {
	m.total_portfolio_items = nil
	m.addtotal_portfolio_items = nil
}

// SetTotalPortfolioV2Items sets the "total_portfolio_v2_items" field.
func (m *UpworkFreelancerMutation) SetTotalPortfolioV2Items(i int) {
	m.total_portfolio_v2_items = &i
	m.addtotal_portfolio_v2_items = nil
}

// TotalPortfolioV2Items returns the value of the "total_portfolio_v2_items" field in the mutation.
func (m *UpworkFreelancerMutation) TotalPortfolioV2Items() (r int, exists bool) {
	v := m.total_portfolio_v2_items
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalPortfolioV2Items returns the old "total_portfolio_v2_items" field's value of the UpworkFreelancer entity.
// If the UpworkFreelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkFreelancerMutation) OldTotalPortfolioV2Items(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalPortfolioV2Items is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalPortfolioV2Items requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalPortfolioV2Items: %w", err)
	}
	return oldValue.TotalPortfolioV2Items, nil
}

// AddTotalPortfolioV2Items adds i to the "total_portfolio_v2_items" field.
func (m *UpworkFreelancerMutation) AddTotalPortfolioV2Items(i int) {
	if m.addtotal_portfolio_v2_items != nil {
		*m.addtotal_portfolio_v2_items += i
	} else {
		m.addtotal_portfolio_v2_items = &i
	}
}

// AddedTotalPortfolioV2Items returns the value that was added to the "total_portfolio_v2_items" field in this mutation.
func (m *UpworkFreelancerMutation) AddedTotalPortfolioV2Items() (r int, exists bool) {
	v := m.addtotal_portfolio_v2_items
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalPortfolioV2Items resets all changes to the "total_portfolio_v2_items" field.
func (m *UpworkFreelancerMutation) ResetTotalPortfolioV2Items() {
	m.total_portfolio_v2_items = nil
	m.addtotal_portfolio_v2_items = nil
}

// SetUpworkTotalFeedback sets the "upwork_total_feedback" field.
func (m *UpworkFreelancerMutation) SetUpworkTotalFeedback(f float64) {
	m.upwork_total_feedback = &f
	m.addupwork_total_feedback = nil
}

// UpworkTotalFeedback returns the value of the "upwork_total_feedback" field in the mutation.
func (m *UpworkFreelancerMutation) UpworkTotalFeedback() (r float64, exists bool) {
	v := m.upwork_total_feedback
	if v == nil {
		return
	}
	return *v, true
}

// OldUpworkTotalFeedback returns the old "upwork_total_feedback" field's value of the UpworkFreelancer entity.
// If the UpworkFreelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkFreelancerMutation) OldUpworkTotalFeedback(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpworkTotalFeedback is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpworkTotalFeedback requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpworkTotalFeedback: %w", err)
	}
	return oldValue.UpworkTotalFeedback, nil
}

// AddUpworkTotalFeedback adds f to the "upwork_total_feedback" field.
func (m *UpworkFreelancerMutation) AddUpworkTotalFeedback(f float64) {
	if m.addupwork_total_feedback != nil {
		*m.addupwork_total_feedback += f
	} else {
		m.addupwork_total_feedback = &f
	}
}

// AddedUpworkTotalFeedback returns the value that was added to the "upwork_total_feedback" field in this mutation.
func (m *UpworkFreelancerMutation) AddedUpworkTotalFeedback() (r float64, exists bool) {
	v := m.addupwork_total_feedback
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpworkTotalFeedback resets all changes to the "upwork_total_feedback" field.
func (m *UpworkFreelancerMutation) ResetUpworkTotalFeedback() {
	m.upwork_total_feedback = nil
	m.addupwork_total_feedback = nil
}

// SetUpworkRecentFeedback sets the "upwork_recent_feedback" field.
func (m *UpworkFreelancerMutation) SetUpworkRecentFeedback(f float64) {
	m.upwork_recent_feedback = &f
	m.addupwork_recent_feedback = nil
}

// UpworkRecentFeedback returns the value of the "upwork_recent_feedback" field in the mutation.
func (m *UpworkFreelancerMutation) UpworkRecentFeedback() (r float64, exists bool) {
	v := m.upwork_recent_feedback
	if v == nil {
		return
	}
	return *v, true
}

// OldUpworkRecentFeedback returns the old "upwork_recent_feedback" field's value of the UpworkFreelancer entity.
// If the UpworkFreelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkFreelancerMutation) OldUpworkRecentFeedback(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpworkRecentFeedback is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpworkRecentFeedback requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpworkRecentFeedback: %w", err)
	}
	return oldValue.UpworkRecentFeedback, nil
}

// AddUpworkRecentFeedback adds f to the "upwork_recent_feedback" field.
func (m *UpworkFreelancerMutation) AddUpworkRecentFeedback(f float64) {
	if m.addupwork_recent_feedback != nil {
		*m.addupwork_recent_feedback += f
	} else {
		m.addupwork_recent_feedback = &f
	}
}

// AddedUpworkRecentFeedback returns the value that was added to the "upwork_recent_feedback" field in this mutation.
func (m *UpworkFreelancerMutation) AddedUpworkRecentFeedback() (r float64, exists bool) {
	v := m.addupwork_recent_feedback
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpworkRecentFeedback resets all changes to the "upwork_recent_feedback" field.
func (m *UpworkFreelancerMutation) ResetUpworkRecentFeedback() {
	m.upwork_recent_feedback = nil
	m.addupwork_recent_feedback = nil
}

// SetUpworkTopRatedStatus sets the "upwork_top_rated_status" field.
func (m *UpworkFreelancerMutation) SetUpworkTopRatedStatus(b bool) {
	m.upwork_top_rated_status = &b
}

// UpworkTopRatedStatus returns the value of the "upwork_top_rated_status" field in the mutation.
func (m *UpworkFreelancerMutation) UpworkTopRatedStatus() (r bool, exists bool) {
	v := m.upwork_top_rated_status
	if v == nil {
		return
	}
	return *v, true
}

// OldUpworkTopRatedStatus returns the old "upwork_top_rated_status" field's value of the UpworkFreelancer entity.
// If the UpworkFreelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkFreelancerMutation) OldUpworkTopRatedStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpworkTopRatedStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpworkTopRatedStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpworkTopRatedStatus: %w", err)
	}
	return oldValue.UpworkTopRatedStatus, nil
}

// ResetUpworkTopRatedStatus resets all changes to the "upwork_top_rated_status" field.
func (m *UpworkFreelancerMutation) ResetUpworkTopRatedStatus() {
	m.upwork_top_rated_status = nil
}

// SetUpworkTopRatedPlusStatus sets the "upwork_top_rated_plus_status" field.
func (m *UpworkFreelancerMutation) SetUpworkTopRatedPlusStatus(b bool) {
	m.upwork_top_rated_plus_status = &b
}

// UpworkTopRatedPlusStatus returns the value of the "upwork_top_rated_plus_status" field in the mutation.
func (m *UpworkFreelancerMutation) UpworkTopRatedPlusStatus() (r bool, exists bool) {
	v := m.upwork_top_rated_plus_status
	if v == nil {
		return
	}
	return *v, true
}

// OldUpworkTopRatedPlusStatus returns the old "upwork_top_rated_plus_status" field's value of the UpworkFreelancer entity.
// If the UpworkFreelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkFreelancerMutation) OldUpworkTopRatedPlusStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpworkTopRatedPlusStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpworkTopRatedPlusStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpworkTopRatedPlusStatus: %w", err)
	}
	return oldValue.UpworkTopRatedPlusStatus, nil
}

// ResetUpworkTopRatedPlusStatus resets all changes to the "upwork_top_rated_plus_status" field.
func (m *UpworkFreelancerMutation) ResetUpworkTopRatedPlusStatus() {
	m.upwork_top_rated_plus_status = nil
}

// SetUpworkSponsored sets the "upwork_sponsored" field.
func (m *UpworkFreelancerMutation) SetUpworkSponsored(b bool) {
	m.upwork_sponsored = &b
}

// UpworkSponsored returns the value of the "upwork_sponsored" field in the mutation.
func (m *UpworkFreelancerMutation) UpworkSponsored() (r bool, exists bool) {
	v := m.upwork_sponsored
	if v == nil {
		return
	}
	return *v, true
}

// OldUpworkSponsored returns the old "upwork_sponsored" field's value of the UpworkFreelancer entity.
// If the UpworkFreelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkFreelancerMutation) OldUpworkSponsored(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpworkSponsored is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpworkSponsored requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpworkSponsored: %w", err)
	}
	return oldValue.UpworkSponsored, nil
}

// ResetUpworkSponsored resets all changes to the "upwork_sponsored" field.
func (m *UpworkFreelancerMutation) ResetUpworkSponsored() {
	m.upwork_sponsored = nil
}

// SetUpworkJobSuccessScore sets the "upwork_job_success_score" field.
func (m *UpworkFreelancerMutation) SetUpworkJobSuccessScore(f float64) {
	m.upwork_job_success_score = &f
	m.addupwork_job_success_score = nil
}

// UpworkJobSuccessScore returns the value of the "upwork_job_success_score" field in the mutation.
func (m *UpworkFreelancerMutation) UpworkJobSuccessScore() (r float64, exists bool) {
	v := m.upwork_job_success_score
	if v == nil {
		return
	}
	return *v, true
}

// OldUpworkJobSuccessScore returns the old "upwork_job_success_score" field's value of the UpworkFreelancer entity.
// If the UpworkFreelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkFreelancerMutation) OldUpworkJobSuccessScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpworkJobSuccessScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpworkJobSuccessScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpworkJobSuccessScore: %w", err)
	}
	return oldValue.UpworkJobSuccessScore, nil
}

// AddUpworkJobSuccessScore adds f to the "upwork_job_success_score" field.
func (m *UpworkFreelancerMutation) AddUpworkJobSuccessScore(f float64) {
	if m.addupwork_job_success_score != nil {
		*m.addupwork_job_success_score += f
	} else {
		m.addupwork_job_success_score = &f
	}
}

// AddedUpworkJobSuccessScore returns the value that was added to the "upwork_job_success_score" field in this mutation.
func (m *UpworkFreelancerMutation) AddedUpworkJobSuccessScore() (r float64, exists bool) {
	v := m.addupwork_job_success_score
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpworkJobSuccessScore resets all changes to the "upwork_job_success_score" field.
func (m *UpworkFreelancerMutation) ResetUpworkJobSuccessScore() {
	m.upwork_job_success_score = nil
	m.addupwork_job_success_score = nil
}

// SetUpworkReccomended sets the "upwork_reccomended" field.
func (m *UpworkFreelancerMutation) SetUpworkReccomended(b bool) {
	m.upwork_reccomended = &b
}

// UpworkReccomended returns the value of the "upwork_reccomended" field in the mutation.
func (m *UpworkFreelancerMutation) UpworkReccomended() (r bool, exists bool) {
	v := m.upwork_reccomended
	if v == nil {
		return
	}
	return *v, true
}

// OldUpworkReccomended returns the old "upwork_reccomended" field's value of the UpworkFreelancer entity.
// If the UpworkFreelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkFreelancerMutation) OldUpworkReccomended(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpworkReccomended is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpworkReccomended requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpworkReccomended: %w", err)
	}
	return oldValue.UpworkReccomended, nil
}

// ResetUpworkReccomended resets all changes to the "upwork_reccomended" field.
func (m *UpworkFreelancerMutation) ResetUpworkReccomended() {
	m.upwork_reccomended = nil
}

// SetSkills sets the "skills" field.
func (m *UpworkFreelancerMutation) SetSkills(s []string) {
	m.skills = &s
	m.appendskills = nil
}

// Skills returns the value of the "skills" field in the mutation.
func (m *UpworkFreelancerMutation) Skills() (r []string, exists bool) {
	v := m.skills
	if v == nil {
		return
	}
	return *v, true
}

// OldSkills returns the old "skills" field's value of the UpworkFreelancer entity.
// If the UpworkFreelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkFreelancerMutation) OldSkills(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkills is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkills requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkills: %w", err)
	}
	return oldValue.Skills, nil
}

// AppendSkills adds s to the "skills" field.
func (m *UpworkFreelancerMutation) AppendSkills(s []string) {
	m.appendskills = append(m.appendskills, s...)
}

// AppendedSkills returns the list of values that were appended to the "skills" field in this mutation.
func (m *UpworkFreelancerMutation) AppendedSkills() ([]string, bool) {
	if len(m.appendskills) == 0 {
		return nil, false
	}
	return m.appendskills, true
}

// ResetSkills resets all changes to the "skills" field.
func (m *UpworkFreelancerMutation) ResetSkills() {
	m.skills = nil
	m.appendskills = nil
}

// SetAverageRecentEarnings sets the "average_recent_earnings" field.
func (m *UpworkFreelancerMutation) SetAverageRecentEarnings(f float64) {
	m.average_recent_earnings = &f
	m.addaverage_recent_earnings = nil
}

// AverageRecentEarnings returns the value of the "average_recent_earnings" field in the mutation.
func (m *UpworkFreelancerMutation) AverageRecentEarnings() (r float64, exists bool) {
	v := m.average_recent_earnings
	if v == nil {
		return
	}
	return *v, true
}

// OldAverageRecentEarnings returns the old "average_recent_earnings" field's value of the UpworkFreelancer entity.
// If the UpworkFreelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkFreelancerMutation) OldAverageRecentEarnings(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAverageRecentEarnings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAverageRecentEarnings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAverageRecentEarnings: %w", err)
	}
	return oldValue.AverageRecentEarnings, nil
}

// AddAverageRecentEarnings adds f to the "average_recent_earnings" field.
func (m *UpworkFreelancerMutation) AddAverageRecentEarnings(f float64) {
	if m.addaverage_recent_earnings != nil {
		*m.addaverage_recent_earnings += f
	} else {
		m.addaverage_recent_earnings = &f
	}
}

// AddedAverageRecentEarnings returns the value that was added to the "average_recent_earnings" field in this mutation.
func (m *UpworkFreelancerMutation) AddedAverageRecentEarnings() (r float64, exists bool) {
	v := m.addaverage_recent_earnings
	if v == nil {
		return
	}
	return *v, true
}

// ResetAverageRecentEarnings resets all changes to the "average_recent_earnings" field.
func (m *UpworkFreelancerMutation) ResetAverageRecentEarnings() {
	m.average_recent_earnings = nil
	m.addaverage_recent_earnings = nil
}

// SetCombinedAverageRecentEarnings sets the "combined_average_recent_earnings" field.
func (m *UpworkFreelancerMutation) SetCombinedAverageRecentEarnings(f float64) {
	m.combined_average_recent_earnings = &f
	m.addcombined_average_recent_earnings = nil
}

// CombinedAverageRecentEarnings returns the value of the "combined_average_recent_earnings" field in the mutation.
func (m *UpworkFreelancerMutation) CombinedAverageRecentEarnings() (r float64, exists bool) {
	v := m.combined_average_recent_earnings
	if v == nil {
		return
	}
	return *v, true
}

// OldCombinedAverageRecentEarnings returns the old "combined_average_recent_earnings" field's value of the UpworkFreelancer entity.
// If the UpworkFreelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkFreelancerMutation) OldCombinedAverageRecentEarnings(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCombinedAverageRecentEarnings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCombinedAverageRecentEarnings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCombinedAverageRecentEarnings: %w", err)
	}
	return oldValue.CombinedAverageRecentEarnings, nil
}

// AddCombinedAverageRecentEarnings adds f to the "combined_average_recent_earnings" field.
func (m *UpworkFreelancerMutation) AddCombinedAverageRecentEarnings(f float64) {
	if m.addcombined_average_recent_earnings != nil {
		*m.addcombined_average_recent_earnings += f
	} else {
		m.addcombined_average_recent_earnings = &f
	}
}

// AddedCombinedAverageRecentEarnings returns the value that was added to the "combined_average_recent_earnings" field in this mutation.
func (m *UpworkFreelancerMutation) AddedCombinedAverageRecentEarnings() (r float64, exists bool) {
	v := m.addcombined_average_recent_earnings
	if v == nil {
		return
	}
	return *v, true
}

// ResetCombinedAverageRecentEarnings resets all changes to the "combined_average_recent_earnings" field.
func (m *UpworkFreelancerMutation) ResetCombinedAverageRecentEarnings() {
	m.combined_average_recent_earnings = nil
	m.addcombined_average_recent_earnings = nil
}

// SetCombinedRecentEarnings sets the "combined_recent_earnings" field.
func (m *UpworkFreelancerMutation) SetCombinedRecentEarnings(f float64) {
	m.combined_recent_earnings = &f
	m.addcombined_recent_earnings = nil
}

// CombinedRecentEarnings returns the value of the "combined_recent_earnings" field in the mutation.
func (m *UpworkFreelancerMutation) CombinedRecentEarnings() (r float64, exists bool) {
	v := m.combined_recent_earnings
	if v == nil {
		return
	}
	return *v, true
}

// OldCombinedRecentEarnings returns the old "combined_recent_earnings" field's value of the UpworkFreelancer entity.
// If the UpworkFreelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkFreelancerMutation) OldCombinedRecentEarnings(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCombinedRecentEarnings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCombinedRecentEarnings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCombinedRecentEarnings: %w", err)
	}
	return oldValue.CombinedRecentEarnings, nil
}

// AddCombinedRecentEarnings adds f to the "combined_recent_earnings" field.
func (m *UpworkFreelancerMutation) AddCombinedRecentEarnings(f float64) {
	if m.addcombined_recent_earnings != nil {
		*m.addcombined_recent_earnings += f
	} else {
		m.addcombined_recent_earnings = &f
	}
}

// AddedCombinedRecentEarnings returns the value that was added to the "combined_recent_earnings" field in this mutation.
func (m *UpworkFreelancerMutation) AddedCombinedRecentEarnings() (r float64, exists bool) {
	v := m.addcombined_recent_earnings
	if v == nil {
		return
	}
	return *v, true
}

// ResetCombinedRecentEarnings resets all changes to the "combined_recent_earnings" field.
func (m *UpworkFreelancerMutation) ResetCombinedRecentEarnings() {
	m.combined_recent_earnings = nil
	m.addcombined_recent_earnings = nil
}

// SetCombinedTotalEarnings sets the "combined_total_earnings" field.
func (m *UpworkFreelancerMutation) SetCombinedTotalEarnings(f float64) {
	m.combined_total_earnings = &f
	m.addcombined_total_earnings = nil
}

// CombinedTotalEarnings returns the value of the "combined_total_earnings" field in the mutation.
func (m *UpworkFreelancerMutation) CombinedTotalEarnings() (r float64, exists bool) {
	v := m.combined_total_earnings
	if v == nil {
		return
	}
	return *v, true
}

// OldCombinedTotalEarnings returns the old "combined_total_earnings" field's value of the UpworkFreelancer entity.
// If the UpworkFreelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkFreelancerMutation) OldCombinedTotalEarnings(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCombinedTotalEarnings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCombinedTotalEarnings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCombinedTotalEarnings: %w", err)
	}
	return oldValue.CombinedTotalEarnings, nil
}

// AddCombinedTotalEarnings adds f to the "combined_total_earnings" field.
func (m *UpworkFreelancerMutation) AddCombinedTotalEarnings(f float64) {
	if m.addcombined_total_earnings != nil {
		*m.addcombined_total_earnings += f
	} else {
		m.addcombined_total_earnings = &f
	}
}

// AddedCombinedTotalEarnings returns the value that was added to the "combined_total_earnings" field in this mutation.
func (m *UpworkFreelancerMutation) AddedCombinedTotalEarnings() (r float64, exists bool) {
	v := m.addcombined_total_earnings
	if v == nil {
		return
	}
	return *v, true
}

// ResetCombinedTotalEarnings resets all changes to the "combined_total_earnings" field.
func (m *UpworkFreelancerMutation) ResetCombinedTotalEarnings() {
	m.combined_total_earnings = nil
	m.addcombined_total_earnings = nil
}

// SetCombinedTotalRevenue sets the "combined_total_revenue" field.
func (m *UpworkFreelancerMutation) SetCombinedTotalRevenue(f float64) {
	m.combined_total_revenue = &f
	m.addcombined_total_revenue = nil
}

// CombinedTotalRevenue returns the value of the "combined_total_revenue" field in the mutation.
func (m *UpworkFreelancerMutation) CombinedTotalRevenue() (r float64, exists bool) {
	v := m.combined_total_revenue
	if v == nil {
		return
	}
	return *v, true
}

// OldCombinedTotalRevenue returns the old "combined_total_revenue" field's value of the UpworkFreelancer entity.
// If the UpworkFreelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkFreelancerMutation) OldCombinedTotalRevenue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCombinedTotalRevenue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCombinedTotalRevenue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCombinedTotalRevenue: %w", err)
	}
	return oldValue.CombinedTotalRevenue, nil
}

// AddCombinedTotalRevenue adds f to the "combined_total_revenue" field.
func (m *UpworkFreelancerMutation) AddCombinedTotalRevenue(f float64) {
	if m.addcombined_total_revenue != nil {
		*m.addcombined_total_revenue += f
	} else {
		m.addcombined_total_revenue = &f
	}
}

// AddedCombinedTotalRevenue returns the value that was added to the "combined_total_revenue" field in this mutation.
func (m *UpworkFreelancerMutation) AddedCombinedTotalRevenue() (r float64, exists bool) {
	v := m.addcombined_total_revenue
	if v == nil {
		return
	}
	return *v, true
}

// ResetCombinedTotalRevenue resets all changes to the "combined_total_revenue" field.
func (m *UpworkFreelancerMutation) ResetCombinedTotalRevenue() {
	m.combined_total_revenue = nil
	m.addcombined_total_revenue = nil
}

// SetRecentEarnings sets the "recent_earnings" field.
func (m *UpworkFreelancerMutation) SetRecentEarnings(f float64) {
	m.recent_earnings = &f
	m.addrecent_earnings = nil
}

// RecentEarnings returns the value of the "recent_earnings" field in the mutation.
func (m *UpworkFreelancerMutation) RecentEarnings() (r float64, exists bool) {
	v := m.recent_earnings
	if v == nil {
		return
	}
	return *v, true
}

// OldRecentEarnings returns the old "recent_earnings" field's value of the UpworkFreelancer entity.
// If the UpworkFreelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkFreelancerMutation) OldRecentEarnings(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecentEarnings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecentEarnings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecentEarnings: %w", err)
	}
	return oldValue.RecentEarnings, nil
}

// AddRecentEarnings adds f to the "recent_earnings" field.
func (m *UpworkFreelancerMutation) AddRecentEarnings(f float64) {
	if m.addrecent_earnings != nil {
		*m.addrecent_earnings += f
	} else {
		m.addrecent_earnings = &f
	}
}

// AddedRecentEarnings returns the value that was added to the "recent_earnings" field in this mutation.
func (m *UpworkFreelancerMutation) AddedRecentEarnings() (r float64, exists bool) {
	v := m.addrecent_earnings
	if v == nil {
		return
	}
	return *v, true
}

// ResetRecentEarnings resets all changes to the "recent_earnings" field.
func (m *UpworkFreelancerMutation) ResetRecentEarnings() {
	m.recent_earnings = nil
	m.addrecent_earnings = nil
}

// SetTotalRevenue sets the "total_revenue" field.
func (m *UpworkFreelancerMutation) SetTotalRevenue(f float64) {
	m.total_revenue = &f
	m.addtotal_revenue = nil
}

// TotalRevenue returns the value of the "total_revenue" field in the mutation.
func (m *UpworkFreelancerMutation) TotalRevenue() (r float64, exists bool) {
	v := m.total_revenue
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalRevenue returns the old "total_revenue" field's value of the UpworkFreelancer entity.
// If the UpworkFreelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkFreelancerMutation) OldTotalRevenue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalRevenue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalRevenue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalRevenue: %w", err)
	}
	return oldValue.TotalRevenue, nil
}

// AddTotalRevenue adds f to the "total_revenue" field.
func (m *UpworkFreelancerMutation) AddTotalRevenue(f float64) {
	if m.addtotal_revenue != nil {
		*m.addtotal_revenue += f
	} else {
		m.addtotal_revenue = &f
	}
}

// AddedTotalRevenue returns the value that was added to the "total_revenue" field in this mutation.
func (m *UpworkFreelancerMutation) AddedTotalRevenue() (r float64, exists bool) {
	v := m.addtotal_revenue
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalRevenue resets all changes to the "total_revenue" field.
func (m *UpworkFreelancerMutation) ResetTotalRevenue() {
	m.total_revenue = nil
	m.addtotal_revenue = nil
}

// SetUprankScore sets the "uprank_score" field.
func (m *UpworkFreelancerMutation) SetUprankScore(i int) {
	m.uprank_score = &i
	m.adduprank_score = nil
}

// UprankScore returns the value of the "uprank_score" field in the mutation.
func (m *UpworkFreelancerMutation) UprankScore() (r int, exists bool) {
	v := m.uprank_score
	if v == nil {
		return
	}
	return *v, true
}

// OldUprankScore returns the old "uprank_score" field's value of the UpworkFreelancer entity.
// If the UpworkFreelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkFreelancerMutation) OldUprankScore(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUprankScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUprankScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUprankScore: %w", err)
	}
	return oldValue.UprankScore, nil
}

// AddUprankScore adds i to the "uprank_score" field.
func (m *UpworkFreelancerMutation) AddUprankScore(i int) {
	if m.adduprank_score != nil {
		*m.adduprank_score += i
	} else {
		m.adduprank_score = &i
	}
}

// AddedUprankScore returns the value that was added to the "uprank_score" field in this mutation.
func (m *UpworkFreelancerMutation) AddedUprankScore() (r int, exists bool) {
	v := m.adduprank_score
	if v == nil {
		return
	}
	return *v, true
}

// ClearUprankScore clears the value of the "uprank_score" field.
func (m *UpworkFreelancerMutation) ClearUprankScore() {
	m.uprank_score = nil
	m.adduprank_score = nil
	m.clearedFields[upworkfreelancer.FieldUprankScore] = struct{}{}
}

// UprankScoreCleared returns if the "uprank_score" field was cleared in this mutation.
func (m *UpworkFreelancerMutation) UprankScoreCleared() bool {
	_, ok := m.clearedFields[upworkfreelancer.FieldUprankScore]
	return ok
}

// ResetUprankScore resets all changes to the "uprank_score" field.
func (m *UpworkFreelancerMutation) ResetUprankScore() {
	m.uprank_score = nil
	m.adduprank_score = nil
	delete(m.clearedFields, upworkfreelancer.FieldUprankScore)
}

// SetUprankUpdatedAt sets the "uprank_updated_at" field.
func (m *UpworkFreelancerMutation) SetUprankUpdatedAt(t time.Time) {
	m.uprank_updated_at = &t
}

// UprankUpdatedAt returns the value of the "uprank_updated_at" field in the mutation.
func (m *UpworkFreelancerMutation) UprankUpdatedAt() (r time.Time, exists bool) {
	v := m.uprank_updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUprankUpdatedAt returns the old "uprank_updated_at" field's value of the UpworkFreelancer entity.
// If the UpworkFreelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkFreelancerMutation) OldUprankUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUprankUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUprankUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUprankUpdatedAt: %w", err)
	}
	return oldValue.UprankUpdatedAt, nil
}

// ResetUprankUpdatedAt resets all changes to the "uprank_updated_at" field.
func (m *UpworkFreelancerMutation) ResetUprankUpdatedAt() {
	m.uprank_updated_at = nil
}

// SetUprankReccomended sets the "uprank_reccomended" field.
func (m *UpworkFreelancerMutation) SetUprankReccomended(b bool) {
	m.uprank_reccomended = &b
}

// UprankReccomended returns the value of the "uprank_reccomended" field in the mutation.
func (m *UpworkFreelancerMutation) UprankReccomended() (r bool, exists bool) {
	v := m.uprank_reccomended
	if v == nil {
		return
	}
	return *v, true
}

// OldUprankReccomended returns the old "uprank_reccomended" field's value of the UpworkFreelancer entity.
// If the UpworkFreelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkFreelancerMutation) OldUprankReccomended(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUprankReccomended is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUprankReccomended requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUprankReccomended: %w", err)
	}
	return oldValue.UprankReccomended, nil
}

// ClearUprankReccomended clears the value of the "uprank_reccomended" field.
func (m *UpworkFreelancerMutation) ClearUprankReccomended() {
	m.uprank_reccomended = nil
	m.clearedFields[upworkfreelancer.FieldUprankReccomended] = struct{}{}
}

// UprankReccomendedCleared returns if the "uprank_reccomended" field was cleared in this mutation.
func (m *UpworkFreelancerMutation) UprankReccomendedCleared() bool {
	_, ok := m.clearedFields[upworkfreelancer.FieldUprankReccomended]
	return ok
}

// ResetUprankReccomended resets all changes to the "uprank_reccomended" field.
func (m *UpworkFreelancerMutation) ResetUprankReccomended() {
	m.uprank_reccomended = nil
	delete(m.clearedFields, upworkfreelancer.FieldUprankReccomended)
}

// SetUprankReccomendedReasons sets the "uprank_reccomended_reasons" field.
func (m *UpworkFreelancerMutation) SetUprankReccomendedReasons(s string) {
	m.uprank_reccomended_reasons = &s
}

// UprankReccomendedReasons returns the value of the "uprank_reccomended_reasons" field in the mutation.
func (m *UpworkFreelancerMutation) UprankReccomendedReasons() (r string, exists bool) {
	v := m.uprank_reccomended_reasons
	if v == nil {
		return
	}
	return *v, true
}

// OldUprankReccomendedReasons returns the old "uprank_reccomended_reasons" field's value of the UpworkFreelancer entity.
// If the UpworkFreelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkFreelancerMutation) OldUprankReccomendedReasons(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUprankReccomendedReasons is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUprankReccomendedReasons requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUprankReccomendedReasons: %w", err)
	}
	return oldValue.UprankReccomendedReasons, nil
}

// ClearUprankReccomendedReasons clears the value of the "uprank_reccomended_reasons" field.
func (m *UpworkFreelancerMutation) ClearUprankReccomendedReasons() {
	m.uprank_reccomended_reasons = nil
	m.clearedFields[upworkfreelancer.FieldUprankReccomendedReasons] = struct{}{}
}

// UprankReccomendedReasonsCleared returns if the "uprank_reccomended_reasons" field was cleared in this mutation.
func (m *UpworkFreelancerMutation) UprankReccomendedReasonsCleared() bool {
	_, ok := m.clearedFields[upworkfreelancer.FieldUprankReccomendedReasons]
	return ok
}

// ResetUprankReccomendedReasons resets all changes to the "uprank_reccomended_reasons" field.
func (m *UpworkFreelancerMutation) ResetUprankReccomendedReasons() {
	m.uprank_reccomended_reasons = nil
	delete(m.clearedFields, upworkfreelancer.FieldUprankReccomendedReasons)
}

// SetUprankNotEnoughData sets the "uprank_not_enough_data" field.
func (m *UpworkFreelancerMutation) SetUprankNotEnoughData(b bool) {
	m.uprank_not_enough_data = &b
}

// UprankNotEnoughData returns the value of the "uprank_not_enough_data" field in the mutation.
func (m *UpworkFreelancerMutation) UprankNotEnoughData() (r bool, exists bool) {
	v := m.uprank_not_enough_data
	if v == nil {
		return
	}
	return *v, true
}

// OldUprankNotEnoughData returns the old "uprank_not_enough_data" field's value of the UpworkFreelancer entity.
// If the UpworkFreelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkFreelancerMutation) OldUprankNotEnoughData(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUprankNotEnoughData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUprankNotEnoughData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUprankNotEnoughData: %w", err)
	}
	return oldValue.UprankNotEnoughData, nil
}

// ClearUprankNotEnoughData clears the value of the "uprank_not_enough_data" field.
func (m *UpworkFreelancerMutation) ClearUprankNotEnoughData() {
	m.uprank_not_enough_data = nil
	m.clearedFields[upworkfreelancer.FieldUprankNotEnoughData] = struct{}{}
}

// UprankNotEnoughDataCleared returns if the "uprank_not_enough_data" field was cleared in this mutation.
func (m *UpworkFreelancerMutation) UprankNotEnoughDataCleared() bool {
	_, ok := m.clearedFields[upworkfreelancer.FieldUprankNotEnoughData]
	return ok
}

// ResetUprankNotEnoughData resets all changes to the "uprank_not_enough_data" field.
func (m *UpworkFreelancerMutation) ResetUprankNotEnoughData() {
	m.uprank_not_enough_data = nil
	delete(m.clearedFields, upworkfreelancer.FieldUprankNotEnoughData)
}

// AddUpworkJobIDs adds the "upwork_job" edge to the UpworkJob entity by ids.
func (m *UpworkFreelancerMutation) AddUpworkJobIDs(ids ...string) {
	if m.upwork_job == nil {
		m.upwork_job = make(map[string]struct{})
	}
	for i := range ids {
		m.upwork_job[ids[i]] = struct{}{}
	}
}

// ClearUpworkJob clears the "upwork_job" edge to the UpworkJob entity.
func (m *UpworkFreelancerMutation) ClearUpworkJob() {
	m.clearedupwork_job = true
}

// UpworkJobCleared reports if the "upwork_job" edge to the UpworkJob entity was cleared.
func (m *UpworkFreelancerMutation) UpworkJobCleared() bool {
	return m.clearedupwork_job
}

// RemoveUpworkJobIDs removes the "upwork_job" edge to the UpworkJob entity by IDs.
func (m *UpworkFreelancerMutation) RemoveUpworkJobIDs(ids ...string) {
	if m.removedupwork_job == nil {
		m.removedupwork_job = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.upwork_job, ids[i])
		m.removedupwork_job[ids[i]] = struct{}{}
	}
}

// RemovedUpworkJob returns the removed IDs of the "upwork_job" edge to the UpworkJob entity.
func (m *UpworkFreelancerMutation) RemovedUpworkJobIDs() (ids []string) {
	for id := range m.removedupwork_job {
		ids = append(ids, id)
	}
	return
}

// UpworkJobIDs returns the "upwork_job" edge IDs in the mutation.
func (m *UpworkFreelancerMutation) UpworkJobIDs() (ids []string) {
	for id := range m.upwork_job {
		ids = append(ids, id)
	}
	return
}

// ResetUpworkJob resets all changes to the "upwork_job" edge.
func (m *UpworkFreelancerMutation) ResetUpworkJob() {
	m.upwork_job = nil
	m.clearedupwork_job = false
	m.removedupwork_job = nil
}

// AddAttachmentIDs adds the "attachments" edge to the AttachmentRef entity by ids.
func (m *UpworkFreelancerMutation) AddAttachmentIDs(ids ...int) {
	if m.attachments == nil {
		m.attachments = make(map[int]struct{})
	}
	for i := range ids {
		m.attachments[ids[i]] = struct{}{}
	}
}

// ClearAttachments clears the "attachments" edge to the AttachmentRef entity.
func (m *UpworkFreelancerMutation) ClearAttachments() {
	m.clearedattachments = true
}

// AttachmentsCleared reports if the "attachments" edge to the AttachmentRef entity was cleared.
func (m *UpworkFreelancerMutation) AttachmentsCleared() bool {
	return m.clearedattachments
}

// RemoveAttachmentIDs removes the "attachments" edge to the AttachmentRef entity by IDs.
func (m *UpworkFreelancerMutation) RemoveAttachmentIDs(ids ...int) {
	if m.removedattachments == nil {
		m.removedattachments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.attachments, ids[i])
		m.removedattachments[ids[i]] = struct{}{}
	}
}

// RemovedAttachments returns the removed IDs of the "attachments" edge to the AttachmentRef entity.
func (m *UpworkFreelancerMutation) RemovedAttachmentsIDs() (ids []int) {
	for id := range m.removedattachments {
		ids = append(ids, id)
	}
	return
}

// AttachmentsIDs returns the "attachments" edge IDs in the mutation.
func (m *UpworkFreelancerMutation) AttachmentsIDs() (ids []int) {
	for id := range m.attachments {
		ids = append(ids, id)
	}
	return
}

// ResetAttachments resets all changes to the "attachments" edge.
func (m *UpworkFreelancerMutation) ResetAttachments() {
	m.attachments = nil
	m.clearedattachments = false
	m.removedattachments = nil
}

// AddWorkHistoryIDs adds the "work_histories" edge to the WorkHistory entity by ids.
func (m *UpworkFreelancerMutation) AddWorkHistoryIDs(ids ...int) {
	if m.work_histories == nil {
		m.work_histories = make(map[int]struct{})
	}
	for i := range ids {
		m.work_histories[ids[i]] = struct{}{}
	}
}

// ClearWorkHistories clears the "work_histories" edge to the WorkHistory entity.
func (m *UpworkFreelancerMutation) ClearWorkHistories() {
	m.clearedwork_histories = true
}

// WorkHistoriesCleared reports if the "work_histories" edge to the WorkHistory entity was cleared.
func (m *UpworkFreelancerMutation) WorkHistoriesCleared() bool {
	return m.clearedwork_histories
}

// RemoveWorkHistoryIDs removes the "work_histories" edge to the WorkHistory entity by IDs.
func (m *UpworkFreelancerMutation) RemoveWorkHistoryIDs(ids ...int) {
	if m.removedwork_histories == nil {
		m.removedwork_histories = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.work_histories, ids[i])
		m.removedwork_histories[ids[i]] = struct{}{}
	}
}

// RemovedWorkHistories returns the removed IDs of the "work_histories" edge to the WorkHistory entity.
func (m *UpworkFreelancerMutation) RemovedWorkHistoriesIDs() (ids []int) {
	for id := range m.removedwork_histories {
		ids = append(ids, id)
	}
	return
}

// WorkHistoriesIDs returns the "work_histories" edge IDs in the mutation.
func (m *UpworkFreelancerMutation) WorkHistoriesIDs() (ids []int) {
	for id := range m.work_histories {
		ids = append(ids, id)
	}
	return
}

// ResetWorkHistories resets all changes to the "work_histories" edge.
func (m *UpworkFreelancerMutation) ResetWorkHistories() {
	m.work_histories = nil
	m.clearedwork_histories = false
	m.removedwork_histories = nil
}

// Where appends a list predicates to the UpworkFreelancerMutation builder.
func (m *UpworkFreelancerMutation) Where(ps ...predicate.UpworkFreelancer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpworkFreelancerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpworkFreelancerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpworkFreelancer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpworkFreelancerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpworkFreelancerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpworkFreelancer).
func (m *UpworkFreelancerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpworkFreelancerMutation) Fields() []string {
	fields := make([]string, 0, 38)
	if m.name != nil {
		fields = append(fields, upworkfreelancer.FieldName)
	}
	if m.title != nil {
		fields = append(fields, upworkfreelancer.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, upworkfreelancer.FieldDescription)
	}
	if m.city != nil {
		fields = append(fields, upworkfreelancer.FieldCity)
	}
	if m.country != nil {
		fields = append(fields, upworkfreelancer.FieldCountry)
	}
	if m.timezone != nil {
		fields = append(fields, upworkfreelancer.FieldTimezone)
	}
	if m.cv != nil {
		fields = append(fields, upworkfreelancer.FieldCv)
	}
	if m.ai_reccomended != nil {
		fields = append(fields, upworkfreelancer.FieldAiReccomended)
	}
	if m.fixed_charge_amount != nil {
		fields = append(fields, upworkfreelancer.FieldFixedChargeAmount)
	}
	if m.fixed_charge_currency != nil {
		fields = append(fields, upworkfreelancer.FieldFixedChargeCurrency)
	}
	if m.hourly_charge_amount != nil {
		fields = append(fields, upworkfreelancer.FieldHourlyChargeAmount)
	}
	if m.hourly_charge_currency != nil {
		fields = append(fields, upworkfreelancer.FieldHourlyChargeCurrency)
	}
	if m.invited != nil {
		fields = append(fields, upworkfreelancer.FieldInvited)
	}
	if m.photo_url != nil {
		fields = append(fields, upworkfreelancer.FieldPhotoURL)
	}
	if m.recent_hours != nil {
		fields = append(fields, upworkfreelancer.FieldRecentHours)
	}
	if m.total_hours != nil {
		fields = append(fields, upworkfreelancer.FieldTotalHours)
	}
	if m.total_portfolio_items != nil {
		fields = append(fields, upworkfreelancer.FieldTotalPortfolioItems)
	}
	if m.total_portfolio_v2_items != nil {
		fields = append(fields, upworkfreelancer.FieldTotalPortfolioV2Items)
	}
	if m.upwork_total_feedback != nil {
		fields = append(fields, upworkfreelancer.FieldUpworkTotalFeedback)
	}
	if m.upwork_recent_feedback != nil {
		fields = append(fields, upworkfreelancer.FieldUpworkRecentFeedback)
	}
	if m.upwork_top_rated_status != nil {
		fields = append(fields, upworkfreelancer.FieldUpworkTopRatedStatus)
	}
	if m.upwork_top_rated_plus_status != nil {
		fields = append(fields, upworkfreelancer.FieldUpworkTopRatedPlusStatus)
	}
	if m.upwork_sponsored != nil {
		fields = append(fields, upworkfreelancer.FieldUpworkSponsored)
	}
	if m.upwork_job_success_score != nil {
		fields = append(fields, upworkfreelancer.FieldUpworkJobSuccessScore)
	}
	if m.upwork_reccomended != nil {
		fields = append(fields, upworkfreelancer.FieldUpworkReccomended)
	}
	if m.skills != nil {
		fields = append(fields, upworkfreelancer.FieldSkills)
	}
	if m.average_recent_earnings != nil {
		fields = append(fields, upworkfreelancer.FieldAverageRecentEarnings)
	}
	if m.combined_average_recent_earnings != nil {
		fields = append(fields, upworkfreelancer.FieldCombinedAverageRecentEarnings)
	}
	if m.combined_recent_earnings != nil {
		fields = append(fields, upworkfreelancer.FieldCombinedRecentEarnings)
	}
	if m.combined_total_earnings != nil {
		fields = append(fields, upworkfreelancer.FieldCombinedTotalEarnings)
	}
	if m.combined_total_revenue != nil {
		fields = append(fields, upworkfreelancer.FieldCombinedTotalRevenue)
	}
	if m.recent_earnings != nil {
		fields = append(fields, upworkfreelancer.FieldRecentEarnings)
	}
	if m.total_revenue != nil {
		fields = append(fields, upworkfreelancer.FieldTotalRevenue)
	}
	if m.uprank_score != nil {
		fields = append(fields, upworkfreelancer.FieldUprankScore)
	}
	if m.uprank_updated_at != nil {
		fields = append(fields, upworkfreelancer.FieldUprankUpdatedAt)
	}
	if m.uprank_reccomended != nil {
		fields = append(fields, upworkfreelancer.FieldUprankReccomended)
	}
	if m.uprank_reccomended_reasons != nil {
		fields = append(fields, upworkfreelancer.FieldUprankReccomendedReasons)
	}
	if m.uprank_not_enough_data != nil {
		fields = append(fields, upworkfreelancer.FieldUprankNotEnoughData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpworkFreelancerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upworkfreelancer.FieldName:
		return m.Name()
	case upworkfreelancer.FieldTitle:
		return m.Title()
	case upworkfreelancer.FieldDescription:
		return m.Description()
	case upworkfreelancer.FieldCity:
		return m.City()
	case upworkfreelancer.FieldCountry:
		return m.Country()
	case upworkfreelancer.FieldTimezone:
		return m.Timezone()
	case upworkfreelancer.FieldCv:
		return m.Cv()
	case upworkfreelancer.FieldAiReccomended:
		return m.AiReccomended()
	case upworkfreelancer.FieldFixedChargeAmount:
		return m.FixedChargeAmount()
	case upworkfreelancer.FieldFixedChargeCurrency:
		return m.FixedChargeCurrency()
	case upworkfreelancer.FieldHourlyChargeAmount:
		return m.HourlyChargeAmount()
	case upworkfreelancer.FieldHourlyChargeCurrency:
		return m.HourlyChargeCurrency()
	case upworkfreelancer.FieldInvited:
		return m.Invited()
	case upworkfreelancer.FieldPhotoURL:
		return m.PhotoURL()
	case upworkfreelancer.FieldRecentHours:
		return m.RecentHours()
	case upworkfreelancer.FieldTotalHours:
		return m.TotalHours()
	case upworkfreelancer.FieldTotalPortfolioItems:
		return m.TotalPortfolioItems()
	case upworkfreelancer.FieldTotalPortfolioV2Items:
		return m.TotalPortfolioV2Items()
	case upworkfreelancer.FieldUpworkTotalFeedback:
		return m.UpworkTotalFeedback()
	case upworkfreelancer.FieldUpworkRecentFeedback:
		return m.UpworkRecentFeedback()
	case upworkfreelancer.FieldUpworkTopRatedStatus:
		return m.UpworkTopRatedStatus()
	case upworkfreelancer.FieldUpworkTopRatedPlusStatus:
		return m.UpworkTopRatedPlusStatus()
	case upworkfreelancer.FieldUpworkSponsored:
		return m.UpworkSponsored()
	case upworkfreelancer.FieldUpworkJobSuccessScore:
		return m.UpworkJobSuccessScore()
	case upworkfreelancer.FieldUpworkReccomended:
		return m.UpworkReccomended()
	case upworkfreelancer.FieldSkills:
		return m.Skills()
	case upworkfreelancer.FieldAverageRecentEarnings:
		return m.AverageRecentEarnings()
	case upworkfreelancer.FieldCombinedAverageRecentEarnings:
		return m.CombinedAverageRecentEarnings()
	case upworkfreelancer.FieldCombinedRecentEarnings:
		return m.CombinedRecentEarnings()
	case upworkfreelancer.FieldCombinedTotalEarnings:
		return m.CombinedTotalEarnings()
	case upworkfreelancer.FieldCombinedTotalRevenue:
		return m.CombinedTotalRevenue()
	case upworkfreelancer.FieldRecentEarnings:
		return m.RecentEarnings()
	case upworkfreelancer.FieldTotalRevenue:
		return m.TotalRevenue()
	case upworkfreelancer.FieldUprankScore:
		return m.UprankScore()
	case upworkfreelancer.FieldUprankUpdatedAt:
		return m.UprankUpdatedAt()
	case upworkfreelancer.FieldUprankReccomended:
		return m.UprankReccomended()
	case upworkfreelancer.FieldUprankReccomendedReasons:
		return m.UprankReccomendedReasons()
	case upworkfreelancer.FieldUprankNotEnoughData:
		return m.UprankNotEnoughData()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpworkFreelancerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upworkfreelancer.FieldName:
		return m.OldName(ctx)
	case upworkfreelancer.FieldTitle:
		return m.OldTitle(ctx)
	case upworkfreelancer.FieldDescription:
		return m.OldDescription(ctx)
	case upworkfreelancer.FieldCity:
		return m.OldCity(ctx)
	case upworkfreelancer.FieldCountry:
		return m.OldCountry(ctx)
	case upworkfreelancer.FieldTimezone:
		return m.OldTimezone(ctx)
	case upworkfreelancer.FieldCv:
		return m.OldCv(ctx)
	case upworkfreelancer.FieldAiReccomended:
		return m.OldAiReccomended(ctx)
	case upworkfreelancer.FieldFixedChargeAmount:
		return m.OldFixedChargeAmount(ctx)
	case upworkfreelancer.FieldFixedChargeCurrency:
		return m.OldFixedChargeCurrency(ctx)
	case upworkfreelancer.FieldHourlyChargeAmount:
		return m.OldHourlyChargeAmount(ctx)
	case upworkfreelancer.FieldHourlyChargeCurrency:
		return m.OldHourlyChargeCurrency(ctx)
	case upworkfreelancer.FieldInvited:
		return m.OldInvited(ctx)
	case upworkfreelancer.FieldPhotoURL:
		return m.OldPhotoURL(ctx)
	case upworkfreelancer.FieldRecentHours:
		return m.OldRecentHours(ctx)
	case upworkfreelancer.FieldTotalHours:
		return m.OldTotalHours(ctx)
	case upworkfreelancer.FieldTotalPortfolioItems:
		return m.OldTotalPortfolioItems(ctx)
	case upworkfreelancer.FieldTotalPortfolioV2Items:
		return m.OldTotalPortfolioV2Items(ctx)
	case upworkfreelancer.FieldUpworkTotalFeedback:
		return m.OldUpworkTotalFeedback(ctx)
	case upworkfreelancer.FieldUpworkRecentFeedback:
		return m.OldUpworkRecentFeedback(ctx)
	case upworkfreelancer.FieldUpworkTopRatedStatus:
		return m.OldUpworkTopRatedStatus(ctx)
	case upworkfreelancer.FieldUpworkTopRatedPlusStatus:
		return m.OldUpworkTopRatedPlusStatus(ctx)
	case upworkfreelancer.FieldUpworkSponsored:
		return m.OldUpworkSponsored(ctx)
	case upworkfreelancer.FieldUpworkJobSuccessScore:
		return m.OldUpworkJobSuccessScore(ctx)
	case upworkfreelancer.FieldUpworkReccomended:
		return m.OldUpworkReccomended(ctx)
	case upworkfreelancer.FieldSkills:
		return m.OldSkills(ctx)
	case upworkfreelancer.FieldAverageRecentEarnings:
		return m.OldAverageRecentEarnings(ctx)
	case upworkfreelancer.FieldCombinedAverageRecentEarnings:
		return m.OldCombinedAverageRecentEarnings(ctx)
	case upworkfreelancer.FieldCombinedRecentEarnings:
		return m.OldCombinedRecentEarnings(ctx)
	case upworkfreelancer.FieldCombinedTotalEarnings:
		return m.OldCombinedTotalEarnings(ctx)
	case upworkfreelancer.FieldCombinedTotalRevenue:
		return m.OldCombinedTotalRevenue(ctx)
	case upworkfreelancer.FieldRecentEarnings:
		return m.OldRecentEarnings(ctx)
	case upworkfreelancer.FieldTotalRevenue:
		return m.OldTotalRevenue(ctx)
	case upworkfreelancer.FieldUprankScore:
		return m.OldUprankScore(ctx)
	case upworkfreelancer.FieldUprankUpdatedAt:
		return m.OldUprankUpdatedAt(ctx)
	case upworkfreelancer.FieldUprankReccomended:
		return m.OldUprankReccomended(ctx)
	case upworkfreelancer.FieldUprankReccomendedReasons:
		return m.OldUprankReccomendedReasons(ctx)
	case upworkfreelancer.FieldUprankNotEnoughData:
		return m.OldUprankNotEnoughData(ctx)
	}
	return nil, fmt.Errorf("unknown UpworkFreelancer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpworkFreelancerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upworkfreelancer.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case upworkfreelancer.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case upworkfreelancer.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case upworkfreelancer.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case upworkfreelancer.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case upworkfreelancer.FieldTimezone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimezone(v)
		return nil
	case upworkfreelancer.FieldCv:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCv(v)
		return nil
	case upworkfreelancer.FieldAiReccomended:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAiReccomended(v)
		return nil
	case upworkfreelancer.FieldFixedChargeAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFixedChargeAmount(v)
		return nil
	case upworkfreelancer.FieldFixedChargeCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFixedChargeCurrency(v)
		return nil
	case upworkfreelancer.FieldHourlyChargeAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHourlyChargeAmount(v)
		return nil
	case upworkfreelancer.FieldHourlyChargeCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHourlyChargeCurrency(v)
		return nil
	case upworkfreelancer.FieldInvited:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvited(v)
		return nil
	case upworkfreelancer.FieldPhotoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhotoURL(v)
		return nil
	case upworkfreelancer.FieldRecentHours:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecentHours(v)
		return nil
	case upworkfreelancer.FieldTotalHours:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalHours(v)
		return nil
	case upworkfreelancer.FieldTotalPortfolioItems:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalPortfolioItems(v)
		return nil
	case upworkfreelancer.FieldTotalPortfolioV2Items:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalPortfolioV2Items(v)
		return nil
	case upworkfreelancer.FieldUpworkTotalFeedback:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpworkTotalFeedback(v)
		return nil
	case upworkfreelancer.FieldUpworkRecentFeedback:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpworkRecentFeedback(v)
		return nil
	case upworkfreelancer.FieldUpworkTopRatedStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpworkTopRatedStatus(v)
		return nil
	case upworkfreelancer.FieldUpworkTopRatedPlusStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpworkTopRatedPlusStatus(v)
		return nil
	case upworkfreelancer.FieldUpworkSponsored:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpworkSponsored(v)
		return nil
	case upworkfreelancer.FieldUpworkJobSuccessScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpworkJobSuccessScore(v)
		return nil
	case upworkfreelancer.FieldUpworkReccomended:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpworkReccomended(v)
		return nil
	case upworkfreelancer.FieldSkills:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkills(v)
		return nil
	case upworkfreelancer.FieldAverageRecentEarnings:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAverageRecentEarnings(v)
		return nil
	case upworkfreelancer.FieldCombinedAverageRecentEarnings:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCombinedAverageRecentEarnings(v)
		return nil
	case upworkfreelancer.FieldCombinedRecentEarnings:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCombinedRecentEarnings(v)
		return nil
	case upworkfreelancer.FieldCombinedTotalEarnings:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCombinedTotalEarnings(v)
		return nil
	case upworkfreelancer.FieldCombinedTotalRevenue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCombinedTotalRevenue(v)
		return nil
	case upworkfreelancer.FieldRecentEarnings:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecentEarnings(v)
		return nil
	case upworkfreelancer.FieldTotalRevenue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalRevenue(v)
		return nil
	case upworkfreelancer.FieldUprankScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUprankScore(v)
		return nil
	case upworkfreelancer.FieldUprankUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUprankUpdatedAt(v)
		return nil
	case upworkfreelancer.FieldUprankReccomended:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUprankReccomended(v)
		return nil
	case upworkfreelancer.FieldUprankReccomendedReasons:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUprankReccomendedReasons(v)
		return nil
	case upworkfreelancer.FieldUprankNotEnoughData:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUprankNotEnoughData(v)
		return nil
	}
	return fmt.Errorf("unknown UpworkFreelancer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpworkFreelancerMutation) AddedFields() []string {
	var fields []string
	if m.addfixed_charge_amount != nil {
		fields = append(fields, upworkfreelancer.FieldFixedChargeAmount)
	}
	if m.addhourly_charge_amount != nil {
		fields = append(fields, upworkfreelancer.FieldHourlyChargeAmount)
	}
	if m.addrecent_hours != nil {
		fields = append(fields, upworkfreelancer.FieldRecentHours)
	}
	if m.addtotal_hours != nil {
		fields = append(fields, upworkfreelancer.FieldTotalHours)
	}
	if m.addtotal_portfolio_items != nil {
		fields = append(fields, upworkfreelancer.FieldTotalPortfolioItems)
	}
	if m.addtotal_portfolio_v2_items != nil {
		fields = append(fields, upworkfreelancer.FieldTotalPortfolioV2Items)
	}
	if m.addupwork_total_feedback != nil {
		fields = append(fields, upworkfreelancer.FieldUpworkTotalFeedback)
	}
	if m.addupwork_recent_feedback != nil {
		fields = append(fields, upworkfreelancer.FieldUpworkRecentFeedback)
	}
	if m.addupwork_job_success_score != nil {
		fields = append(fields, upworkfreelancer.FieldUpworkJobSuccessScore)
	}
	if m.addaverage_recent_earnings != nil {
		fields = append(fields, upworkfreelancer.FieldAverageRecentEarnings)
	}
	if m.addcombined_average_recent_earnings != nil {
		fields = append(fields, upworkfreelancer.FieldCombinedAverageRecentEarnings)
	}
	if m.addcombined_recent_earnings != nil {
		fields = append(fields, upworkfreelancer.FieldCombinedRecentEarnings)
	}
	if m.addcombined_total_earnings != nil {
		fields = append(fields, upworkfreelancer.FieldCombinedTotalEarnings)
	}
	if m.addcombined_total_revenue != nil {
		fields = append(fields, upworkfreelancer.FieldCombinedTotalRevenue)
	}
	if m.addrecent_earnings != nil {
		fields = append(fields, upworkfreelancer.FieldRecentEarnings)
	}
	if m.addtotal_revenue != nil {
		fields = append(fields, upworkfreelancer.FieldTotalRevenue)
	}
	if m.adduprank_score != nil {
		fields = append(fields, upworkfreelancer.FieldUprankScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpworkFreelancerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upworkfreelancer.FieldFixedChargeAmount:
		return m.AddedFixedChargeAmount()
	case upworkfreelancer.FieldHourlyChargeAmount:
		return m.AddedHourlyChargeAmount()
	case upworkfreelancer.FieldRecentHours:
		return m.AddedRecentHours()
	case upworkfreelancer.FieldTotalHours:
		return m.AddedTotalHours()
	case upworkfreelancer.FieldTotalPortfolioItems:
		return m.AddedTotalPortfolioItems()
	case upworkfreelancer.FieldTotalPortfolioV2Items:
		return m.AddedTotalPortfolioV2Items()
	case upworkfreelancer.FieldUpworkTotalFeedback:
		return m.AddedUpworkTotalFeedback()
	case upworkfreelancer.FieldUpworkRecentFeedback:
		return m.AddedUpworkRecentFeedback()
	case upworkfreelancer.FieldUpworkJobSuccessScore:
		return m.AddedUpworkJobSuccessScore()
	case upworkfreelancer.FieldAverageRecentEarnings:
		return m.AddedAverageRecentEarnings()
	case upworkfreelancer.FieldCombinedAverageRecentEarnings:
		return m.AddedCombinedAverageRecentEarnings()
	case upworkfreelancer.FieldCombinedRecentEarnings:
		return m.AddedCombinedRecentEarnings()
	case upworkfreelancer.FieldCombinedTotalEarnings:
		return m.AddedCombinedTotalEarnings()
	case upworkfreelancer.FieldCombinedTotalRevenue:
		return m.AddedCombinedTotalRevenue()
	case upworkfreelancer.FieldRecentEarnings:
		return m.AddedRecentEarnings()
	case upworkfreelancer.FieldTotalRevenue:
		return m.AddedTotalRevenue()
	case upworkfreelancer.FieldUprankScore:
		return m.AddedUprankScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpworkFreelancerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upworkfreelancer.FieldFixedChargeAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFixedChargeAmount(v)
		return nil
	case upworkfreelancer.FieldHourlyChargeAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHourlyChargeAmount(v)
		return nil
	case upworkfreelancer.FieldRecentHours:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRecentHours(v)
		return nil
	case upworkfreelancer.FieldTotalHours:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalHours(v)
		return nil
	case upworkfreelancer.FieldTotalPortfolioItems:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalPortfolioItems(v)
		return nil
	case upworkfreelancer.FieldTotalPortfolioV2Items:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalPortfolioV2Items(v)
		return nil
	case upworkfreelancer.FieldUpworkTotalFeedback:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpworkTotalFeedback(v)
		return nil
	case upworkfreelancer.FieldUpworkRecentFeedback:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpworkRecentFeedback(v)
		return nil
	case upworkfreelancer.FieldUpworkJobSuccessScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpworkJobSuccessScore(v)
		return nil
	case upworkfreelancer.FieldAverageRecentEarnings:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAverageRecentEarnings(v)
		return nil
	case upworkfreelancer.FieldCombinedAverageRecentEarnings:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCombinedAverageRecentEarnings(v)
		return nil
	case upworkfreelancer.FieldCombinedRecentEarnings:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCombinedRecentEarnings(v)
		return nil
	case upworkfreelancer.FieldCombinedTotalEarnings:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCombinedTotalEarnings(v)
		return nil
	case upworkfreelancer.FieldCombinedTotalRevenue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCombinedTotalRevenue(v)
		return nil
	case upworkfreelancer.FieldRecentEarnings:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRecentEarnings(v)
		return nil
	case upworkfreelancer.FieldTotalRevenue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalRevenue(v)
		return nil
	case upworkfreelancer.FieldUprankScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUprankScore(v)
		return nil
	}
	return fmt.Errorf("unknown UpworkFreelancer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpworkFreelancerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upworkfreelancer.FieldFixedChargeAmount) {
		fields = append(fields, upworkfreelancer.FieldFixedChargeAmount)
	}
	if m.FieldCleared(upworkfreelancer.FieldHourlyChargeAmount) {
		fields = append(fields, upworkfreelancer.FieldHourlyChargeAmount)
	}
	if m.FieldCleared(upworkfreelancer.FieldUprankScore) {
		fields = append(fields, upworkfreelancer.FieldUprankScore)
	}
	if m.FieldCleared(upworkfreelancer.FieldUprankReccomended) {
		fields = append(fields, upworkfreelancer.FieldUprankReccomended)
	}
	if m.FieldCleared(upworkfreelancer.FieldUprankReccomendedReasons) {
		fields = append(fields, upworkfreelancer.FieldUprankReccomendedReasons)
	}
	if m.FieldCleared(upworkfreelancer.FieldUprankNotEnoughData) {
		fields = append(fields, upworkfreelancer.FieldUprankNotEnoughData)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpworkFreelancerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpworkFreelancerMutation) ClearField(name string) error {
	switch name {
	case upworkfreelancer.FieldFixedChargeAmount:
		m.ClearFixedChargeAmount()
		return nil
	case upworkfreelancer.FieldHourlyChargeAmount:
		m.ClearHourlyChargeAmount()
		return nil
	case upworkfreelancer.FieldUprankScore:
		m.ClearUprankScore()
		return nil
	case upworkfreelancer.FieldUprankReccomended:
		m.ClearUprankReccomended()
		return nil
	case upworkfreelancer.FieldUprankReccomendedReasons:
		m.ClearUprankReccomendedReasons()
		return nil
	case upworkfreelancer.FieldUprankNotEnoughData:
		m.ClearUprankNotEnoughData()
		return nil
	}
	return fmt.Errorf("unknown UpworkFreelancer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpworkFreelancerMutation) ResetField(name string) error {
	switch name {
	case upworkfreelancer.FieldName:
		m.ResetName()
		return nil
	case upworkfreelancer.FieldTitle:
		m.ResetTitle()
		return nil
	case upworkfreelancer.FieldDescription:
		m.ResetDescription()
		return nil
	case upworkfreelancer.FieldCity:
		m.ResetCity()
		return nil
	case upworkfreelancer.FieldCountry:
		m.ResetCountry()
		return nil
	case upworkfreelancer.FieldTimezone:
		m.ResetTimezone()
		return nil
	case upworkfreelancer.FieldCv:
		m.ResetCv()
		return nil
	case upworkfreelancer.FieldAiReccomended:
		m.ResetAiReccomended()
		return nil
	case upworkfreelancer.FieldFixedChargeAmount:
		m.ResetFixedChargeAmount()
		return nil
	case upworkfreelancer.FieldFixedChargeCurrency:
		m.ResetFixedChargeCurrency()
		return nil
	case upworkfreelancer.FieldHourlyChargeAmount:
		m.ResetHourlyChargeAmount()
		return nil
	case upworkfreelancer.FieldHourlyChargeCurrency:
		m.ResetHourlyChargeCurrency()
		return nil
	case upworkfreelancer.FieldInvited:
		m.ResetInvited()
		return nil
	case upworkfreelancer.FieldPhotoURL:
		m.ResetPhotoURL()
		return nil
	case upworkfreelancer.FieldRecentHours:
		m.ResetRecentHours()
		return nil
	case upworkfreelancer.FieldTotalHours:
		m.ResetTotalHours()
		return nil
	case upworkfreelancer.FieldTotalPortfolioItems:
		m.ResetTotalPortfolioItems()
		return nil
	case upworkfreelancer.FieldTotalPortfolioV2Items:
		m.ResetTotalPortfolioV2Items()
		return nil
	case upworkfreelancer.FieldUpworkTotalFeedback:
		m.ResetUpworkTotalFeedback()
		return nil
	case upworkfreelancer.FieldUpworkRecentFeedback:
		m.ResetUpworkRecentFeedback()
		return nil
	case upworkfreelancer.FieldUpworkTopRatedStatus:
		m.ResetUpworkTopRatedStatus()
		return nil
	case upworkfreelancer.FieldUpworkTopRatedPlusStatus:
		m.ResetUpworkTopRatedPlusStatus()
		return nil
	case upworkfreelancer.FieldUpworkSponsored:
		m.ResetUpworkSponsored()
		return nil
	case upworkfreelancer.FieldUpworkJobSuccessScore:
		m.ResetUpworkJobSuccessScore()
		return nil
	case upworkfreelancer.FieldUpworkReccomended:
		m.ResetUpworkReccomended()
		return nil
	case upworkfreelancer.FieldSkills:
		m.ResetSkills()
		return nil
	case upworkfreelancer.FieldAverageRecentEarnings:
		m.ResetAverageRecentEarnings()
		return nil
	case upworkfreelancer.FieldCombinedAverageRecentEarnings:
		m.ResetCombinedAverageRecentEarnings()
		return nil
	case upworkfreelancer.FieldCombinedRecentEarnings:
		m.ResetCombinedRecentEarnings()
		return nil
	case upworkfreelancer.FieldCombinedTotalEarnings:
		m.ResetCombinedTotalEarnings()
		return nil
	case upworkfreelancer.FieldCombinedTotalRevenue:
		m.ResetCombinedTotalRevenue()
		return nil
	case upworkfreelancer.FieldRecentEarnings:
		m.ResetRecentEarnings()
		return nil
	case upworkfreelancer.FieldTotalRevenue:
		m.ResetTotalRevenue()
		return nil
	case upworkfreelancer.FieldUprankScore:
		m.ResetUprankScore()
		return nil
	case upworkfreelancer.FieldUprankUpdatedAt:
		m.ResetUprankUpdatedAt()
		return nil
	case upworkfreelancer.FieldUprankReccomended:
		m.ResetUprankReccomended()
		return nil
	case upworkfreelancer.FieldUprankReccomendedReasons:
		m.ResetUprankReccomendedReasons()
		return nil
	case upworkfreelancer.FieldUprankNotEnoughData:
		m.ResetUprankNotEnoughData()
		return nil
	}
	return fmt.Errorf("unknown UpworkFreelancer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpworkFreelancerMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.upwork_job != nil {
		edges = append(edges, upworkfreelancer.EdgeUpworkJob)
	}
	if m.attachments != nil {
		edges = append(edges, upworkfreelancer.EdgeAttachments)
	}
	if m.work_histories != nil {
		edges = append(edges, upworkfreelancer.EdgeWorkHistories)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpworkFreelancerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case upworkfreelancer.EdgeUpworkJob:
		ids := make([]ent.Value, 0, len(m.upwork_job))
		for id := range m.upwork_job {
			ids = append(ids, id)
		}
		return ids
	case upworkfreelancer.EdgeAttachments:
		ids := make([]ent.Value, 0, len(m.attachments))
		for id := range m.attachments {
			ids = append(ids, id)
		}
		return ids
	case upworkfreelancer.EdgeWorkHistories:
		ids := make([]ent.Value, 0, len(m.work_histories))
		for id := range m.work_histories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpworkFreelancerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedupwork_job != nil {
		edges = append(edges, upworkfreelancer.EdgeUpworkJob)
	}
	if m.removedattachments != nil {
		edges = append(edges, upworkfreelancer.EdgeAttachments)
	}
	if m.removedwork_histories != nil {
		edges = append(edges, upworkfreelancer.EdgeWorkHistories)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpworkFreelancerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case upworkfreelancer.EdgeUpworkJob:
		ids := make([]ent.Value, 0, len(m.removedupwork_job))
		for id := range m.removedupwork_job {
			ids = append(ids, id)
		}
		return ids
	case upworkfreelancer.EdgeAttachments:
		ids := make([]ent.Value, 0, len(m.removedattachments))
		for id := range m.removedattachments {
			ids = append(ids, id)
		}
		return ids
	case upworkfreelancer.EdgeWorkHistories:
		ids := make([]ent.Value, 0, len(m.removedwork_histories))
		for id := range m.removedwork_histories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpworkFreelancerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedupwork_job {
		edges = append(edges, upworkfreelancer.EdgeUpworkJob)
	}
	if m.clearedattachments {
		edges = append(edges, upworkfreelancer.EdgeAttachments)
	}
	if m.clearedwork_histories {
		edges = append(edges, upworkfreelancer.EdgeWorkHistories)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpworkFreelancerMutation) EdgeCleared(name string) bool {
	switch name {
	case upworkfreelancer.EdgeUpworkJob:
		return m.clearedupwork_job
	case upworkfreelancer.EdgeAttachments:
		return m.clearedattachments
	case upworkfreelancer.EdgeWorkHistories:
		return m.clearedwork_histories
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpworkFreelancerMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown UpworkFreelancer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpworkFreelancerMutation) ResetEdge(name string) error {
	switch name {
	case upworkfreelancer.EdgeUpworkJob:
		m.ResetUpworkJob()
		return nil
	case upworkfreelancer.EdgeAttachments:
		m.ResetAttachments()
		return nil
	case upworkfreelancer.EdgeWorkHistories:
		m.ResetWorkHistories()
		return nil
	}
	return fmt.Errorf("unknown UpworkFreelancer edge %s", name)
}

// UpworkJobMutation represents an operation that mutates the UpworkJob nodes in the graph.
type UpworkJobMutation struct {
	config
	op                      Op
	typ                     string
	id                      *string
	title                   *string
	created_at              *time.Time
	location                *string
	description             *string
	skills                  *[]string
	appendskills            []string
	experience_level        *string
	hourly                  *bool
	fixed                   *bool
	hourly_rate             *[]float32
	appendhourly_rate       []float32
	fixed_rate              *float64
	addfixed_rate           *float64
	average_uprank_score    *float64
	addaverage_uprank_score *float64
	max_uprank_score        *float64
	addmax_uprank_score     *float64
	min_uprank_score        *float64
	addmin_uprank_score     *float64
	clearedFields           map[string]struct{}
	upworkfreelancer        map[string]struct{}
	removedupworkfreelancer map[string]struct{}
	clearedupworkfreelancer bool
	job                     *uuid.UUID
	clearedjob              bool
	user                    map[string]struct{}
	removeduser             map[string]struct{}
	cleareduser             bool
	done                    bool
	oldValue                func(context.Context) (*UpworkJob, error)
	predicates              []predicate.UpworkJob
}

var _ ent.Mutation = (*UpworkJobMutation)(nil)

// upworkjobOption allows management of the mutation configuration using functional options.
type upworkjobOption func(*UpworkJobMutation)

// newUpworkJobMutation creates new mutation for the UpworkJob entity.
func newUpworkJobMutation(c config, op Op, opts ...upworkjobOption) *UpworkJobMutation {
	m := &UpworkJobMutation{
		config:        c,
		op:            op,
		typ:           TypeUpworkJob,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUpworkJobID sets the ID field of the mutation.
func withUpworkJobID(id string) upworkjobOption {
	return func(m *UpworkJobMutation) {
		var (
			err   error
			once  sync.Once
			value *UpworkJob
		)
		m.oldValue = func(ctx context.Context) (*UpworkJob, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UpworkJob.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUpworkJob sets the old UpworkJob of the mutation.
func withUpworkJob(node *UpworkJob) upworkjobOption {
	return func(m *UpworkJobMutation) {
		m.oldValue = func(context.Context) (*UpworkJob, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UpworkJobMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UpworkJobMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UpworkJob entities.
func (m *UpworkJobMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UpworkJobMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UpworkJobMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UpworkJob.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *UpworkJobMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *UpworkJobMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the UpworkJob entity.
// If the UpworkJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkJobMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *UpworkJobMutation) ResetTitle() {
	m.title = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UpworkJobMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UpworkJobMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UpworkJob entity.
// If the UpworkJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkJobMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UpworkJobMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetLocation sets the "location" field.
func (m *UpworkJobMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *UpworkJobMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the UpworkJob entity.
// If the UpworkJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkJobMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *UpworkJobMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[upworkjob.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *UpworkJobMutation) LocationCleared() bool {
	_, ok := m.clearedFields[upworkjob.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *UpworkJobMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, upworkjob.FieldLocation)
}

// SetDescription sets the "description" field.
func (m *UpworkJobMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UpworkJobMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the UpworkJob entity.
// If the UpworkJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkJobMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *UpworkJobMutation) ResetDescription() {
	m.description = nil
}

// SetSkills sets the "skills" field.
func (m *UpworkJobMutation) SetSkills(s []string) {
	m.skills = &s
	m.appendskills = nil
}

// Skills returns the value of the "skills" field in the mutation.
func (m *UpworkJobMutation) Skills() (r []string, exists bool) {
	v := m.skills
	if v == nil {
		return
	}
	return *v, true
}

// OldSkills returns the old "skills" field's value of the UpworkJob entity.
// If the UpworkJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkJobMutation) OldSkills(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkills is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkills requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkills: %w", err)
	}
	return oldValue.Skills, nil
}

// AppendSkills adds s to the "skills" field.
func (m *UpworkJobMutation) AppendSkills(s []string) {
	m.appendskills = append(m.appendskills, s...)
}

// AppendedSkills returns the list of values that were appended to the "skills" field in this mutation.
func (m *UpworkJobMutation) AppendedSkills() ([]string, bool) {
	if len(m.appendskills) == 0 {
		return nil, false
	}
	return m.appendskills, true
}

// ClearSkills clears the value of the "skills" field.
func (m *UpworkJobMutation) ClearSkills() {
	m.skills = nil
	m.appendskills = nil
	m.clearedFields[upworkjob.FieldSkills] = struct{}{}
}

// SkillsCleared returns if the "skills" field was cleared in this mutation.
func (m *UpworkJobMutation) SkillsCleared() bool {
	_, ok := m.clearedFields[upworkjob.FieldSkills]
	return ok
}

// ResetSkills resets all changes to the "skills" field.
func (m *UpworkJobMutation) ResetSkills() {
	m.skills = nil
	m.appendskills = nil
	delete(m.clearedFields, upworkjob.FieldSkills)
}

// SetExperienceLevel sets the "experience_level" field.
func (m *UpworkJobMutation) SetExperienceLevel(s string) {
	m.experience_level = &s
}

// ExperienceLevel returns the value of the "experience_level" field in the mutation.
func (m *UpworkJobMutation) ExperienceLevel() (r string, exists bool) {
	v := m.experience_level
	if v == nil {
		return
	}
	return *v, true
}

// OldExperienceLevel returns the old "experience_level" field's value of the UpworkJob entity.
// If the UpworkJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkJobMutation) OldExperienceLevel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExperienceLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExperienceLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExperienceLevel: %w", err)
	}
	return oldValue.ExperienceLevel, nil
}

// ClearExperienceLevel clears the value of the "experience_level" field.
func (m *UpworkJobMutation) ClearExperienceLevel() {
	m.experience_level = nil
	m.clearedFields[upworkjob.FieldExperienceLevel] = struct{}{}
}

// ExperienceLevelCleared returns if the "experience_level" field was cleared in this mutation.
func (m *UpworkJobMutation) ExperienceLevelCleared() bool {
	_, ok := m.clearedFields[upworkjob.FieldExperienceLevel]
	return ok
}

// ResetExperienceLevel resets all changes to the "experience_level" field.
func (m *UpworkJobMutation) ResetExperienceLevel() {
	m.experience_level = nil
	delete(m.clearedFields, upworkjob.FieldExperienceLevel)
}

// SetHourly sets the "hourly" field.
func (m *UpworkJobMutation) SetHourly(b bool) {
	m.hourly = &b
}

// Hourly returns the value of the "hourly" field in the mutation.
func (m *UpworkJobMutation) Hourly() (r bool, exists bool) {
	v := m.hourly
	if v == nil {
		return
	}
	return *v, true
}

// OldHourly returns the old "hourly" field's value of the UpworkJob entity.
// If the UpworkJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkJobMutation) OldHourly(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHourly is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHourly requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHourly: %w", err)
	}
	return oldValue.Hourly, nil
}

// ResetHourly resets all changes to the "hourly" field.
func (m *UpworkJobMutation) ResetHourly() {
	m.hourly = nil
}

// SetFixed sets the "fixed" field.
func (m *UpworkJobMutation) SetFixed(b bool) {
	m.fixed = &b
}

// Fixed returns the value of the "fixed" field in the mutation.
func (m *UpworkJobMutation) Fixed() (r bool, exists bool) {
	v := m.fixed
	if v == nil {
		return
	}
	return *v, true
}

// OldFixed returns the old "fixed" field's value of the UpworkJob entity.
// If the UpworkJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkJobMutation) OldFixed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFixed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFixed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFixed: %w", err)
	}
	return oldValue.Fixed, nil
}

// ResetFixed resets all changes to the "fixed" field.
func (m *UpworkJobMutation) ResetFixed() {
	m.fixed = nil
}

// SetHourlyRate sets the "hourly_rate" field.
func (m *UpworkJobMutation) SetHourlyRate(f []float32) {
	m.hourly_rate = &f
	m.appendhourly_rate = nil
}

// HourlyRate returns the value of the "hourly_rate" field in the mutation.
func (m *UpworkJobMutation) HourlyRate() (r []float32, exists bool) {
	v := m.hourly_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldHourlyRate returns the old "hourly_rate" field's value of the UpworkJob entity.
// If the UpworkJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkJobMutation) OldHourlyRate(ctx context.Context) (v []float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHourlyRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHourlyRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHourlyRate: %w", err)
	}
	return oldValue.HourlyRate, nil
}

// AppendHourlyRate adds f to the "hourly_rate" field.
func (m *UpworkJobMutation) AppendHourlyRate(f []float32) {
	m.appendhourly_rate = append(m.appendhourly_rate, f...)
}

// AppendedHourlyRate returns the list of values that were appended to the "hourly_rate" field in this mutation.
func (m *UpworkJobMutation) AppendedHourlyRate() ([]float32, bool) {
	if len(m.appendhourly_rate) == 0 {
		return nil, false
	}
	return m.appendhourly_rate, true
}

// ClearHourlyRate clears the value of the "hourly_rate" field.
func (m *UpworkJobMutation) ClearHourlyRate() {
	m.hourly_rate = nil
	m.appendhourly_rate = nil
	m.clearedFields[upworkjob.FieldHourlyRate] = struct{}{}
}

// HourlyRateCleared returns if the "hourly_rate" field was cleared in this mutation.
func (m *UpworkJobMutation) HourlyRateCleared() bool {
	_, ok := m.clearedFields[upworkjob.FieldHourlyRate]
	return ok
}

// ResetHourlyRate resets all changes to the "hourly_rate" field.
func (m *UpworkJobMutation) ResetHourlyRate() {
	m.hourly_rate = nil
	m.appendhourly_rate = nil
	delete(m.clearedFields, upworkjob.FieldHourlyRate)
}

// SetFixedRate sets the "fixed_rate" field.
func (m *UpworkJobMutation) SetFixedRate(f float64) {
	m.fixed_rate = &f
	m.addfixed_rate = nil
}

// FixedRate returns the value of the "fixed_rate" field in the mutation.
func (m *UpworkJobMutation) FixedRate() (r float64, exists bool) {
	v := m.fixed_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldFixedRate returns the old "fixed_rate" field's value of the UpworkJob entity.
// If the UpworkJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkJobMutation) OldFixedRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFixedRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFixedRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFixedRate: %w", err)
	}
	return oldValue.FixedRate, nil
}

// AddFixedRate adds f to the "fixed_rate" field.
func (m *UpworkJobMutation) AddFixedRate(f float64) {
	if m.addfixed_rate != nil {
		*m.addfixed_rate += f
	} else {
		m.addfixed_rate = &f
	}
}

// AddedFixedRate returns the value that was added to the "fixed_rate" field in this mutation.
func (m *UpworkJobMutation) AddedFixedRate() (r float64, exists bool) {
	v := m.addfixed_rate
	if v == nil {
		return
	}
	return *v, true
}

// ClearFixedRate clears the value of the "fixed_rate" field.
func (m *UpworkJobMutation) ClearFixedRate() {
	m.fixed_rate = nil
	m.addfixed_rate = nil
	m.clearedFields[upworkjob.FieldFixedRate] = struct{}{}
}

// FixedRateCleared returns if the "fixed_rate" field was cleared in this mutation.
func (m *UpworkJobMutation) FixedRateCleared() bool {
	_, ok := m.clearedFields[upworkjob.FieldFixedRate]
	return ok
}

// ResetFixedRate resets all changes to the "fixed_rate" field.
func (m *UpworkJobMutation) ResetFixedRate() {
	m.fixed_rate = nil
	m.addfixed_rate = nil
	delete(m.clearedFields, upworkjob.FieldFixedRate)
}

// SetAverageUprankScore sets the "average_uprank_score" field.
func (m *UpworkJobMutation) SetAverageUprankScore(f float64) {
	m.average_uprank_score = &f
	m.addaverage_uprank_score = nil
}

// AverageUprankScore returns the value of the "average_uprank_score" field in the mutation.
func (m *UpworkJobMutation) AverageUprankScore() (r float64, exists bool) {
	v := m.average_uprank_score
	if v == nil {
		return
	}
	return *v, true
}

// OldAverageUprankScore returns the old "average_uprank_score" field's value of the UpworkJob entity.
// If the UpworkJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkJobMutation) OldAverageUprankScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAverageUprankScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAverageUprankScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAverageUprankScore: %w", err)
	}
	return oldValue.AverageUprankScore, nil
}

// AddAverageUprankScore adds f to the "average_uprank_score" field.
func (m *UpworkJobMutation) AddAverageUprankScore(f float64) {
	if m.addaverage_uprank_score != nil {
		*m.addaverage_uprank_score += f
	} else {
		m.addaverage_uprank_score = &f
	}
}

// AddedAverageUprankScore returns the value that was added to the "average_uprank_score" field in this mutation.
func (m *UpworkJobMutation) AddedAverageUprankScore() (r float64, exists bool) {
	v := m.addaverage_uprank_score
	if v == nil {
		return
	}
	return *v, true
}

// ClearAverageUprankScore clears the value of the "average_uprank_score" field.
func (m *UpworkJobMutation) ClearAverageUprankScore() {
	m.average_uprank_score = nil
	m.addaverage_uprank_score = nil
	m.clearedFields[upworkjob.FieldAverageUprankScore] = struct{}{}
}

// AverageUprankScoreCleared returns if the "average_uprank_score" field was cleared in this mutation.
func (m *UpworkJobMutation) AverageUprankScoreCleared() bool {
	_, ok := m.clearedFields[upworkjob.FieldAverageUprankScore]
	return ok
}

// ResetAverageUprankScore resets all changes to the "average_uprank_score" field.
func (m *UpworkJobMutation) ResetAverageUprankScore() {
	m.average_uprank_score = nil
	m.addaverage_uprank_score = nil
	delete(m.clearedFields, upworkjob.FieldAverageUprankScore)
}

// SetMaxUprankScore sets the "max_uprank_score" field.
func (m *UpworkJobMutation) SetMaxUprankScore(f float64) {
	m.max_uprank_score = &f
	m.addmax_uprank_score = nil
}

// MaxUprankScore returns the value of the "max_uprank_score" field in the mutation.
func (m *UpworkJobMutation) MaxUprankScore() (r float64, exists bool) {
	v := m.max_uprank_score
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxUprankScore returns the old "max_uprank_score" field's value of the UpworkJob entity.
// If the UpworkJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkJobMutation) OldMaxUprankScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxUprankScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxUprankScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxUprankScore: %w", err)
	}
	return oldValue.MaxUprankScore, nil
}

// AddMaxUprankScore adds f to the "max_uprank_score" field.
func (m *UpworkJobMutation) AddMaxUprankScore(f float64) {
	if m.addmax_uprank_score != nil {
		*m.addmax_uprank_score += f
	} else {
		m.addmax_uprank_score = &f
	}
}

// AddedMaxUprankScore returns the value that was added to the "max_uprank_score" field in this mutation.
func (m *UpworkJobMutation) AddedMaxUprankScore() (r float64, exists bool) {
	v := m.addmax_uprank_score
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxUprankScore clears the value of the "max_uprank_score" field.
func (m *UpworkJobMutation) ClearMaxUprankScore() {
	m.max_uprank_score = nil
	m.addmax_uprank_score = nil
	m.clearedFields[upworkjob.FieldMaxUprankScore] = struct{}{}
}

// MaxUprankScoreCleared returns if the "max_uprank_score" field was cleared in this mutation.
func (m *UpworkJobMutation) MaxUprankScoreCleared() bool {
	_, ok := m.clearedFields[upworkjob.FieldMaxUprankScore]
	return ok
}

// ResetMaxUprankScore resets all changes to the "max_uprank_score" field.
func (m *UpworkJobMutation) ResetMaxUprankScore() {
	m.max_uprank_score = nil
	m.addmax_uprank_score = nil
	delete(m.clearedFields, upworkjob.FieldMaxUprankScore)
}

// SetMinUprankScore sets the "min_uprank_score" field.
func (m *UpworkJobMutation) SetMinUprankScore(f float64) {
	m.min_uprank_score = &f
	m.addmin_uprank_score = nil
}

// MinUprankScore returns the value of the "min_uprank_score" field in the mutation.
func (m *UpworkJobMutation) MinUprankScore() (r float64, exists bool) {
	v := m.min_uprank_score
	if v == nil {
		return
	}
	return *v, true
}

// OldMinUprankScore returns the old "min_uprank_score" field's value of the UpworkJob entity.
// If the UpworkJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UpworkJobMutation) OldMinUprankScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinUprankScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinUprankScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinUprankScore: %w", err)
	}
	return oldValue.MinUprankScore, nil
}

// AddMinUprankScore adds f to the "min_uprank_score" field.
func (m *UpworkJobMutation) AddMinUprankScore(f float64) {
	if m.addmin_uprank_score != nil {
		*m.addmin_uprank_score += f
	} else {
		m.addmin_uprank_score = &f
	}
}

// AddedMinUprankScore returns the value that was added to the "min_uprank_score" field in this mutation.
func (m *UpworkJobMutation) AddedMinUprankScore() (r float64, exists bool) {
	v := m.addmin_uprank_score
	if v == nil {
		return
	}
	return *v, true
}

// ClearMinUprankScore clears the value of the "min_uprank_score" field.
func (m *UpworkJobMutation) ClearMinUprankScore() {
	m.min_uprank_score = nil
	m.addmin_uprank_score = nil
	m.clearedFields[upworkjob.FieldMinUprankScore] = struct{}{}
}

// MinUprankScoreCleared returns if the "min_uprank_score" field was cleared in this mutation.
func (m *UpworkJobMutation) MinUprankScoreCleared() bool {
	_, ok := m.clearedFields[upworkjob.FieldMinUprankScore]
	return ok
}

// ResetMinUprankScore resets all changes to the "min_uprank_score" field.
func (m *UpworkJobMutation) ResetMinUprankScore() {
	m.min_uprank_score = nil
	m.addmin_uprank_score = nil
	delete(m.clearedFields, upworkjob.FieldMinUprankScore)
}

// AddUpworkfreelancerIDs adds the "upworkfreelancer" edge to the UpworkFreelancer entity by ids.
func (m *UpworkJobMutation) AddUpworkfreelancerIDs(ids ...string) {
	if m.upworkfreelancer == nil {
		m.upworkfreelancer = make(map[string]struct{})
	}
	for i := range ids {
		m.upworkfreelancer[ids[i]] = struct{}{}
	}
}

// ClearUpworkfreelancer clears the "upworkfreelancer" edge to the UpworkFreelancer entity.
func (m *UpworkJobMutation) ClearUpworkfreelancer() {
	m.clearedupworkfreelancer = true
}

// UpworkfreelancerCleared reports if the "upworkfreelancer" edge to the UpworkFreelancer entity was cleared.
func (m *UpworkJobMutation) UpworkfreelancerCleared() bool {
	return m.clearedupworkfreelancer
}

// RemoveUpworkfreelancerIDs removes the "upworkfreelancer" edge to the UpworkFreelancer entity by IDs.
func (m *UpworkJobMutation) RemoveUpworkfreelancerIDs(ids ...string) {
	if m.removedupworkfreelancer == nil {
		m.removedupworkfreelancer = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.upworkfreelancer, ids[i])
		m.removedupworkfreelancer[ids[i]] = struct{}{}
	}
}

// RemovedUpworkfreelancer returns the removed IDs of the "upworkfreelancer" edge to the UpworkFreelancer entity.
func (m *UpworkJobMutation) RemovedUpworkfreelancerIDs() (ids []string) {
	for id := range m.removedupworkfreelancer {
		ids = append(ids, id)
	}
	return
}

// UpworkfreelancerIDs returns the "upworkfreelancer" edge IDs in the mutation.
func (m *UpworkJobMutation) UpworkfreelancerIDs() (ids []string) {
	for id := range m.upworkfreelancer {
		ids = append(ids, id)
	}
	return
}

// ResetUpworkfreelancer resets all changes to the "upworkfreelancer" edge.
func (m *UpworkJobMutation) ResetUpworkfreelancer() {
	m.upworkfreelancer = nil
	m.clearedupworkfreelancer = false
	m.removedupworkfreelancer = nil
}

// SetJobID sets the "job" edge to the Job entity by id.
func (m *UpworkJobMutation) SetJobID(id uuid.UUID) {
	m.job = &id
}

// ClearJob clears the "job" edge to the Job entity.
func (m *UpworkJobMutation) ClearJob() {
	m.clearedjob = true
}

// JobCleared reports if the "job" edge to the Job entity was cleared.
func (m *UpworkJobMutation) JobCleared() bool {
	return m.clearedjob
}

// JobID returns the "job" edge ID in the mutation.
func (m *UpworkJobMutation) JobID() (id uuid.UUID, exists bool) {
	if m.job != nil {
		return *m.job, true
	}
	return
}

// JobIDs returns the "job" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// JobID instead. It exists only for internal usage by the builders.
func (m *UpworkJobMutation) JobIDs() (ids []uuid.UUID) {
	if id := m.job; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJob resets all changes to the "job" edge.
func (m *UpworkJobMutation) ResetJob() {
	m.job = nil
	m.clearedjob = false
}

// AddUserIDs adds the "user" edge to the User entity by ids.
func (m *UpworkJobMutation) AddUserIDs(ids ...string) {
	if m.user == nil {
		m.user = make(map[string]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// ClearUser clears the "user" edge to the User entity.
func (m *UpworkJobMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UpworkJobMutation) UserCleared() bool {
	return m.cleareduser
}

// RemoveUserIDs removes the "user" edge to the User entity by IDs.
func (m *UpworkJobMutation) RemoveUserIDs(ids ...string) {
	if m.removeduser == nil {
		m.removeduser = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.user, ids[i])
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed IDs of the "user" edge to the User entity.
func (m *UpworkJobMutation) RemovedUserIDs() (ids []string) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
func (m *UpworkJobMutation) UserIDs() (ids []string) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UpworkJobMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
	m.removeduser = nil
}

// Where appends a list predicates to the UpworkJobMutation builder.
func (m *UpworkJobMutation) Where(ps ...predicate.UpworkJob) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UpworkJobMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UpworkJobMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UpworkJob, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UpworkJobMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UpworkJobMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UpworkJob).
func (m *UpworkJobMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UpworkJobMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.title != nil {
		fields = append(fields, upworkjob.FieldTitle)
	}
	if m.created_at != nil {
		fields = append(fields, upworkjob.FieldCreatedAt)
	}
	if m.location != nil {
		fields = append(fields, upworkjob.FieldLocation)
	}
	if m.description != nil {
		fields = append(fields, upworkjob.FieldDescription)
	}
	if m.skills != nil {
		fields = append(fields, upworkjob.FieldSkills)
	}
	if m.experience_level != nil {
		fields = append(fields, upworkjob.FieldExperienceLevel)
	}
	if m.hourly != nil {
		fields = append(fields, upworkjob.FieldHourly)
	}
	if m.fixed != nil {
		fields = append(fields, upworkjob.FieldFixed)
	}
	if m.hourly_rate != nil {
		fields = append(fields, upworkjob.FieldHourlyRate)
	}
	if m.fixed_rate != nil {
		fields = append(fields, upworkjob.FieldFixedRate)
	}
	if m.average_uprank_score != nil {
		fields = append(fields, upworkjob.FieldAverageUprankScore)
	}
	if m.max_uprank_score != nil {
		fields = append(fields, upworkjob.FieldMaxUprankScore)
	}
	if m.min_uprank_score != nil {
		fields = append(fields, upworkjob.FieldMinUprankScore)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UpworkJobMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case upworkjob.FieldTitle:
		return m.Title()
	case upworkjob.FieldCreatedAt:
		return m.CreatedAt()
	case upworkjob.FieldLocation:
		return m.Location()
	case upworkjob.FieldDescription:
		return m.Description()
	case upworkjob.FieldSkills:
		return m.Skills()
	case upworkjob.FieldExperienceLevel:
		return m.ExperienceLevel()
	case upworkjob.FieldHourly:
		return m.Hourly()
	case upworkjob.FieldFixed:
		return m.Fixed()
	case upworkjob.FieldHourlyRate:
		return m.HourlyRate()
	case upworkjob.FieldFixedRate:
		return m.FixedRate()
	case upworkjob.FieldAverageUprankScore:
		return m.AverageUprankScore()
	case upworkjob.FieldMaxUprankScore:
		return m.MaxUprankScore()
	case upworkjob.FieldMinUprankScore:
		return m.MinUprankScore()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UpworkJobMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case upworkjob.FieldTitle:
		return m.OldTitle(ctx)
	case upworkjob.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case upworkjob.FieldLocation:
		return m.OldLocation(ctx)
	case upworkjob.FieldDescription:
		return m.OldDescription(ctx)
	case upworkjob.FieldSkills:
		return m.OldSkills(ctx)
	case upworkjob.FieldExperienceLevel:
		return m.OldExperienceLevel(ctx)
	case upworkjob.FieldHourly:
		return m.OldHourly(ctx)
	case upworkjob.FieldFixed:
		return m.OldFixed(ctx)
	case upworkjob.FieldHourlyRate:
		return m.OldHourlyRate(ctx)
	case upworkjob.FieldFixedRate:
		return m.OldFixedRate(ctx)
	case upworkjob.FieldAverageUprankScore:
		return m.OldAverageUprankScore(ctx)
	case upworkjob.FieldMaxUprankScore:
		return m.OldMaxUprankScore(ctx)
	case upworkjob.FieldMinUprankScore:
		return m.OldMinUprankScore(ctx)
	}
	return nil, fmt.Errorf("unknown UpworkJob field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpworkJobMutation) SetField(name string, value ent.Value) error {
	switch name {
	case upworkjob.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case upworkjob.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case upworkjob.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case upworkjob.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case upworkjob.FieldSkills:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkills(v)
		return nil
	case upworkjob.FieldExperienceLevel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExperienceLevel(v)
		return nil
	case upworkjob.FieldHourly:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHourly(v)
		return nil
	case upworkjob.FieldFixed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFixed(v)
		return nil
	case upworkjob.FieldHourlyRate:
		v, ok := value.([]float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHourlyRate(v)
		return nil
	case upworkjob.FieldFixedRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFixedRate(v)
		return nil
	case upworkjob.FieldAverageUprankScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAverageUprankScore(v)
		return nil
	case upworkjob.FieldMaxUprankScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxUprankScore(v)
		return nil
	case upworkjob.FieldMinUprankScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinUprankScore(v)
		return nil
	}
	return fmt.Errorf("unknown UpworkJob field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UpworkJobMutation) AddedFields() []string {
	var fields []string
	if m.addfixed_rate != nil {
		fields = append(fields, upworkjob.FieldFixedRate)
	}
	if m.addaverage_uprank_score != nil {
		fields = append(fields, upworkjob.FieldAverageUprankScore)
	}
	if m.addmax_uprank_score != nil {
		fields = append(fields, upworkjob.FieldMaxUprankScore)
	}
	if m.addmin_uprank_score != nil {
		fields = append(fields, upworkjob.FieldMinUprankScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UpworkJobMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case upworkjob.FieldFixedRate:
		return m.AddedFixedRate()
	case upworkjob.FieldAverageUprankScore:
		return m.AddedAverageUprankScore()
	case upworkjob.FieldMaxUprankScore:
		return m.AddedMaxUprankScore()
	case upworkjob.FieldMinUprankScore:
		return m.AddedMinUprankScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UpworkJobMutation) AddField(name string, value ent.Value) error {
	switch name {
	case upworkjob.FieldFixedRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFixedRate(v)
		return nil
	case upworkjob.FieldAverageUprankScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAverageUprankScore(v)
		return nil
	case upworkjob.FieldMaxUprankScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxUprankScore(v)
		return nil
	case upworkjob.FieldMinUprankScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinUprankScore(v)
		return nil
	}
	return fmt.Errorf("unknown UpworkJob numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UpworkJobMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(upworkjob.FieldLocation) {
		fields = append(fields, upworkjob.FieldLocation)
	}
	if m.FieldCleared(upworkjob.FieldSkills) {
		fields = append(fields, upworkjob.FieldSkills)
	}
	if m.FieldCleared(upworkjob.FieldExperienceLevel) {
		fields = append(fields, upworkjob.FieldExperienceLevel)
	}
	if m.FieldCleared(upworkjob.FieldHourlyRate) {
		fields = append(fields, upworkjob.FieldHourlyRate)
	}
	if m.FieldCleared(upworkjob.FieldFixedRate) {
		fields = append(fields, upworkjob.FieldFixedRate)
	}
	if m.FieldCleared(upworkjob.FieldAverageUprankScore) {
		fields = append(fields, upworkjob.FieldAverageUprankScore)
	}
	if m.FieldCleared(upworkjob.FieldMaxUprankScore) {
		fields = append(fields, upworkjob.FieldMaxUprankScore)
	}
	if m.FieldCleared(upworkjob.FieldMinUprankScore) {
		fields = append(fields, upworkjob.FieldMinUprankScore)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UpworkJobMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UpworkJobMutation) ClearField(name string) error {
	switch name {
	case upworkjob.FieldLocation:
		m.ClearLocation()
		return nil
	case upworkjob.FieldSkills:
		m.ClearSkills()
		return nil
	case upworkjob.FieldExperienceLevel:
		m.ClearExperienceLevel()
		return nil
	case upworkjob.FieldHourlyRate:
		m.ClearHourlyRate()
		return nil
	case upworkjob.FieldFixedRate:
		m.ClearFixedRate()
		return nil
	case upworkjob.FieldAverageUprankScore:
		m.ClearAverageUprankScore()
		return nil
	case upworkjob.FieldMaxUprankScore:
		m.ClearMaxUprankScore()
		return nil
	case upworkjob.FieldMinUprankScore:
		m.ClearMinUprankScore()
		return nil
	}
	return fmt.Errorf("unknown UpworkJob nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UpworkJobMutation) ResetField(name string) error {
	switch name {
	case upworkjob.FieldTitle:
		m.ResetTitle()
		return nil
	case upworkjob.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case upworkjob.FieldLocation:
		m.ResetLocation()
		return nil
	case upworkjob.FieldDescription:
		m.ResetDescription()
		return nil
	case upworkjob.FieldSkills:
		m.ResetSkills()
		return nil
	case upworkjob.FieldExperienceLevel:
		m.ResetExperienceLevel()
		return nil
	case upworkjob.FieldHourly:
		m.ResetHourly()
		return nil
	case upworkjob.FieldFixed:
		m.ResetFixed()
		return nil
	case upworkjob.FieldHourlyRate:
		m.ResetHourlyRate()
		return nil
	case upworkjob.FieldFixedRate:
		m.ResetFixedRate()
		return nil
	case upworkjob.FieldAverageUprankScore:
		m.ResetAverageUprankScore()
		return nil
	case upworkjob.FieldMaxUprankScore:
		m.ResetMaxUprankScore()
		return nil
	case upworkjob.FieldMinUprankScore:
		m.ResetMinUprankScore()
		return nil
	}
	return fmt.Errorf("unknown UpworkJob field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UpworkJobMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.upworkfreelancer != nil {
		edges = append(edges, upworkjob.EdgeUpworkfreelancer)
	}
	if m.job != nil {
		edges = append(edges, upworkjob.EdgeJob)
	}
	if m.user != nil {
		edges = append(edges, upworkjob.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UpworkJobMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case upworkjob.EdgeUpworkfreelancer:
		ids := make([]ent.Value, 0, len(m.upworkfreelancer))
		for id := range m.upworkfreelancer {
			ids = append(ids, id)
		}
		return ids
	case upworkjob.EdgeJob:
		if id := m.job; id != nil {
			return []ent.Value{*id}
		}
	case upworkjob.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UpworkJobMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedupworkfreelancer != nil {
		edges = append(edges, upworkjob.EdgeUpworkfreelancer)
	}
	if m.removeduser != nil {
		edges = append(edges, upworkjob.EdgeUser)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UpworkJobMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case upworkjob.EdgeUpworkfreelancer:
		ids := make([]ent.Value, 0, len(m.removedupworkfreelancer))
		for id := range m.removedupworkfreelancer {
			ids = append(ids, id)
		}
		return ids
	case upworkjob.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UpworkJobMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedupworkfreelancer {
		edges = append(edges, upworkjob.EdgeUpworkfreelancer)
	}
	if m.clearedjob {
		edges = append(edges, upworkjob.EdgeJob)
	}
	if m.cleareduser {
		edges = append(edges, upworkjob.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UpworkJobMutation) EdgeCleared(name string) bool {
	switch name {
	case upworkjob.EdgeUpworkfreelancer:
		return m.clearedupworkfreelancer
	case upworkjob.EdgeJob:
		return m.clearedjob
	case upworkjob.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UpworkJobMutation) ClearEdge(name string) error {
	switch name {
	case upworkjob.EdgeJob:
		m.ClearJob()
		return nil
	}
	return fmt.Errorf("unknown UpworkJob unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UpworkJobMutation) ResetEdge(name string) error {
	switch name {
	case upworkjob.EdgeUpworkfreelancer:
		m.ResetUpworkfreelancer()
		return nil
	case upworkjob.EdgeJob:
		m.ResetJob()
		return nil
	case upworkjob.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UpworkJob edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op               Op
	typ              string
	id               *string
	first_name       *string
	company_name     *string
	email            *string
	created_at       *time.Time
	updated_at       *time.Time
	last_login       *time.Time
	clearedFields    map[string]struct{}
	job              map[uuid.UUID]struct{}
	removedjob       map[uuid.UUID]struct{}
	clearedjob       bool
	upworkjob        map[string]struct{}
	removedupworkjob map[string]struct{}
	clearedupworkjob bool
	done             bool
	oldValue         func(context.Context) (*User, error)
	predicates       []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id string) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFirstName sets the "first_name" field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
}

// SetCompanyName sets the "company_name" field.
func (m *UserMutation) SetCompanyName(s string) {
	m.company_name = &s
}

// CompanyName returns the value of the "company_name" field in the mutation.
func (m *UserMutation) CompanyName() (r string, exists bool) {
	v := m.company_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyName returns the old "company_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCompanyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyName: %w", err)
	}
	return oldValue.CompanyName, nil
}

// ResetCompanyName resets all changes to the "company_name" field.
func (m *UserMutation) ResetCompanyName() {
	m.company_name = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetLastLogin sets the "last_login" field.
func (m *UserMutation) SetLastLogin(t time.Time) {
	m.last_login = &t
}

// LastLogin returns the value of the "last_login" field in the mutation.
func (m *UserMutation) LastLogin() (r time.Time, exists bool) {
	v := m.last_login
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLogin returns the old "last_login" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLogin(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLogin: %w", err)
	}
	return oldValue.LastLogin, nil
}

// ResetLastLogin resets all changes to the "last_login" field.
func (m *UserMutation) ResetLastLogin() {
	m.last_login = nil
}

// AddJobIDs adds the "job" edge to the Job entity by ids.
func (m *UserMutation) AddJobIDs(ids ...uuid.UUID) {
	if m.job == nil {
		m.job = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.job[ids[i]] = struct{}{}
	}
}

// ClearJob clears the "job" edge to the Job entity.
func (m *UserMutation) ClearJob() {
	m.clearedjob = true
}

// JobCleared reports if the "job" edge to the Job entity was cleared.
func (m *UserMutation) JobCleared() bool {
	return m.clearedjob
}

// RemoveJobIDs removes the "job" edge to the Job entity by IDs.
func (m *UserMutation) RemoveJobIDs(ids ...uuid.UUID) {
	if m.removedjob == nil {
		m.removedjob = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.job, ids[i])
		m.removedjob[ids[i]] = struct{}{}
	}
}

// RemovedJob returns the removed IDs of the "job" edge to the Job entity.
func (m *UserMutation) RemovedJobIDs() (ids []uuid.UUID) {
	for id := range m.removedjob {
		ids = append(ids, id)
	}
	return
}

// JobIDs returns the "job" edge IDs in the mutation.
func (m *UserMutation) JobIDs() (ids []uuid.UUID) {
	for id := range m.job {
		ids = append(ids, id)
	}
	return
}

// ResetJob resets all changes to the "job" edge.
func (m *UserMutation) ResetJob() {
	m.job = nil
	m.clearedjob = false
	m.removedjob = nil
}

// AddUpworkjobIDs adds the "upworkjob" edge to the UpworkJob entity by ids.
func (m *UserMutation) AddUpworkjobIDs(ids ...string) {
	if m.upworkjob == nil {
		m.upworkjob = make(map[string]struct{})
	}
	for i := range ids {
		m.upworkjob[ids[i]] = struct{}{}
	}
}

// ClearUpworkjob clears the "upworkjob" edge to the UpworkJob entity.
func (m *UserMutation) ClearUpworkjob() {
	m.clearedupworkjob = true
}

// UpworkjobCleared reports if the "upworkjob" edge to the UpworkJob entity was cleared.
func (m *UserMutation) UpworkjobCleared() bool {
	return m.clearedupworkjob
}

// RemoveUpworkjobIDs removes the "upworkjob" edge to the UpworkJob entity by IDs.
func (m *UserMutation) RemoveUpworkjobIDs(ids ...string) {
	if m.removedupworkjob == nil {
		m.removedupworkjob = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.upworkjob, ids[i])
		m.removedupworkjob[ids[i]] = struct{}{}
	}
}

// RemovedUpworkjob returns the removed IDs of the "upworkjob" edge to the UpworkJob entity.
func (m *UserMutation) RemovedUpworkjobIDs() (ids []string) {
	for id := range m.removedupworkjob {
		ids = append(ids, id)
	}
	return
}

// UpworkjobIDs returns the "upworkjob" edge IDs in the mutation.
func (m *UserMutation) UpworkjobIDs() (ids []string) {
	for id := range m.upworkjob {
		ids = append(ids, id)
	}
	return
}

// ResetUpworkjob resets all changes to the "upworkjob" edge.
func (m *UserMutation) ResetUpworkjob() {
	m.upworkjob = nil
	m.clearedupworkjob = false
	m.removedupworkjob = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.company_name != nil {
		fields = append(fields, user.FieldCompanyName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.last_login != nil {
		fields = append(fields, user.FieldLastLogin)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldCompanyName:
		return m.CompanyName()
	case user.FieldEmail:
		return m.Email()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldLastLogin:
		return m.LastLogin()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldCompanyName:
		return m.OldCompanyName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldLastLogin:
		return m.OldLastLogin(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldCompanyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldLastLogin:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLogin(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldCompanyName:
		m.ResetCompanyName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldLastLogin:
		m.ResetLastLogin()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.job != nil {
		edges = append(edges, user.EdgeJob)
	}
	if m.upworkjob != nil {
		edges = append(edges, user.EdgeUpworkjob)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeJob:
		ids := make([]ent.Value, 0, len(m.job))
		for id := range m.job {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUpworkjob:
		ids := make([]ent.Value, 0, len(m.upworkjob))
		for id := range m.upworkjob {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedjob != nil {
		edges = append(edges, user.EdgeJob)
	}
	if m.removedupworkjob != nil {
		edges = append(edges, user.EdgeUpworkjob)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeJob:
		ids := make([]ent.Value, 0, len(m.removedjob))
		for id := range m.removedjob {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUpworkjob:
		ids := make([]ent.Value, 0, len(m.removedupworkjob))
		for id := range m.removedupworkjob {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedjob {
		edges = append(edges, user.EdgeJob)
	}
	if m.clearedupworkjob {
		edges = append(edges, user.EdgeUpworkjob)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeJob:
		return m.clearedjob
	case user.EdgeUpworkjob:
		return m.clearedupworkjob
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeJob:
		m.ResetJob()
		return nil
	case user.EdgeUpworkjob:
		m.ResetUpworkjob()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// WorkHistoryMutation represents an operation that mutates the WorkHistory nodes in the graph.
type WorkHistoryMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *int
	title                              *string
	client_feedback                    *string
	overall_rating                     *float64
	addoverall_rating                  *float64
	freelancer_earnings                *float64
	addfreelancer_earnings             *float64
	start_date                         *time.Time
	end_date                           *time.Time
	description                        *string
	budget                             *float64
	addbudget                          *float64
	client_rating                      *float64
	addclient_rating                   *float64
	client_review_count                *int
	addclient_review_count             *int
	client_country                     *string
	client_total_jobs_posted           *int
	addclient_total_jobs_posted        *int
	client_total_spend                 *float64
	addclient_total_spend              *float64
	client_total_hires                 *int
	addclient_total_hires              *int
	client_active_hires                *int
	addclient_active_hires             *int
	client_total_paid_hours            *int
	addclient_total_paid_hours         *int
	client_average_hourly_rate_paid    *float64
	addclient_average_hourly_rate_paid *float64
	client_company_category            *string
	client_company_size                *string
	total_proposals                    *int
	addtotal_proposals                 *int
	number_of_interviews               *int
	addnumber_of_interviews            *int
	skills                             *[]string
	appendskills                       []string
	clearedFields                      map[string]struct{}
	freelancer                         *string
	clearedfreelancer                  bool
	done                               bool
	oldValue                           func(context.Context) (*WorkHistory, error)
	predicates                         []predicate.WorkHistory
}

var _ ent.Mutation = (*WorkHistoryMutation)(nil)

// workhistoryOption allows management of the mutation configuration using functional options.
type workhistoryOption func(*WorkHistoryMutation)

// newWorkHistoryMutation creates new mutation for the WorkHistory entity.
func newWorkHistoryMutation(c config, op Op, opts ...workhistoryOption) *WorkHistoryMutation {
	m := &WorkHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkHistoryID sets the ID field of the mutation.
func withWorkHistoryID(id int) workhistoryOption {
	return func(m *WorkHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkHistory
		)
		m.oldValue = func(ctx context.Context) (*WorkHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkHistory sets the old WorkHistory of the mutation.
func withWorkHistory(node *WorkHistory) workhistoryOption {
	return func(m *WorkHistoryMutation) {
		m.oldValue = func(context.Context) (*WorkHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkHistoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkHistoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *WorkHistoryMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *WorkHistoryMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *WorkHistoryMutation) ResetTitle() {
	m.title = nil
}

// SetClientFeedback sets the "client_feedback" field.
func (m *WorkHistoryMutation) SetClientFeedback(s string) {
	m.client_feedback = &s
}

// ClientFeedback returns the value of the "client_feedback" field in the mutation.
func (m *WorkHistoryMutation) ClientFeedback() (r string, exists bool) {
	v := m.client_feedback
	if v == nil {
		return
	}
	return *v, true
}

// OldClientFeedback returns the old "client_feedback" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldClientFeedback(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientFeedback is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientFeedback requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientFeedback: %w", err)
	}
	return oldValue.ClientFeedback, nil
}

// ClearClientFeedback clears the value of the "client_feedback" field.
func (m *WorkHistoryMutation) ClearClientFeedback() {
	m.client_feedback = nil
	m.clearedFields[workhistory.FieldClientFeedback] = struct{}{}
}

// ClientFeedbackCleared returns if the "client_feedback" field was cleared in this mutation.
func (m *WorkHistoryMutation) ClientFeedbackCleared() bool {
	_, ok := m.clearedFields[workhistory.FieldClientFeedback]
	return ok
}

// ResetClientFeedback resets all changes to the "client_feedback" field.
func (m *WorkHistoryMutation) ResetClientFeedback() {
	m.client_feedback = nil
	delete(m.clearedFields, workhistory.FieldClientFeedback)
}

// SetOverallRating sets the "overall_rating" field.
func (m *WorkHistoryMutation) SetOverallRating(f float64) {
	m.overall_rating = &f
	m.addoverall_rating = nil
}

// OverallRating returns the value of the "overall_rating" field in the mutation.
func (m *WorkHistoryMutation) OverallRating() (r float64, exists bool) {
	v := m.overall_rating
	if v == nil {
		return
	}
	return *v, true
}

// OldOverallRating returns the old "overall_rating" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldOverallRating(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverallRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverallRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverallRating: %w", err)
	}
	return oldValue.OverallRating, nil
}

// AddOverallRating adds f to the "overall_rating" field.
func (m *WorkHistoryMutation) AddOverallRating(f float64) {
	if m.addoverall_rating != nil {
		*m.addoverall_rating += f
	} else {
		m.addoverall_rating = &f
	}
}

// AddedOverallRating returns the value that was added to the "overall_rating" field in this mutation.
func (m *WorkHistoryMutation) AddedOverallRating() (r float64, exists bool) {
	v := m.addoverall_rating
	if v == nil {
		return
	}
	return *v, true
}

// ClearOverallRating clears the value of the "overall_rating" field.
func (m *WorkHistoryMutation) ClearOverallRating() {
	m.overall_rating = nil
	m.addoverall_rating = nil
	m.clearedFields[workhistory.FieldOverallRating] = struct{}{}
}

// OverallRatingCleared returns if the "overall_rating" field was cleared in this mutation.
func (m *WorkHistoryMutation) OverallRatingCleared() bool {
	_, ok := m.clearedFields[workhistory.FieldOverallRating]
	return ok
}

// ResetOverallRating resets all changes to the "overall_rating" field.
func (m *WorkHistoryMutation) ResetOverallRating() {
	m.overall_rating = nil
	m.addoverall_rating = nil
	delete(m.clearedFields, workhistory.FieldOverallRating)
}

// SetFreelancerEarnings sets the "freelancer_earnings" field.
func (m *WorkHistoryMutation) SetFreelancerEarnings(f float64) {
	m.freelancer_earnings = &f
	m.addfreelancer_earnings = nil
}

// FreelancerEarnings returns the value of the "freelancer_earnings" field in the mutation.
func (m *WorkHistoryMutation) FreelancerEarnings() (r float64, exists bool) {
	v := m.freelancer_earnings
	if v == nil {
		return
	}
	return *v, true
}

// OldFreelancerEarnings returns the old "freelancer_earnings" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldFreelancerEarnings(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFreelancerEarnings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFreelancerEarnings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFreelancerEarnings: %w", err)
	}
	return oldValue.FreelancerEarnings, nil
}

// AddFreelancerEarnings adds f to the "freelancer_earnings" field.
func (m *WorkHistoryMutation) AddFreelancerEarnings(f float64) {
	if m.addfreelancer_earnings != nil {
		*m.addfreelancer_earnings += f
	} else {
		m.addfreelancer_earnings = &f
	}
}

// AddedFreelancerEarnings returns the value that was added to the "freelancer_earnings" field in this mutation.
func (m *WorkHistoryMutation) AddedFreelancerEarnings() (r float64, exists bool) {
	v := m.addfreelancer_earnings
	if v == nil {
		return
	}
	return *v, true
}

// ClearFreelancerEarnings clears the value of the "freelancer_earnings" field.
func (m *WorkHistoryMutation) ClearFreelancerEarnings() {
	m.freelancer_earnings = nil
	m.addfreelancer_earnings = nil
	m.clearedFields[workhistory.FieldFreelancerEarnings] = struct{}{}
}

// FreelancerEarningsCleared returns if the "freelancer_earnings" field was cleared in this mutation.
func (m *WorkHistoryMutation) FreelancerEarningsCleared() bool {
	_, ok := m.clearedFields[workhistory.FieldFreelancerEarnings]
	return ok
}

// ResetFreelancerEarnings resets all changes to the "freelancer_earnings" field.
func (m *WorkHistoryMutation) ResetFreelancerEarnings() {
	m.freelancer_earnings = nil
	m.addfreelancer_earnings = nil
	delete(m.clearedFields, workhistory.FieldFreelancerEarnings)
}

// SetStartDate sets the "start_date" field.
func (m *WorkHistoryMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *WorkHistoryMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ClearStartDate clears the value of the "start_date" field.
func (m *WorkHistoryMutation) ClearStartDate() {
	m.start_date = nil
	m.clearedFields[workhistory.FieldStartDate] = struct{}{}
}

// StartDateCleared returns if the "start_date" field was cleared in this mutation.
func (m *WorkHistoryMutation) StartDateCleared() bool {
	_, ok := m.clearedFields[workhistory.FieldStartDate]
	return ok
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *WorkHistoryMutation) ResetStartDate() {
	m.start_date = nil
	delete(m.clearedFields, workhistory.FieldStartDate)
}

// SetEndDate sets the "end_date" field.
func (m *WorkHistoryMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *WorkHistoryMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *WorkHistoryMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[workhistory.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *WorkHistoryMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[workhistory.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *WorkHistoryMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, workhistory.FieldEndDate)
}

// SetDescription sets the "description" field.
func (m *WorkHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *WorkHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *WorkHistoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[workhistory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *WorkHistoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[workhistory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *WorkHistoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, workhistory.FieldDescription)
}

// SetBudget sets the "budget" field.
func (m *WorkHistoryMutation) SetBudget(f float64) {
	m.budget = &f
	m.addbudget = nil
}

// Budget returns the value of the "budget" field in the mutation.
func (m *WorkHistoryMutation) Budget() (r float64, exists bool) {
	v := m.budget
	if v == nil {
		return
	}
	return *v, true
}

// OldBudget returns the old "budget" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldBudget(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBudget is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBudget requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBudget: %w", err)
	}
	return oldValue.Budget, nil
}

// AddBudget adds f to the "budget" field.
func (m *WorkHistoryMutation) AddBudget(f float64) {
	if m.addbudget != nil {
		*m.addbudget += f
	} else {
		m.addbudget = &f
	}
}

// AddedBudget returns the value that was added to the "budget" field in this mutation.
func (m *WorkHistoryMutation) AddedBudget() (r float64, exists bool) {
	v := m.addbudget
	if v == nil {
		return
	}
	return *v, true
}

// ClearBudget clears the value of the "budget" field.
func (m *WorkHistoryMutation) ClearBudget() {
	m.budget = nil
	m.addbudget = nil
	m.clearedFields[workhistory.FieldBudget] = struct{}{}
}

// BudgetCleared returns if the "budget" field was cleared in this mutation.
func (m *WorkHistoryMutation) BudgetCleared() bool {
	_, ok := m.clearedFields[workhistory.FieldBudget]
	return ok
}

// ResetBudget resets all changes to the "budget" field.
func (m *WorkHistoryMutation) ResetBudget() {
	m.budget = nil
	m.addbudget = nil
	delete(m.clearedFields, workhistory.FieldBudget)
}

// SetClientRating sets the "client_rating" field.
func (m *WorkHistoryMutation) SetClientRating(f float64) {
	m.client_rating = &f
	m.addclient_rating = nil
}

// ClientRating returns the value of the "client_rating" field in the mutation.
func (m *WorkHistoryMutation) ClientRating() (r float64, exists bool) {
	v := m.client_rating
	if v == nil {
		return
	}
	return *v, true
}

// OldClientRating returns the old "client_rating" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldClientRating(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientRating: %w", err)
	}
	return oldValue.ClientRating, nil
}

// AddClientRating adds f to the "client_rating" field.
func (m *WorkHistoryMutation) AddClientRating(f float64) {
	if m.addclient_rating != nil {
		*m.addclient_rating += f
	} else {
		m.addclient_rating = &f
	}
}

// AddedClientRating returns the value that was added to the "client_rating" field in this mutation.
func (m *WorkHistoryMutation) AddedClientRating() (r float64, exists bool) {
	v := m.addclient_rating
	if v == nil {
		return
	}
	return *v, true
}

// ClearClientRating clears the value of the "client_rating" field.
func (m *WorkHistoryMutation) ClearClientRating() {
	m.client_rating = nil
	m.addclient_rating = nil
	m.clearedFields[workhistory.FieldClientRating] = struct{}{}
}

// ClientRatingCleared returns if the "client_rating" field was cleared in this mutation.
func (m *WorkHistoryMutation) ClientRatingCleared() bool {
	_, ok := m.clearedFields[workhistory.FieldClientRating]
	return ok
}

// ResetClientRating resets all changes to the "client_rating" field.
func (m *WorkHistoryMutation) ResetClientRating() {
	m.client_rating = nil
	m.addclient_rating = nil
	delete(m.clearedFields, workhistory.FieldClientRating)
}

// SetClientReviewCount sets the "client_review_count" field.
func (m *WorkHistoryMutation) SetClientReviewCount(i int) {
	m.client_review_count = &i
	m.addclient_review_count = nil
}

// ClientReviewCount returns the value of the "client_review_count" field in the mutation.
func (m *WorkHistoryMutation) ClientReviewCount() (r int, exists bool) {
	v := m.client_review_count
	if v == nil {
		return
	}
	return *v, true
}

// OldClientReviewCount returns the old "client_review_count" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldClientReviewCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientReviewCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientReviewCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientReviewCount: %w", err)
	}
	return oldValue.ClientReviewCount, nil
}

// AddClientReviewCount adds i to the "client_review_count" field.
func (m *WorkHistoryMutation) AddClientReviewCount(i int) {
	if m.addclient_review_count != nil {
		*m.addclient_review_count += i
	} else {
		m.addclient_review_count = &i
	}
}

// AddedClientReviewCount returns the value that was added to the "client_review_count" field in this mutation.
func (m *WorkHistoryMutation) AddedClientReviewCount() (r int, exists bool) {
	v := m.addclient_review_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearClientReviewCount clears the value of the "client_review_count" field.
func (m *WorkHistoryMutation) ClearClientReviewCount() {
	m.client_review_count = nil
	m.addclient_review_count = nil
	m.clearedFields[workhistory.FieldClientReviewCount] = struct{}{}
}

// ClientReviewCountCleared returns if the "client_review_count" field was cleared in this mutation.
func (m *WorkHistoryMutation) ClientReviewCountCleared() bool {
	_, ok := m.clearedFields[workhistory.FieldClientReviewCount]
	return ok
}

// ResetClientReviewCount resets all changes to the "client_review_count" field.
func (m *WorkHistoryMutation) ResetClientReviewCount() {
	m.client_review_count = nil
	m.addclient_review_count = nil
	delete(m.clearedFields, workhistory.FieldClientReviewCount)
}

// SetClientCountry sets the "client_country" field.
func (m *WorkHistoryMutation) SetClientCountry(s string) {
	m.client_country = &s
}

// ClientCountry returns the value of the "client_country" field in the mutation.
func (m *WorkHistoryMutation) ClientCountry() (r string, exists bool) {
	v := m.client_country
	if v == nil {
		return
	}
	return *v, true
}

// OldClientCountry returns the old "client_country" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldClientCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientCountry: %w", err)
	}
	return oldValue.ClientCountry, nil
}

// ClearClientCountry clears the value of the "client_country" field.
func (m *WorkHistoryMutation) ClearClientCountry() {
	m.client_country = nil
	m.clearedFields[workhistory.FieldClientCountry] = struct{}{}
}

// ClientCountryCleared returns if the "client_country" field was cleared in this mutation.
func (m *WorkHistoryMutation) ClientCountryCleared() bool {
	_, ok := m.clearedFields[workhistory.FieldClientCountry]
	return ok
}

// ResetClientCountry resets all changes to the "client_country" field.
func (m *WorkHistoryMutation) ResetClientCountry() {
	m.client_country = nil
	delete(m.clearedFields, workhistory.FieldClientCountry)
}

// SetClientTotalJobsPosted sets the "client_total_jobs_posted" field.
func (m *WorkHistoryMutation) SetClientTotalJobsPosted(i int) {
	m.client_total_jobs_posted = &i
	m.addclient_total_jobs_posted = nil
}

// ClientTotalJobsPosted returns the value of the "client_total_jobs_posted" field in the mutation.
func (m *WorkHistoryMutation) ClientTotalJobsPosted() (r int, exists bool) {
	v := m.client_total_jobs_posted
	if v == nil {
		return
	}
	return *v, true
}

// OldClientTotalJobsPosted returns the old "client_total_jobs_posted" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldClientTotalJobsPosted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientTotalJobsPosted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientTotalJobsPosted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientTotalJobsPosted: %w", err)
	}
	return oldValue.ClientTotalJobsPosted, nil
}

// AddClientTotalJobsPosted adds i to the "client_total_jobs_posted" field.
func (m *WorkHistoryMutation) AddClientTotalJobsPosted(i int) {
	if m.addclient_total_jobs_posted != nil {
		*m.addclient_total_jobs_posted += i
	} else {
		m.addclient_total_jobs_posted = &i
	}
}

// AddedClientTotalJobsPosted returns the value that was added to the "client_total_jobs_posted" field in this mutation.
func (m *WorkHistoryMutation) AddedClientTotalJobsPosted() (r int, exists bool) {
	v := m.addclient_total_jobs_posted
	if v == nil {
		return
	}
	return *v, true
}

// ClearClientTotalJobsPosted clears the value of the "client_total_jobs_posted" field.
func (m *WorkHistoryMutation) ClearClientTotalJobsPosted() {
	m.client_total_jobs_posted = nil
	m.addclient_total_jobs_posted = nil
	m.clearedFields[workhistory.FieldClientTotalJobsPosted] = struct{}{}
}

// ClientTotalJobsPostedCleared returns if the "client_total_jobs_posted" field was cleared in this mutation.
func (m *WorkHistoryMutation) ClientTotalJobsPostedCleared() bool {
	_, ok := m.clearedFields[workhistory.FieldClientTotalJobsPosted]
	return ok
}

// ResetClientTotalJobsPosted resets all changes to the "client_total_jobs_posted" field.
func (m *WorkHistoryMutation) ResetClientTotalJobsPosted() {
	m.client_total_jobs_posted = nil
	m.addclient_total_jobs_posted = nil
	delete(m.clearedFields, workhistory.FieldClientTotalJobsPosted)
}

// SetClientTotalSpend sets the "client_total_spend" field.
func (m *WorkHistoryMutation) SetClientTotalSpend(f float64) {
	m.client_total_spend = &f
	m.addclient_total_spend = nil
}

// ClientTotalSpend returns the value of the "client_total_spend" field in the mutation.
func (m *WorkHistoryMutation) ClientTotalSpend() (r float64, exists bool) {
	v := m.client_total_spend
	if v == nil {
		return
	}
	return *v, true
}

// OldClientTotalSpend returns the old "client_total_spend" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldClientTotalSpend(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientTotalSpend is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientTotalSpend requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientTotalSpend: %w", err)
	}
	return oldValue.ClientTotalSpend, nil
}

// AddClientTotalSpend adds f to the "client_total_spend" field.
func (m *WorkHistoryMutation) AddClientTotalSpend(f float64) {
	if m.addclient_total_spend != nil {
		*m.addclient_total_spend += f
	} else {
		m.addclient_total_spend = &f
	}
}

// AddedClientTotalSpend returns the value that was added to the "client_total_spend" field in this mutation.
func (m *WorkHistoryMutation) AddedClientTotalSpend() (r float64, exists bool) {
	v := m.addclient_total_spend
	if v == nil {
		return
	}
	return *v, true
}

// ClearClientTotalSpend clears the value of the "client_total_spend" field.
func (m *WorkHistoryMutation) ClearClientTotalSpend() {
	m.client_total_spend = nil
	m.addclient_total_spend = nil
	m.clearedFields[workhistory.FieldClientTotalSpend] = struct{}{}
}

// ClientTotalSpendCleared returns if the "client_total_spend" field was cleared in this mutation.
func (m *WorkHistoryMutation) ClientTotalSpendCleared() bool {
	_, ok := m.clearedFields[workhistory.FieldClientTotalSpend]
	return ok
}

// ResetClientTotalSpend resets all changes to the "client_total_spend" field.
func (m *WorkHistoryMutation) ResetClientTotalSpend() {
	m.client_total_spend = nil
	m.addclient_total_spend = nil
	delete(m.clearedFields, workhistory.FieldClientTotalSpend)
}

// SetClientTotalHires sets the "client_total_hires" field.
func (m *WorkHistoryMutation) SetClientTotalHires(i int) {
	m.client_total_hires = &i
	m.addclient_total_hires = nil
}

// ClientTotalHires returns the value of the "client_total_hires" field in the mutation.
func (m *WorkHistoryMutation) ClientTotalHires() (r int, exists bool) {
	v := m.client_total_hires
	if v == nil {
		return
	}
	return *v, true
}

// OldClientTotalHires returns the old "client_total_hires" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldClientTotalHires(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientTotalHires is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientTotalHires requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientTotalHires: %w", err)
	}
	return oldValue.ClientTotalHires, nil
}

// AddClientTotalHires adds i to the "client_total_hires" field.
func (m *WorkHistoryMutation) AddClientTotalHires(i int) {
	if m.addclient_total_hires != nil {
		*m.addclient_total_hires += i
	} else {
		m.addclient_total_hires = &i
	}
}

// AddedClientTotalHires returns the value that was added to the "client_total_hires" field in this mutation.
func (m *WorkHistoryMutation) AddedClientTotalHires() (r int, exists bool) {
	v := m.addclient_total_hires
	if v == nil {
		return
	}
	return *v, true
}

// ClearClientTotalHires clears the value of the "client_total_hires" field.
func (m *WorkHistoryMutation) ClearClientTotalHires() {
	m.client_total_hires = nil
	m.addclient_total_hires = nil
	m.clearedFields[workhistory.FieldClientTotalHires] = struct{}{}
}

// ClientTotalHiresCleared returns if the "client_total_hires" field was cleared in this mutation.
func (m *WorkHistoryMutation) ClientTotalHiresCleared() bool {
	_, ok := m.clearedFields[workhistory.FieldClientTotalHires]
	return ok
}

// ResetClientTotalHires resets all changes to the "client_total_hires" field.
func (m *WorkHistoryMutation) ResetClientTotalHires() {
	m.client_total_hires = nil
	m.addclient_total_hires = nil
	delete(m.clearedFields, workhistory.FieldClientTotalHires)
}

// SetClientActiveHires sets the "client_active_hires" field.
func (m *WorkHistoryMutation) SetClientActiveHires(i int) {
	m.client_active_hires = &i
	m.addclient_active_hires = nil
}

// ClientActiveHires returns the value of the "client_active_hires" field in the mutation.
func (m *WorkHistoryMutation) ClientActiveHires() (r int, exists bool) {
	v := m.client_active_hires
	if v == nil {
		return
	}
	return *v, true
}

// OldClientActiveHires returns the old "client_active_hires" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldClientActiveHires(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientActiveHires is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientActiveHires requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientActiveHires: %w", err)
	}
	return oldValue.ClientActiveHires, nil
}

// AddClientActiveHires adds i to the "client_active_hires" field.
func (m *WorkHistoryMutation) AddClientActiveHires(i int) {
	if m.addclient_active_hires != nil {
		*m.addclient_active_hires += i
	} else {
		m.addclient_active_hires = &i
	}
}

// AddedClientActiveHires returns the value that was added to the "client_active_hires" field in this mutation.
func (m *WorkHistoryMutation) AddedClientActiveHires() (r int, exists bool) {
	v := m.addclient_active_hires
	if v == nil {
		return
	}
	return *v, true
}

// ClearClientActiveHires clears the value of the "client_active_hires" field.
func (m *WorkHistoryMutation) ClearClientActiveHires() {
	m.client_active_hires = nil
	m.addclient_active_hires = nil
	m.clearedFields[workhistory.FieldClientActiveHires] = struct{}{}
}

// ClientActiveHiresCleared returns if the "client_active_hires" field was cleared in this mutation.
func (m *WorkHistoryMutation) ClientActiveHiresCleared() bool {
	_, ok := m.clearedFields[workhistory.FieldClientActiveHires]
	return ok
}

// ResetClientActiveHires resets all changes to the "client_active_hires" field.
func (m *WorkHistoryMutation) ResetClientActiveHires() {
	m.client_active_hires = nil
	m.addclient_active_hires = nil
	delete(m.clearedFields, workhistory.FieldClientActiveHires)
}

// SetClientTotalPaidHours sets the "client_total_paid_hours" field.
func (m *WorkHistoryMutation) SetClientTotalPaidHours(i int) {
	m.client_total_paid_hours = &i
	m.addclient_total_paid_hours = nil
}

// ClientTotalPaidHours returns the value of the "client_total_paid_hours" field in the mutation.
func (m *WorkHistoryMutation) ClientTotalPaidHours() (r int, exists bool) {
	v := m.client_total_paid_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldClientTotalPaidHours returns the old "client_total_paid_hours" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldClientTotalPaidHours(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientTotalPaidHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientTotalPaidHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientTotalPaidHours: %w", err)
	}
	return oldValue.ClientTotalPaidHours, nil
}

// AddClientTotalPaidHours adds i to the "client_total_paid_hours" field.
func (m *WorkHistoryMutation) AddClientTotalPaidHours(i int) {
	if m.addclient_total_paid_hours != nil {
		*m.addclient_total_paid_hours += i
	} else {
		m.addclient_total_paid_hours = &i
	}
}

// AddedClientTotalPaidHours returns the value that was added to the "client_total_paid_hours" field in this mutation.
func (m *WorkHistoryMutation) AddedClientTotalPaidHours() (r int, exists bool) {
	v := m.addclient_total_paid_hours
	if v == nil {
		return
	}
	return *v, true
}

// ClearClientTotalPaidHours clears the value of the "client_total_paid_hours" field.
func (m *WorkHistoryMutation) ClearClientTotalPaidHours() {
	m.client_total_paid_hours = nil
	m.addclient_total_paid_hours = nil
	m.clearedFields[workhistory.FieldClientTotalPaidHours] = struct{}{}
}

// ClientTotalPaidHoursCleared returns if the "client_total_paid_hours" field was cleared in this mutation.
func (m *WorkHistoryMutation) ClientTotalPaidHoursCleared() bool {
	_, ok := m.clearedFields[workhistory.FieldClientTotalPaidHours]
	return ok
}

// ResetClientTotalPaidHours resets all changes to the "client_total_paid_hours" field.
func (m *WorkHistoryMutation) ResetClientTotalPaidHours() {
	m.client_total_paid_hours = nil
	m.addclient_total_paid_hours = nil
	delete(m.clearedFields, workhistory.FieldClientTotalPaidHours)
}

// SetClientAverageHourlyRatePaid sets the "client_average_hourly_rate_paid" field.
func (m *WorkHistoryMutation) SetClientAverageHourlyRatePaid(f float64) {
	m.client_average_hourly_rate_paid = &f
	m.addclient_average_hourly_rate_paid = nil
}

// ClientAverageHourlyRatePaid returns the value of the "client_average_hourly_rate_paid" field in the mutation.
func (m *WorkHistoryMutation) ClientAverageHourlyRatePaid() (r float64, exists bool) {
	v := m.client_average_hourly_rate_paid
	if v == nil {
		return
	}
	return *v, true
}

// OldClientAverageHourlyRatePaid returns the old "client_average_hourly_rate_paid" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldClientAverageHourlyRatePaid(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientAverageHourlyRatePaid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientAverageHourlyRatePaid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientAverageHourlyRatePaid: %w", err)
	}
	return oldValue.ClientAverageHourlyRatePaid, nil
}

// AddClientAverageHourlyRatePaid adds f to the "client_average_hourly_rate_paid" field.
func (m *WorkHistoryMutation) AddClientAverageHourlyRatePaid(f float64) {
	if m.addclient_average_hourly_rate_paid != nil {
		*m.addclient_average_hourly_rate_paid += f
	} else {
		m.addclient_average_hourly_rate_paid = &f
	}
}

// AddedClientAverageHourlyRatePaid returns the value that was added to the "client_average_hourly_rate_paid" field in this mutation.
func (m *WorkHistoryMutation) AddedClientAverageHourlyRatePaid() (r float64, exists bool) {
	v := m.addclient_average_hourly_rate_paid
	if v == nil {
		return
	}
	return *v, true
}

// ClearClientAverageHourlyRatePaid clears the value of the "client_average_hourly_rate_paid" field.
func (m *WorkHistoryMutation) ClearClientAverageHourlyRatePaid() {
	m.client_average_hourly_rate_paid = nil
	m.addclient_average_hourly_rate_paid = nil
	m.clearedFields[workhistory.FieldClientAverageHourlyRatePaid] = struct{}{}
}

// ClientAverageHourlyRatePaidCleared returns if the "client_average_hourly_rate_paid" field was cleared in this mutation.
func (m *WorkHistoryMutation) ClientAverageHourlyRatePaidCleared() bool {
	_, ok := m.clearedFields[workhistory.FieldClientAverageHourlyRatePaid]
	return ok
}

// ResetClientAverageHourlyRatePaid resets all changes to the "client_average_hourly_rate_paid" field.
func (m *WorkHistoryMutation) ResetClientAverageHourlyRatePaid() {
	m.client_average_hourly_rate_paid = nil
	m.addclient_average_hourly_rate_paid = nil
	delete(m.clearedFields, workhistory.FieldClientAverageHourlyRatePaid)
}

// SetClientCompanyCategory sets the "client_company_category" field.
func (m *WorkHistoryMutation) SetClientCompanyCategory(s string) {
	m.client_company_category = &s
}

// ClientCompanyCategory returns the value of the "client_company_category" field in the mutation.
func (m *WorkHistoryMutation) ClientCompanyCategory() (r string, exists bool) {
	v := m.client_company_category
	if v == nil {
		return
	}
	return *v, true
}

// OldClientCompanyCategory returns the old "client_company_category" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldClientCompanyCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientCompanyCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientCompanyCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientCompanyCategory: %w", err)
	}
	return oldValue.ClientCompanyCategory, nil
}

// ClearClientCompanyCategory clears the value of the "client_company_category" field.
func (m *WorkHistoryMutation) ClearClientCompanyCategory() {
	m.client_company_category = nil
	m.clearedFields[workhistory.FieldClientCompanyCategory] = struct{}{}
}

// ClientCompanyCategoryCleared returns if the "client_company_category" field was cleared in this mutation.
func (m *WorkHistoryMutation) ClientCompanyCategoryCleared() bool {
	_, ok := m.clearedFields[workhistory.FieldClientCompanyCategory]
	return ok
}

// ResetClientCompanyCategory resets all changes to the "client_company_category" field.
func (m *WorkHistoryMutation) ResetClientCompanyCategory() {
	m.client_company_category = nil
	delete(m.clearedFields, workhistory.FieldClientCompanyCategory)
}

// SetClientCompanySize sets the "client_company_size" field.
func (m *WorkHistoryMutation) SetClientCompanySize(s string) {
	m.client_company_size = &s
}

// ClientCompanySize returns the value of the "client_company_size" field in the mutation.
func (m *WorkHistoryMutation) ClientCompanySize() (r string, exists bool) {
	v := m.client_company_size
	if v == nil {
		return
	}
	return *v, true
}

// OldClientCompanySize returns the old "client_company_size" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldClientCompanySize(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientCompanySize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientCompanySize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientCompanySize: %w", err)
	}
	return oldValue.ClientCompanySize, nil
}

// ClearClientCompanySize clears the value of the "client_company_size" field.
func (m *WorkHistoryMutation) ClearClientCompanySize() {
	m.client_company_size = nil
	m.clearedFields[workhistory.FieldClientCompanySize] = struct{}{}
}

// ClientCompanySizeCleared returns if the "client_company_size" field was cleared in this mutation.
func (m *WorkHistoryMutation) ClientCompanySizeCleared() bool {
	_, ok := m.clearedFields[workhistory.FieldClientCompanySize]
	return ok
}

// ResetClientCompanySize resets all changes to the "client_company_size" field.
func (m *WorkHistoryMutation) ResetClientCompanySize() {
	m.client_company_size = nil
	delete(m.clearedFields, workhistory.FieldClientCompanySize)
}

// SetTotalProposals sets the "total_proposals" field.
func (m *WorkHistoryMutation) SetTotalProposals(i int) {
	m.total_proposals = &i
	m.addtotal_proposals = nil
}

// TotalProposals returns the value of the "total_proposals" field in the mutation.
func (m *WorkHistoryMutation) TotalProposals() (r int, exists bool) {
	v := m.total_proposals
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalProposals returns the old "total_proposals" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldTotalProposals(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalProposals is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalProposals requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalProposals: %w", err)
	}
	return oldValue.TotalProposals, nil
}

// AddTotalProposals adds i to the "total_proposals" field.
func (m *WorkHistoryMutation) AddTotalProposals(i int) {
	if m.addtotal_proposals != nil {
		*m.addtotal_proposals += i
	} else {
		m.addtotal_proposals = &i
	}
}

// AddedTotalProposals returns the value that was added to the "total_proposals" field in this mutation.
func (m *WorkHistoryMutation) AddedTotalProposals() (r int, exists bool) {
	v := m.addtotal_proposals
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotalProposals clears the value of the "total_proposals" field.
func (m *WorkHistoryMutation) ClearTotalProposals() {
	m.total_proposals = nil
	m.addtotal_proposals = nil
	m.clearedFields[workhistory.FieldTotalProposals] = struct{}{}
}

// TotalProposalsCleared returns if the "total_proposals" field was cleared in this mutation.
func (m *WorkHistoryMutation) TotalProposalsCleared() bool {
	_, ok := m.clearedFields[workhistory.FieldTotalProposals]
	return ok
}

// ResetTotalProposals resets all changes to the "total_proposals" field.
func (m *WorkHistoryMutation) ResetTotalProposals() {
	m.total_proposals = nil
	m.addtotal_proposals = nil
	delete(m.clearedFields, workhistory.FieldTotalProposals)
}

// SetNumberOfInterviews sets the "number_of_interviews" field.
func (m *WorkHistoryMutation) SetNumberOfInterviews(i int) {
	m.number_of_interviews = &i
	m.addnumber_of_interviews = nil
}

// NumberOfInterviews returns the value of the "number_of_interviews" field in the mutation.
func (m *WorkHistoryMutation) NumberOfInterviews() (r int, exists bool) {
	v := m.number_of_interviews
	if v == nil {
		return
	}
	return *v, true
}

// OldNumberOfInterviews returns the old "number_of_interviews" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldNumberOfInterviews(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumberOfInterviews is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumberOfInterviews requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumberOfInterviews: %w", err)
	}
	return oldValue.NumberOfInterviews, nil
}

// AddNumberOfInterviews adds i to the "number_of_interviews" field.
func (m *WorkHistoryMutation) AddNumberOfInterviews(i int) {
	if m.addnumber_of_interviews != nil {
		*m.addnumber_of_interviews += i
	} else {
		m.addnumber_of_interviews = &i
	}
}

// AddedNumberOfInterviews returns the value that was added to the "number_of_interviews" field in this mutation.
func (m *WorkHistoryMutation) AddedNumberOfInterviews() (r int, exists bool) {
	v := m.addnumber_of_interviews
	if v == nil {
		return
	}
	return *v, true
}

// ClearNumberOfInterviews clears the value of the "number_of_interviews" field.
func (m *WorkHistoryMutation) ClearNumberOfInterviews() {
	m.number_of_interviews = nil
	m.addnumber_of_interviews = nil
	m.clearedFields[workhistory.FieldNumberOfInterviews] = struct{}{}
}

// NumberOfInterviewsCleared returns if the "number_of_interviews" field was cleared in this mutation.
func (m *WorkHistoryMutation) NumberOfInterviewsCleared() bool {
	_, ok := m.clearedFields[workhistory.FieldNumberOfInterviews]
	return ok
}

// ResetNumberOfInterviews resets all changes to the "number_of_interviews" field.
func (m *WorkHistoryMutation) ResetNumberOfInterviews() {
	m.number_of_interviews = nil
	m.addnumber_of_interviews = nil
	delete(m.clearedFields, workhistory.FieldNumberOfInterviews)
}

// SetSkills sets the "skills" field.
func (m *WorkHistoryMutation) SetSkills(s []string) {
	m.skills = &s
	m.appendskills = nil
}

// Skills returns the value of the "skills" field in the mutation.
func (m *WorkHistoryMutation) Skills() (r []string, exists bool) {
	v := m.skills
	if v == nil {
		return
	}
	return *v, true
}

// OldSkills returns the old "skills" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldSkills(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkills is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkills requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkills: %w", err)
	}
	return oldValue.Skills, nil
}

// AppendSkills adds s to the "skills" field.
func (m *WorkHistoryMutation) AppendSkills(s []string) {
	m.appendskills = append(m.appendskills, s...)
}

// AppendedSkills returns the list of values that were appended to the "skills" field in this mutation.
func (m *WorkHistoryMutation) AppendedSkills() ([]string, bool) {
	if len(m.appendskills) == 0 {
		return nil, false
	}
	return m.appendskills, true
}

// ClearSkills clears the value of the "skills" field.
func (m *WorkHistoryMutation) ClearSkills() {
	m.skills = nil
	m.appendskills = nil
	m.clearedFields[workhistory.FieldSkills] = struct{}{}
}

// SkillsCleared returns if the "skills" field was cleared in this mutation.
func (m *WorkHistoryMutation) SkillsCleared() bool {
	_, ok := m.clearedFields[workhistory.FieldSkills]
	return ok
}

// ResetSkills resets all changes to the "skills" field.
func (m *WorkHistoryMutation) ResetSkills() {
	m.skills = nil
	m.appendskills = nil
	delete(m.clearedFields, workhistory.FieldSkills)
}

// SetFreelancerID sets the "freelancer" edge to the UpworkFreelancer entity by id.
func (m *WorkHistoryMutation) SetFreelancerID(id string) {
	m.freelancer = &id
}

// ClearFreelancer clears the "freelancer" edge to the UpworkFreelancer entity.
func (m *WorkHistoryMutation) ClearFreelancer() {
	m.clearedfreelancer = true
}

// FreelancerCleared reports if the "freelancer" edge to the UpworkFreelancer entity was cleared.
func (m *WorkHistoryMutation) FreelancerCleared() bool {
	return m.clearedfreelancer
}

// FreelancerID returns the "freelancer" edge ID in the mutation.
func (m *WorkHistoryMutation) FreelancerID() (id string, exists bool) {
	if m.freelancer != nil {
		return *m.freelancer, true
	}
	return
}

// FreelancerIDs returns the "freelancer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FreelancerID instead. It exists only for internal usage by the builders.
func (m *WorkHistoryMutation) FreelancerIDs() (ids []string) {
	if id := m.freelancer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFreelancer resets all changes to the "freelancer" edge.
func (m *WorkHistoryMutation) ResetFreelancer() {
	m.freelancer = nil
	m.clearedfreelancer = false
}

// Where appends a list predicates to the WorkHistoryMutation builder.
func (m *WorkHistoryMutation) Where(ps ...predicate.WorkHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkHistory).
func (m *WorkHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkHistoryMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.title != nil {
		fields = append(fields, workhistory.FieldTitle)
	}
	if m.client_feedback != nil {
		fields = append(fields, workhistory.FieldClientFeedback)
	}
	if m.overall_rating != nil {
		fields = append(fields, workhistory.FieldOverallRating)
	}
	if m.freelancer_earnings != nil {
		fields = append(fields, workhistory.FieldFreelancerEarnings)
	}
	if m.start_date != nil {
		fields = append(fields, workhistory.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, workhistory.FieldEndDate)
	}
	if m.description != nil {
		fields = append(fields, workhistory.FieldDescription)
	}
	if m.budget != nil {
		fields = append(fields, workhistory.FieldBudget)
	}
	if m.client_rating != nil {
		fields = append(fields, workhistory.FieldClientRating)
	}
	if m.client_review_count != nil {
		fields = append(fields, workhistory.FieldClientReviewCount)
	}
	if m.client_country != nil {
		fields = append(fields, workhistory.FieldClientCountry)
	}
	if m.client_total_jobs_posted != nil {
		fields = append(fields, workhistory.FieldClientTotalJobsPosted)
	}
	if m.client_total_spend != nil {
		fields = append(fields, workhistory.FieldClientTotalSpend)
	}
	if m.client_total_hires != nil {
		fields = append(fields, workhistory.FieldClientTotalHires)
	}
	if m.client_active_hires != nil {
		fields = append(fields, workhistory.FieldClientActiveHires)
	}
	if m.client_total_paid_hours != nil {
		fields = append(fields, workhistory.FieldClientTotalPaidHours)
	}
	if m.client_average_hourly_rate_paid != nil {
		fields = append(fields, workhistory.FieldClientAverageHourlyRatePaid)
	}
	if m.client_company_category != nil {
		fields = append(fields, workhistory.FieldClientCompanyCategory)
	}
	if m.client_company_size != nil {
		fields = append(fields, workhistory.FieldClientCompanySize)
	}
	if m.total_proposals != nil {
		fields = append(fields, workhistory.FieldTotalProposals)
	}
	if m.number_of_interviews != nil {
		fields = append(fields, workhistory.FieldNumberOfInterviews)
	}
	if m.skills != nil {
		fields = append(fields, workhistory.FieldSkills)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workhistory.FieldTitle:
		return m.Title()
	case workhistory.FieldClientFeedback:
		return m.ClientFeedback()
	case workhistory.FieldOverallRating:
		return m.OverallRating()
	case workhistory.FieldFreelancerEarnings:
		return m.FreelancerEarnings()
	case workhistory.FieldStartDate:
		return m.StartDate()
	case workhistory.FieldEndDate:
		return m.EndDate()
	case workhistory.FieldDescription:
		return m.Description()
	case workhistory.FieldBudget:
		return m.Budget()
	case workhistory.FieldClientRating:
		return m.ClientRating()
	case workhistory.FieldClientReviewCount:
		return m.ClientReviewCount()
	case workhistory.FieldClientCountry:
		return m.ClientCountry()
	case workhistory.FieldClientTotalJobsPosted:
		return m.ClientTotalJobsPosted()
	case workhistory.FieldClientTotalSpend:
		return m.ClientTotalSpend()
	case workhistory.FieldClientTotalHires:
		return m.ClientTotalHires()
	case workhistory.FieldClientActiveHires:
		return m.ClientActiveHires()
	case workhistory.FieldClientTotalPaidHours:
		return m.ClientTotalPaidHours()
	case workhistory.FieldClientAverageHourlyRatePaid:
		return m.ClientAverageHourlyRatePaid()
	case workhistory.FieldClientCompanyCategory:
		return m.ClientCompanyCategory()
	case workhistory.FieldClientCompanySize:
		return m.ClientCompanySize()
	case workhistory.FieldTotalProposals:
		return m.TotalProposals()
	case workhistory.FieldNumberOfInterviews:
		return m.NumberOfInterviews()
	case workhistory.FieldSkills:
		return m.Skills()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workhistory.FieldTitle:
		return m.OldTitle(ctx)
	case workhistory.FieldClientFeedback:
		return m.OldClientFeedback(ctx)
	case workhistory.FieldOverallRating:
		return m.OldOverallRating(ctx)
	case workhistory.FieldFreelancerEarnings:
		return m.OldFreelancerEarnings(ctx)
	case workhistory.FieldStartDate:
		return m.OldStartDate(ctx)
	case workhistory.FieldEndDate:
		return m.OldEndDate(ctx)
	case workhistory.FieldDescription:
		return m.OldDescription(ctx)
	case workhistory.FieldBudget:
		return m.OldBudget(ctx)
	case workhistory.FieldClientRating:
		return m.OldClientRating(ctx)
	case workhistory.FieldClientReviewCount:
		return m.OldClientReviewCount(ctx)
	case workhistory.FieldClientCountry:
		return m.OldClientCountry(ctx)
	case workhistory.FieldClientTotalJobsPosted:
		return m.OldClientTotalJobsPosted(ctx)
	case workhistory.FieldClientTotalSpend:
		return m.OldClientTotalSpend(ctx)
	case workhistory.FieldClientTotalHires:
		return m.OldClientTotalHires(ctx)
	case workhistory.FieldClientActiveHires:
		return m.OldClientActiveHires(ctx)
	case workhistory.FieldClientTotalPaidHours:
		return m.OldClientTotalPaidHours(ctx)
	case workhistory.FieldClientAverageHourlyRatePaid:
		return m.OldClientAverageHourlyRatePaid(ctx)
	case workhistory.FieldClientCompanyCategory:
		return m.OldClientCompanyCategory(ctx)
	case workhistory.FieldClientCompanySize:
		return m.OldClientCompanySize(ctx)
	case workhistory.FieldTotalProposals:
		return m.OldTotalProposals(ctx)
	case workhistory.FieldNumberOfInterviews:
		return m.OldNumberOfInterviews(ctx)
	case workhistory.FieldSkills:
		return m.OldSkills(ctx)
	}
	return nil, fmt.Errorf("unknown WorkHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workhistory.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case workhistory.FieldClientFeedback:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientFeedback(v)
		return nil
	case workhistory.FieldOverallRating:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverallRating(v)
		return nil
	case workhistory.FieldFreelancerEarnings:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFreelancerEarnings(v)
		return nil
	case workhistory.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case workhistory.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case workhistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case workhistory.FieldBudget:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBudget(v)
		return nil
	case workhistory.FieldClientRating:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientRating(v)
		return nil
	case workhistory.FieldClientReviewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientReviewCount(v)
		return nil
	case workhistory.FieldClientCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientCountry(v)
		return nil
	case workhistory.FieldClientTotalJobsPosted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientTotalJobsPosted(v)
		return nil
	case workhistory.FieldClientTotalSpend:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientTotalSpend(v)
		return nil
	case workhistory.FieldClientTotalHires:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientTotalHires(v)
		return nil
	case workhistory.FieldClientActiveHires:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientActiveHires(v)
		return nil
	case workhistory.FieldClientTotalPaidHours:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientTotalPaidHours(v)
		return nil
	case workhistory.FieldClientAverageHourlyRatePaid:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientAverageHourlyRatePaid(v)
		return nil
	case workhistory.FieldClientCompanyCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientCompanyCategory(v)
		return nil
	case workhistory.FieldClientCompanySize:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientCompanySize(v)
		return nil
	case workhistory.FieldTotalProposals:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalProposals(v)
		return nil
	case workhistory.FieldNumberOfInterviews:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumberOfInterviews(v)
		return nil
	case workhistory.FieldSkills:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkills(v)
		return nil
	}
	return fmt.Errorf("unknown WorkHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addoverall_rating != nil {
		fields = append(fields, workhistory.FieldOverallRating)
	}
	if m.addfreelancer_earnings != nil {
		fields = append(fields, workhistory.FieldFreelancerEarnings)
	}
	if m.addbudget != nil {
		fields = append(fields, workhistory.FieldBudget)
	}
	if m.addclient_rating != nil {
		fields = append(fields, workhistory.FieldClientRating)
	}
	if m.addclient_review_count != nil {
		fields = append(fields, workhistory.FieldClientReviewCount)
	}
	if m.addclient_total_jobs_posted != nil {
		fields = append(fields, workhistory.FieldClientTotalJobsPosted)
	}
	if m.addclient_total_spend != nil {
		fields = append(fields, workhistory.FieldClientTotalSpend)
	}
	if m.addclient_total_hires != nil {
		fields = append(fields, workhistory.FieldClientTotalHires)
	}
	if m.addclient_active_hires != nil {
		fields = append(fields, workhistory.FieldClientActiveHires)
	}
	if m.addclient_total_paid_hours != nil {
		fields = append(fields, workhistory.FieldClientTotalPaidHours)
	}
	if m.addclient_average_hourly_rate_paid != nil {
		fields = append(fields, workhistory.FieldClientAverageHourlyRatePaid)
	}
	if m.addtotal_proposals != nil {
		fields = append(fields, workhistory.FieldTotalProposals)
	}
	if m.addnumber_of_interviews != nil {
		fields = append(fields, workhistory.FieldNumberOfInterviews)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workhistory.FieldOverallRating:
		return m.AddedOverallRating()
	case workhistory.FieldFreelancerEarnings:
		return m.AddedFreelancerEarnings()
	case workhistory.FieldBudget:
		return m.AddedBudget()
	case workhistory.FieldClientRating:
		return m.AddedClientRating()
	case workhistory.FieldClientReviewCount:
		return m.AddedClientReviewCount()
	case workhistory.FieldClientTotalJobsPosted:
		return m.AddedClientTotalJobsPosted()
	case workhistory.FieldClientTotalSpend:
		return m.AddedClientTotalSpend()
	case workhistory.FieldClientTotalHires:
		return m.AddedClientTotalHires()
	case workhistory.FieldClientActiveHires:
		return m.AddedClientActiveHires()
	case workhistory.FieldClientTotalPaidHours:
		return m.AddedClientTotalPaidHours()
	case workhistory.FieldClientAverageHourlyRatePaid:
		return m.AddedClientAverageHourlyRatePaid()
	case workhistory.FieldTotalProposals:
		return m.AddedTotalProposals()
	case workhistory.FieldNumberOfInterviews:
		return m.AddedNumberOfInterviews()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workhistory.FieldOverallRating:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOverallRating(v)
		return nil
	case workhistory.FieldFreelancerEarnings:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFreelancerEarnings(v)
		return nil
	case workhistory.FieldBudget:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBudget(v)
		return nil
	case workhistory.FieldClientRating:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClientRating(v)
		return nil
	case workhistory.FieldClientReviewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClientReviewCount(v)
		return nil
	case workhistory.FieldClientTotalJobsPosted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClientTotalJobsPosted(v)
		return nil
	case workhistory.FieldClientTotalSpend:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClientTotalSpend(v)
		return nil
	case workhistory.FieldClientTotalHires:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClientTotalHires(v)
		return nil
	case workhistory.FieldClientActiveHires:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClientActiveHires(v)
		return nil
	case workhistory.FieldClientTotalPaidHours:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClientTotalPaidHours(v)
		return nil
	case workhistory.FieldClientAverageHourlyRatePaid:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClientAverageHourlyRatePaid(v)
		return nil
	case workhistory.FieldTotalProposals:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalProposals(v)
		return nil
	case workhistory.FieldNumberOfInterviews:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumberOfInterviews(v)
		return nil
	}
	return fmt.Errorf("unknown WorkHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workhistory.FieldClientFeedback) {
		fields = append(fields, workhistory.FieldClientFeedback)
	}
	if m.FieldCleared(workhistory.FieldOverallRating) {
		fields = append(fields, workhistory.FieldOverallRating)
	}
	if m.FieldCleared(workhistory.FieldFreelancerEarnings) {
		fields = append(fields, workhistory.FieldFreelancerEarnings)
	}
	if m.FieldCleared(workhistory.FieldStartDate) {
		fields = append(fields, workhistory.FieldStartDate)
	}
	if m.FieldCleared(workhistory.FieldEndDate) {
		fields = append(fields, workhistory.FieldEndDate)
	}
	if m.FieldCleared(workhistory.FieldDescription) {
		fields = append(fields, workhistory.FieldDescription)
	}
	if m.FieldCleared(workhistory.FieldBudget) {
		fields = append(fields, workhistory.FieldBudget)
	}
	if m.FieldCleared(workhistory.FieldClientRating) {
		fields = append(fields, workhistory.FieldClientRating)
	}
	if m.FieldCleared(workhistory.FieldClientReviewCount) {
		fields = append(fields, workhistory.FieldClientReviewCount)
	}
	if m.FieldCleared(workhistory.FieldClientCountry) {
		fields = append(fields, workhistory.FieldClientCountry)
	}
	if m.FieldCleared(workhistory.FieldClientTotalJobsPosted) {
		fields = append(fields, workhistory.FieldClientTotalJobsPosted)
	}
	if m.FieldCleared(workhistory.FieldClientTotalSpend) {
		fields = append(fields, workhistory.FieldClientTotalSpend)
	}
	if m.FieldCleared(workhistory.FieldClientTotalHires) {
		fields = append(fields, workhistory.FieldClientTotalHires)
	}
	if m.FieldCleared(workhistory.FieldClientActiveHires) {
		fields = append(fields, workhistory.FieldClientActiveHires)
	}
	if m.FieldCleared(workhistory.FieldClientTotalPaidHours) {
		fields = append(fields, workhistory.FieldClientTotalPaidHours)
	}
	if m.FieldCleared(workhistory.FieldClientAverageHourlyRatePaid) {
		fields = append(fields, workhistory.FieldClientAverageHourlyRatePaid)
	}
	if m.FieldCleared(workhistory.FieldClientCompanyCategory) {
		fields = append(fields, workhistory.FieldClientCompanyCategory)
	}
	if m.FieldCleared(workhistory.FieldClientCompanySize) {
		fields = append(fields, workhistory.FieldClientCompanySize)
	}
	if m.FieldCleared(workhistory.FieldTotalProposals) {
		fields = append(fields, workhistory.FieldTotalProposals)
	}
	if m.FieldCleared(workhistory.FieldNumberOfInterviews) {
		fields = append(fields, workhistory.FieldNumberOfInterviews)
	}
	if m.FieldCleared(workhistory.FieldSkills) {
		fields = append(fields, workhistory.FieldSkills)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkHistoryMutation) ClearField(name string) error {
	switch name {
	case workhistory.FieldClientFeedback:
		m.ClearClientFeedback()
		return nil
	case workhistory.FieldOverallRating:
		m.ClearOverallRating()
		return nil
	case workhistory.FieldFreelancerEarnings:
		m.ClearFreelancerEarnings()
		return nil
	case workhistory.FieldStartDate:
		m.ClearStartDate()
		return nil
	case workhistory.FieldEndDate:
		m.ClearEndDate()
		return nil
	case workhistory.FieldDescription:
		m.ClearDescription()
		return nil
	case workhistory.FieldBudget:
		m.ClearBudget()
		return nil
	case workhistory.FieldClientRating:
		m.ClearClientRating()
		return nil
	case workhistory.FieldClientReviewCount:
		m.ClearClientReviewCount()
		return nil
	case workhistory.FieldClientCountry:
		m.ClearClientCountry()
		return nil
	case workhistory.FieldClientTotalJobsPosted:
		m.ClearClientTotalJobsPosted()
		return nil
	case workhistory.FieldClientTotalSpend:
		m.ClearClientTotalSpend()
		return nil
	case workhistory.FieldClientTotalHires:
		m.ClearClientTotalHires()
		return nil
	case workhistory.FieldClientActiveHires:
		m.ClearClientActiveHires()
		return nil
	case workhistory.FieldClientTotalPaidHours:
		m.ClearClientTotalPaidHours()
		return nil
	case workhistory.FieldClientAverageHourlyRatePaid:
		m.ClearClientAverageHourlyRatePaid()
		return nil
	case workhistory.FieldClientCompanyCategory:
		m.ClearClientCompanyCategory()
		return nil
	case workhistory.FieldClientCompanySize:
		m.ClearClientCompanySize()
		return nil
	case workhistory.FieldTotalProposals:
		m.ClearTotalProposals()
		return nil
	case workhistory.FieldNumberOfInterviews:
		m.ClearNumberOfInterviews()
		return nil
	case workhistory.FieldSkills:
		m.ClearSkills()
		return nil
	}
	return fmt.Errorf("unknown WorkHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkHistoryMutation) ResetField(name string) error {
	switch name {
	case workhistory.FieldTitle:
		m.ResetTitle()
		return nil
	case workhistory.FieldClientFeedback:
		m.ResetClientFeedback()
		return nil
	case workhistory.FieldOverallRating:
		m.ResetOverallRating()
		return nil
	case workhistory.FieldFreelancerEarnings:
		m.ResetFreelancerEarnings()
		return nil
	case workhistory.FieldStartDate:
		m.ResetStartDate()
		return nil
	case workhistory.FieldEndDate:
		m.ResetEndDate()
		return nil
	case workhistory.FieldDescription:
		m.ResetDescription()
		return nil
	case workhistory.FieldBudget:
		m.ResetBudget()
		return nil
	case workhistory.FieldClientRating:
		m.ResetClientRating()
		return nil
	case workhistory.FieldClientReviewCount:
		m.ResetClientReviewCount()
		return nil
	case workhistory.FieldClientCountry:
		m.ResetClientCountry()
		return nil
	case workhistory.FieldClientTotalJobsPosted:
		m.ResetClientTotalJobsPosted()
		return nil
	case workhistory.FieldClientTotalSpend:
		m.ResetClientTotalSpend()
		return nil
	case workhistory.FieldClientTotalHires:
		m.ResetClientTotalHires()
		return nil
	case workhistory.FieldClientActiveHires:
		m.ResetClientActiveHires()
		return nil
	case workhistory.FieldClientTotalPaidHours:
		m.ResetClientTotalPaidHours()
		return nil
	case workhistory.FieldClientAverageHourlyRatePaid:
		m.ResetClientAverageHourlyRatePaid()
		return nil
	case workhistory.FieldClientCompanyCategory:
		m.ResetClientCompanyCategory()
		return nil
	case workhistory.FieldClientCompanySize:
		m.ResetClientCompanySize()
		return nil
	case workhistory.FieldTotalProposals:
		m.ResetTotalProposals()
		return nil
	case workhistory.FieldNumberOfInterviews:
		m.ResetNumberOfInterviews()
		return nil
	case workhistory.FieldSkills:
		m.ResetSkills()
		return nil
	}
	return fmt.Errorf("unknown WorkHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.freelancer != nil {
		edges = append(edges, workhistory.EdgeFreelancer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkHistoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workhistory.EdgeFreelancer:
		if id := m.freelancer; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedfreelancer {
		edges = append(edges, workhistory.EdgeFreelancer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkHistoryMutation) EdgeCleared(name string) bool {
	switch name {
	case workhistory.EdgeFreelancer:
		return m.clearedfreelancer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkHistoryMutation) ClearEdge(name string) error {
	switch name {
	case workhistory.EdgeFreelancer:
		m.ClearFreelancer()
		return nil
	}
	return fmt.Errorf("unknown WorkHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkHistoryMutation) ResetEdge(name string) error {
	switch name {
	case workhistory.EdgeFreelancer:
		m.ResetFreelancer()
		return nil
	}
	return fmt.Errorf("unknown WorkHistory edge %s", name)
}
