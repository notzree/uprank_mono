// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/notzree/uprank-backend/main-backend/ent/attachmentref"
	"github.com/notzree/uprank-backend/main-backend/ent/freelancer"
	"github.com/notzree/uprank-backend/main-backend/ent/job"
	"github.com/notzree/uprank-backend/main-backend/ent/predicate"
	"github.com/notzree/uprank-backend/main-backend/ent/user"
	"github.com/notzree/uprank-backend/main-backend/ent/workhistory"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAttachmentRef = "AttachmentRef"
	TypeFreelancer    = "Freelancer"
	TypeJob           = "Job"
	TypeUser          = "User"
	TypeWorkHistory   = "WorkHistory"
)

// AttachmentRefMutation represents an operation that mutates the AttachmentRef nodes in the graph.
type AttachmentRefMutation struct {
	config
	op                Op
	typ               string
	id                *int
	name              *string
	url               *string
	clearedFields     map[string]struct{}
	freelancer        *uuid.UUID
	clearedfreelancer bool
	done              bool
	oldValue          func(context.Context) (*AttachmentRef, error)
	predicates        []predicate.AttachmentRef
}

var _ ent.Mutation = (*AttachmentRefMutation)(nil)

// attachmentrefOption allows management of the mutation configuration using functional options.
type attachmentrefOption func(*AttachmentRefMutation)

// newAttachmentRefMutation creates new mutation for the AttachmentRef entity.
func newAttachmentRefMutation(c config, op Op, opts ...attachmentrefOption) *AttachmentRefMutation {
	m := &AttachmentRefMutation{
		config:        c,
		op:            op,
		typ:           TypeAttachmentRef,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAttachmentRefID sets the ID field of the mutation.
func withAttachmentRefID(id int) attachmentrefOption {
	return func(m *AttachmentRefMutation) {
		var (
			err   error
			once  sync.Once
			value *AttachmentRef
		)
		m.oldValue = func(ctx context.Context) (*AttachmentRef, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AttachmentRef.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAttachmentRef sets the old AttachmentRef of the mutation.
func withAttachmentRef(node *AttachmentRef) attachmentrefOption {
	return func(m *AttachmentRefMutation) {
		m.oldValue = func(context.Context) (*AttachmentRef, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AttachmentRefMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AttachmentRefMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AttachmentRefMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AttachmentRefMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AttachmentRef.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AttachmentRefMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AttachmentRefMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AttachmentRef entity.
// If the AttachmentRef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentRefMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AttachmentRefMutation) ResetName() {
	m.name = nil
}

// SetURL sets the "url" field.
func (m *AttachmentRefMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *AttachmentRefMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the AttachmentRef entity.
// If the AttachmentRef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttachmentRefMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *AttachmentRefMutation) ResetURL() {
	m.url = nil
}

// SetFreelancerID sets the "freelancer" edge to the Freelancer entity by id.
func (m *AttachmentRefMutation) SetFreelancerID(id uuid.UUID) {
	m.freelancer = &id
}

// ClearFreelancer clears the "freelancer" edge to the Freelancer entity.
func (m *AttachmentRefMutation) ClearFreelancer() {
	m.clearedfreelancer = true
}

// FreelancerCleared reports if the "freelancer" edge to the Freelancer entity was cleared.
func (m *AttachmentRefMutation) FreelancerCleared() bool {
	return m.clearedfreelancer
}

// FreelancerID returns the "freelancer" edge ID in the mutation.
func (m *AttachmentRefMutation) FreelancerID() (id uuid.UUID, exists bool) {
	if m.freelancer != nil {
		return *m.freelancer, true
	}
	return
}

// FreelancerIDs returns the "freelancer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FreelancerID instead. It exists only for internal usage by the builders.
func (m *AttachmentRefMutation) FreelancerIDs() (ids []uuid.UUID) {
	if id := m.freelancer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFreelancer resets all changes to the "freelancer" edge.
func (m *AttachmentRefMutation) ResetFreelancer() {
	m.freelancer = nil
	m.clearedfreelancer = false
}

// Where appends a list predicates to the AttachmentRefMutation builder.
func (m *AttachmentRefMutation) Where(ps ...predicate.AttachmentRef) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AttachmentRefMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AttachmentRefMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AttachmentRef, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AttachmentRefMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AttachmentRefMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AttachmentRef).
func (m *AttachmentRefMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AttachmentRefMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, attachmentref.FieldName)
	}
	if m.url != nil {
		fields = append(fields, attachmentref.FieldURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AttachmentRefMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case attachmentref.FieldName:
		return m.Name()
	case attachmentref.FieldURL:
		return m.URL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AttachmentRefMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case attachmentref.FieldName:
		return m.OldName(ctx)
	case attachmentref.FieldURL:
		return m.OldURL(ctx)
	}
	return nil, fmt.Errorf("unknown AttachmentRef field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttachmentRefMutation) SetField(name string, value ent.Value) error {
	switch name {
	case attachmentref.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case attachmentref.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	}
	return fmt.Errorf("unknown AttachmentRef field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AttachmentRefMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AttachmentRefMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttachmentRefMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AttachmentRef numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AttachmentRefMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AttachmentRefMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AttachmentRefMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AttachmentRef nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AttachmentRefMutation) ResetField(name string) error {
	switch name {
	case attachmentref.FieldName:
		m.ResetName()
		return nil
	case attachmentref.FieldURL:
		m.ResetURL()
		return nil
	}
	return fmt.Errorf("unknown AttachmentRef field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AttachmentRefMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.freelancer != nil {
		edges = append(edges, attachmentref.EdgeFreelancer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AttachmentRefMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case attachmentref.EdgeFreelancer:
		if id := m.freelancer; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AttachmentRefMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AttachmentRefMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AttachmentRefMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedfreelancer {
		edges = append(edges, attachmentref.EdgeFreelancer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AttachmentRefMutation) EdgeCleared(name string) bool {
	switch name {
	case attachmentref.EdgeFreelancer:
		return m.clearedfreelancer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AttachmentRefMutation) ClearEdge(name string) error {
	switch name {
	case attachmentref.EdgeFreelancer:
		m.ClearFreelancer()
		return nil
	}
	return fmt.Errorf("unknown AttachmentRef unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AttachmentRefMutation) ResetEdge(name string) error {
	switch name {
	case attachmentref.EdgeFreelancer:
		m.ResetFreelancer()
		return nil
	}
	return fmt.Errorf("unknown AttachmentRef edge %s", name)
}

// FreelancerMutation represents an operation that mutates the Freelancer nodes in the graph.
type FreelancerMutation struct {
	config
	op                                  Op
	typ                                 string
	id                                  *uuid.UUID
	url                                 *string
	name                                *string
	title                               *string
	description                         *string
	city                                *string
	country                             *string
	timezone                            *string
	cv                                  *string
	ai_reccomended                      *bool
	fixed_charge_amount                 *int
	addfixed_charge_amount              *int
	fixed_charge_currency               *string
	hourly_charge_amount                *int
	addhourly_charge_amount             *int
	hourly_charge_currency              *string
	invited                             *bool
	photo_url                           *string
	recent_hours                        *int
	addrecent_hours                     *int
	total_hours                         *int
	addtotal_hours                      *int
	total_portfolio_items               *int
	addtotal_portfolio_items            *int
	total_portfolio_v2_items            *int
	addtotal_portfolio_v2_items         *int
	upwork_total_feedback               *float64
	addupwork_total_feedback            *float64
	upwork_recent_feedback              *float64
	addupwork_recent_feedback           *float64
	upwork_top_rated_status             *bool
	upwork_top_rated_plus_status        *bool
	upwork_sponsored                    *bool
	upwork_job_success_score            *float64
	addupwork_job_success_score         *float64
	upwork_reccomended                  *bool
	skills                              *[]string
	appendskills                        []string
	average_recent_earnings             *float64
	addaverage_recent_earnings          *float64
	combined_average_recent_earnings    *float64
	addcombined_average_recent_earnings *float64
	combined_recent_earnings            *float64
	addcombined_recent_earnings         *float64
	combined_total_earnings             *float64
	addcombined_total_earnings          *float64
	combined_total_revenue              *float64
	addcombined_total_revenue           *float64
	recent_earnings                     *float64
	addrecent_earnings                  *float64
	total_revenue                       *float64
	addtotal_revenue                    *float64
	uprank_score                        *int
	adduprank_score                     *int
	uprank_updated_at                   *time.Time
	uprank_reccomended                  *bool
	uprank_reccomended_reasons          *string
	uprank_not_enough_data              *bool
	clearedFields                       map[string]struct{}
	job                                 *int
	clearedjob                          bool
	attachments                         map[int]struct{}
	removedattachments                  map[int]struct{}
	clearedattachments                  bool
	work_histories                      map[int]struct{}
	removedwork_histories               map[int]struct{}
	clearedwork_histories               bool
	done                                bool
	oldValue                            func(context.Context) (*Freelancer, error)
	predicates                          []predicate.Freelancer
}

var _ ent.Mutation = (*FreelancerMutation)(nil)

// freelancerOption allows management of the mutation configuration using functional options.
type freelancerOption func(*FreelancerMutation)

// newFreelancerMutation creates new mutation for the Freelancer entity.
func newFreelancerMutation(c config, op Op, opts ...freelancerOption) *FreelancerMutation {
	m := &FreelancerMutation{
		config:        c,
		op:            op,
		typ:           TypeFreelancer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFreelancerID sets the ID field of the mutation.
func withFreelancerID(id uuid.UUID) freelancerOption {
	return func(m *FreelancerMutation) {
		var (
			err   error
			once  sync.Once
			value *Freelancer
		)
		m.oldValue = func(ctx context.Context) (*Freelancer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Freelancer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFreelancer sets the old Freelancer of the mutation.
func withFreelancer(node *Freelancer) freelancerOption {
	return func(m *FreelancerMutation) {
		m.oldValue = func(context.Context) (*Freelancer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FreelancerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FreelancerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Freelancer entities.
func (m *FreelancerMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FreelancerMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FreelancerMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Freelancer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetURL sets the "url" field.
func (m *FreelancerMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *FreelancerMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Freelancer entity.
// If the Freelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FreelancerMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *FreelancerMutation) ResetURL() {
	m.url = nil
}

// SetName sets the "name" field.
func (m *FreelancerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FreelancerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Freelancer entity.
// If the Freelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FreelancerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FreelancerMutation) ResetName() {
	m.name = nil
}

// SetTitle sets the "title" field.
func (m *FreelancerMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *FreelancerMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Freelancer entity.
// If the Freelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FreelancerMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *FreelancerMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *FreelancerMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FreelancerMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Freelancer entity.
// If the Freelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FreelancerMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *FreelancerMutation) ResetDescription() {
	m.description = nil
}

// SetCity sets the "city" field.
func (m *FreelancerMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *FreelancerMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Freelancer entity.
// If the Freelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FreelancerMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *FreelancerMutation) ResetCity() {
	m.city = nil
}

// SetCountry sets the "country" field.
func (m *FreelancerMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *FreelancerMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the Freelancer entity.
// If the Freelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FreelancerMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry resets all changes to the "country" field.
func (m *FreelancerMutation) ResetCountry() {
	m.country = nil
}

// SetTimezone sets the "timezone" field.
func (m *FreelancerMutation) SetTimezone(s string) {
	m.timezone = &s
}

// Timezone returns the value of the "timezone" field in the mutation.
func (m *FreelancerMutation) Timezone() (r string, exists bool) {
	v := m.timezone
	if v == nil {
		return
	}
	return *v, true
}

// OldTimezone returns the old "timezone" field's value of the Freelancer entity.
// If the Freelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FreelancerMutation) OldTimezone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimezone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimezone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimezone: %w", err)
	}
	return oldValue.Timezone, nil
}

// ResetTimezone resets all changes to the "timezone" field.
func (m *FreelancerMutation) ResetTimezone() {
	m.timezone = nil
}

// SetCv sets the "cv" field.
func (m *FreelancerMutation) SetCv(s string) {
	m.cv = &s
}

// Cv returns the value of the "cv" field in the mutation.
func (m *FreelancerMutation) Cv() (r string, exists bool) {
	v := m.cv
	if v == nil {
		return
	}
	return *v, true
}

// OldCv returns the old "cv" field's value of the Freelancer entity.
// If the Freelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FreelancerMutation) OldCv(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCv is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCv requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCv: %w", err)
	}
	return oldValue.Cv, nil
}

// ResetCv resets all changes to the "cv" field.
func (m *FreelancerMutation) ResetCv() {
	m.cv = nil
}

// SetAiReccomended sets the "ai_reccomended" field.
func (m *FreelancerMutation) SetAiReccomended(b bool) {
	m.ai_reccomended = &b
}

// AiReccomended returns the value of the "ai_reccomended" field in the mutation.
func (m *FreelancerMutation) AiReccomended() (r bool, exists bool) {
	v := m.ai_reccomended
	if v == nil {
		return
	}
	return *v, true
}

// OldAiReccomended returns the old "ai_reccomended" field's value of the Freelancer entity.
// If the Freelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FreelancerMutation) OldAiReccomended(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAiReccomended is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAiReccomended requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAiReccomended: %w", err)
	}
	return oldValue.AiReccomended, nil
}

// ResetAiReccomended resets all changes to the "ai_reccomended" field.
func (m *FreelancerMutation) ResetAiReccomended() {
	m.ai_reccomended = nil
}

// SetFixedChargeAmount sets the "fixed_charge_amount" field.
func (m *FreelancerMutation) SetFixedChargeAmount(i int) {
	m.fixed_charge_amount = &i
	m.addfixed_charge_amount = nil
}

// FixedChargeAmount returns the value of the "fixed_charge_amount" field in the mutation.
func (m *FreelancerMutation) FixedChargeAmount() (r int, exists bool) {
	v := m.fixed_charge_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldFixedChargeAmount returns the old "fixed_charge_amount" field's value of the Freelancer entity.
// If the Freelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FreelancerMutation) OldFixedChargeAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFixedChargeAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFixedChargeAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFixedChargeAmount: %w", err)
	}
	return oldValue.FixedChargeAmount, nil
}

// AddFixedChargeAmount adds i to the "fixed_charge_amount" field.
func (m *FreelancerMutation) AddFixedChargeAmount(i int) {
	if m.addfixed_charge_amount != nil {
		*m.addfixed_charge_amount += i
	} else {
		m.addfixed_charge_amount = &i
	}
}

// AddedFixedChargeAmount returns the value that was added to the "fixed_charge_amount" field in this mutation.
func (m *FreelancerMutation) AddedFixedChargeAmount() (r int, exists bool) {
	v := m.addfixed_charge_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearFixedChargeAmount clears the value of the "fixed_charge_amount" field.
func (m *FreelancerMutation) ClearFixedChargeAmount() {
	m.fixed_charge_amount = nil
	m.addfixed_charge_amount = nil
	m.clearedFields[freelancer.FieldFixedChargeAmount] = struct{}{}
}

// FixedChargeAmountCleared returns if the "fixed_charge_amount" field was cleared in this mutation.
func (m *FreelancerMutation) FixedChargeAmountCleared() bool {
	_, ok := m.clearedFields[freelancer.FieldFixedChargeAmount]
	return ok
}

// ResetFixedChargeAmount resets all changes to the "fixed_charge_amount" field.
func (m *FreelancerMutation) ResetFixedChargeAmount() {
	m.fixed_charge_amount = nil
	m.addfixed_charge_amount = nil
	delete(m.clearedFields, freelancer.FieldFixedChargeAmount)
}

// SetFixedChargeCurrency sets the "fixed_charge_currency" field.
func (m *FreelancerMutation) SetFixedChargeCurrency(s string) {
	m.fixed_charge_currency = &s
}

// FixedChargeCurrency returns the value of the "fixed_charge_currency" field in the mutation.
func (m *FreelancerMutation) FixedChargeCurrency() (r string, exists bool) {
	v := m.fixed_charge_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldFixedChargeCurrency returns the old "fixed_charge_currency" field's value of the Freelancer entity.
// If the Freelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FreelancerMutation) OldFixedChargeCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFixedChargeCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFixedChargeCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFixedChargeCurrency: %w", err)
	}
	return oldValue.FixedChargeCurrency, nil
}

// ResetFixedChargeCurrency resets all changes to the "fixed_charge_currency" field.
func (m *FreelancerMutation) ResetFixedChargeCurrency() {
	m.fixed_charge_currency = nil
}

// SetHourlyChargeAmount sets the "hourly_charge_amount" field.
func (m *FreelancerMutation) SetHourlyChargeAmount(i int) {
	m.hourly_charge_amount = &i
	m.addhourly_charge_amount = nil
}

// HourlyChargeAmount returns the value of the "hourly_charge_amount" field in the mutation.
func (m *FreelancerMutation) HourlyChargeAmount() (r int, exists bool) {
	v := m.hourly_charge_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldHourlyChargeAmount returns the old "hourly_charge_amount" field's value of the Freelancer entity.
// If the Freelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FreelancerMutation) OldHourlyChargeAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHourlyChargeAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHourlyChargeAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHourlyChargeAmount: %w", err)
	}
	return oldValue.HourlyChargeAmount, nil
}

// AddHourlyChargeAmount adds i to the "hourly_charge_amount" field.
func (m *FreelancerMutation) AddHourlyChargeAmount(i int) {
	if m.addhourly_charge_amount != nil {
		*m.addhourly_charge_amount += i
	} else {
		m.addhourly_charge_amount = &i
	}
}

// AddedHourlyChargeAmount returns the value that was added to the "hourly_charge_amount" field in this mutation.
func (m *FreelancerMutation) AddedHourlyChargeAmount() (r int, exists bool) {
	v := m.addhourly_charge_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearHourlyChargeAmount clears the value of the "hourly_charge_amount" field.
func (m *FreelancerMutation) ClearHourlyChargeAmount() {
	m.hourly_charge_amount = nil
	m.addhourly_charge_amount = nil
	m.clearedFields[freelancer.FieldHourlyChargeAmount] = struct{}{}
}

// HourlyChargeAmountCleared returns if the "hourly_charge_amount" field was cleared in this mutation.
func (m *FreelancerMutation) HourlyChargeAmountCleared() bool {
	_, ok := m.clearedFields[freelancer.FieldHourlyChargeAmount]
	return ok
}

// ResetHourlyChargeAmount resets all changes to the "hourly_charge_amount" field.
func (m *FreelancerMutation) ResetHourlyChargeAmount() {
	m.hourly_charge_amount = nil
	m.addhourly_charge_amount = nil
	delete(m.clearedFields, freelancer.FieldHourlyChargeAmount)
}

// SetHourlyChargeCurrency sets the "hourly_charge_currency" field.
func (m *FreelancerMutation) SetHourlyChargeCurrency(s string) {
	m.hourly_charge_currency = &s
}

// HourlyChargeCurrency returns the value of the "hourly_charge_currency" field in the mutation.
func (m *FreelancerMutation) HourlyChargeCurrency() (r string, exists bool) {
	v := m.hourly_charge_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldHourlyChargeCurrency returns the old "hourly_charge_currency" field's value of the Freelancer entity.
// If the Freelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FreelancerMutation) OldHourlyChargeCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHourlyChargeCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHourlyChargeCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHourlyChargeCurrency: %w", err)
	}
	return oldValue.HourlyChargeCurrency, nil
}

// ResetHourlyChargeCurrency resets all changes to the "hourly_charge_currency" field.
func (m *FreelancerMutation) ResetHourlyChargeCurrency() {
	m.hourly_charge_currency = nil
}

// SetInvited sets the "invited" field.
func (m *FreelancerMutation) SetInvited(b bool) {
	m.invited = &b
}

// Invited returns the value of the "invited" field in the mutation.
func (m *FreelancerMutation) Invited() (r bool, exists bool) {
	v := m.invited
	if v == nil {
		return
	}
	return *v, true
}

// OldInvited returns the old "invited" field's value of the Freelancer entity.
// If the Freelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FreelancerMutation) OldInvited(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvited is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvited requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvited: %w", err)
	}
	return oldValue.Invited, nil
}

// ResetInvited resets all changes to the "invited" field.
func (m *FreelancerMutation) ResetInvited() {
	m.invited = nil
}

// SetPhotoURL sets the "photo_url" field.
func (m *FreelancerMutation) SetPhotoURL(s string) {
	m.photo_url = &s
}

// PhotoURL returns the value of the "photo_url" field in the mutation.
func (m *FreelancerMutation) PhotoURL() (r string, exists bool) {
	v := m.photo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPhotoURL returns the old "photo_url" field's value of the Freelancer entity.
// If the Freelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FreelancerMutation) OldPhotoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhotoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhotoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhotoURL: %w", err)
	}
	return oldValue.PhotoURL, nil
}

// ResetPhotoURL resets all changes to the "photo_url" field.
func (m *FreelancerMutation) ResetPhotoURL() {
	m.photo_url = nil
}

// SetRecentHours sets the "recent_hours" field.
func (m *FreelancerMutation) SetRecentHours(i int) {
	m.recent_hours = &i
	m.addrecent_hours = nil
}

// RecentHours returns the value of the "recent_hours" field in the mutation.
func (m *FreelancerMutation) RecentHours() (r int, exists bool) {
	v := m.recent_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldRecentHours returns the old "recent_hours" field's value of the Freelancer entity.
// If the Freelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FreelancerMutation) OldRecentHours(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecentHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecentHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecentHours: %w", err)
	}
	return oldValue.RecentHours, nil
}

// AddRecentHours adds i to the "recent_hours" field.
func (m *FreelancerMutation) AddRecentHours(i int) {
	if m.addrecent_hours != nil {
		*m.addrecent_hours += i
	} else {
		m.addrecent_hours = &i
	}
}

// AddedRecentHours returns the value that was added to the "recent_hours" field in this mutation.
func (m *FreelancerMutation) AddedRecentHours() (r int, exists bool) {
	v := m.addrecent_hours
	if v == nil {
		return
	}
	return *v, true
}

// ResetRecentHours resets all changes to the "recent_hours" field.
func (m *FreelancerMutation) ResetRecentHours() {
	m.recent_hours = nil
	m.addrecent_hours = nil
}

// SetTotalHours sets the "total_hours" field.
func (m *FreelancerMutation) SetTotalHours(i int) {
	m.total_hours = &i
	m.addtotal_hours = nil
}

// TotalHours returns the value of the "total_hours" field in the mutation.
func (m *FreelancerMutation) TotalHours() (r int, exists bool) {
	v := m.total_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalHours returns the old "total_hours" field's value of the Freelancer entity.
// If the Freelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FreelancerMutation) OldTotalHours(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalHours: %w", err)
	}
	return oldValue.TotalHours, nil
}

// AddTotalHours adds i to the "total_hours" field.
func (m *FreelancerMutation) AddTotalHours(i int) {
	if m.addtotal_hours != nil {
		*m.addtotal_hours += i
	} else {
		m.addtotal_hours = &i
	}
}

// AddedTotalHours returns the value that was added to the "total_hours" field in this mutation.
func (m *FreelancerMutation) AddedTotalHours() (r int, exists bool) {
	v := m.addtotal_hours
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalHours resets all changes to the "total_hours" field.
func (m *FreelancerMutation) ResetTotalHours() {
	m.total_hours = nil
	m.addtotal_hours = nil
}

// SetTotalPortfolioItems sets the "total_portfolio_items" field.
func (m *FreelancerMutation) SetTotalPortfolioItems(i int) {
	m.total_portfolio_items = &i
	m.addtotal_portfolio_items = nil
}

// TotalPortfolioItems returns the value of the "total_portfolio_items" field in the mutation.
func (m *FreelancerMutation) TotalPortfolioItems() (r int, exists bool) {
	v := m.total_portfolio_items
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalPortfolioItems returns the old "total_portfolio_items" field's value of the Freelancer entity.
// If the Freelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FreelancerMutation) OldTotalPortfolioItems(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalPortfolioItems is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalPortfolioItems requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalPortfolioItems: %w", err)
	}
	return oldValue.TotalPortfolioItems, nil
}

// AddTotalPortfolioItems adds i to the "total_portfolio_items" field.
func (m *FreelancerMutation) AddTotalPortfolioItems(i int) {
	if m.addtotal_portfolio_items != nil {
		*m.addtotal_portfolio_items += i
	} else {
		m.addtotal_portfolio_items = &i
	}
}

// AddedTotalPortfolioItems returns the value that was added to the "total_portfolio_items" field in this mutation.
func (m *FreelancerMutation) AddedTotalPortfolioItems() (r int, exists bool) {
	v := m.addtotal_portfolio_items
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalPortfolioItems resets all changes to the "total_portfolio_items" field.
func (m *FreelancerMutation) ResetTotalPortfolioItems() {
	m.total_portfolio_items = nil
	m.addtotal_portfolio_items = nil
}

// SetTotalPortfolioV2Items sets the "total_portfolio_v2_items" field.
func (m *FreelancerMutation) SetTotalPortfolioV2Items(i int) {
	m.total_portfolio_v2_items = &i
	m.addtotal_portfolio_v2_items = nil
}

// TotalPortfolioV2Items returns the value of the "total_portfolio_v2_items" field in the mutation.
func (m *FreelancerMutation) TotalPortfolioV2Items() (r int, exists bool) {
	v := m.total_portfolio_v2_items
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalPortfolioV2Items returns the old "total_portfolio_v2_items" field's value of the Freelancer entity.
// If the Freelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FreelancerMutation) OldTotalPortfolioV2Items(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalPortfolioV2Items is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalPortfolioV2Items requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalPortfolioV2Items: %w", err)
	}
	return oldValue.TotalPortfolioV2Items, nil
}

// AddTotalPortfolioV2Items adds i to the "total_portfolio_v2_items" field.
func (m *FreelancerMutation) AddTotalPortfolioV2Items(i int) {
	if m.addtotal_portfolio_v2_items != nil {
		*m.addtotal_portfolio_v2_items += i
	} else {
		m.addtotal_portfolio_v2_items = &i
	}
}

// AddedTotalPortfolioV2Items returns the value that was added to the "total_portfolio_v2_items" field in this mutation.
func (m *FreelancerMutation) AddedTotalPortfolioV2Items() (r int, exists bool) {
	v := m.addtotal_portfolio_v2_items
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalPortfolioV2Items resets all changes to the "total_portfolio_v2_items" field.
func (m *FreelancerMutation) ResetTotalPortfolioV2Items() {
	m.total_portfolio_v2_items = nil
	m.addtotal_portfolio_v2_items = nil
}

// SetUpworkTotalFeedback sets the "upwork_total_feedback" field.
func (m *FreelancerMutation) SetUpworkTotalFeedback(f float64) {
	m.upwork_total_feedback = &f
	m.addupwork_total_feedback = nil
}

// UpworkTotalFeedback returns the value of the "upwork_total_feedback" field in the mutation.
func (m *FreelancerMutation) UpworkTotalFeedback() (r float64, exists bool) {
	v := m.upwork_total_feedback
	if v == nil {
		return
	}
	return *v, true
}

// OldUpworkTotalFeedback returns the old "upwork_total_feedback" field's value of the Freelancer entity.
// If the Freelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FreelancerMutation) OldUpworkTotalFeedback(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpworkTotalFeedback is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpworkTotalFeedback requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpworkTotalFeedback: %w", err)
	}
	return oldValue.UpworkTotalFeedback, nil
}

// AddUpworkTotalFeedback adds f to the "upwork_total_feedback" field.
func (m *FreelancerMutation) AddUpworkTotalFeedback(f float64) {
	if m.addupwork_total_feedback != nil {
		*m.addupwork_total_feedback += f
	} else {
		m.addupwork_total_feedback = &f
	}
}

// AddedUpworkTotalFeedback returns the value that was added to the "upwork_total_feedback" field in this mutation.
func (m *FreelancerMutation) AddedUpworkTotalFeedback() (r float64, exists bool) {
	v := m.addupwork_total_feedback
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpworkTotalFeedback resets all changes to the "upwork_total_feedback" field.
func (m *FreelancerMutation) ResetUpworkTotalFeedback() {
	m.upwork_total_feedback = nil
	m.addupwork_total_feedback = nil
}

// SetUpworkRecentFeedback sets the "upwork_recent_feedback" field.
func (m *FreelancerMutation) SetUpworkRecentFeedback(f float64) {
	m.upwork_recent_feedback = &f
	m.addupwork_recent_feedback = nil
}

// UpworkRecentFeedback returns the value of the "upwork_recent_feedback" field in the mutation.
func (m *FreelancerMutation) UpworkRecentFeedback() (r float64, exists bool) {
	v := m.upwork_recent_feedback
	if v == nil {
		return
	}
	return *v, true
}

// OldUpworkRecentFeedback returns the old "upwork_recent_feedback" field's value of the Freelancer entity.
// If the Freelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FreelancerMutation) OldUpworkRecentFeedback(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpworkRecentFeedback is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpworkRecentFeedback requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpworkRecentFeedback: %w", err)
	}
	return oldValue.UpworkRecentFeedback, nil
}

// AddUpworkRecentFeedback adds f to the "upwork_recent_feedback" field.
func (m *FreelancerMutation) AddUpworkRecentFeedback(f float64) {
	if m.addupwork_recent_feedback != nil {
		*m.addupwork_recent_feedback += f
	} else {
		m.addupwork_recent_feedback = &f
	}
}

// AddedUpworkRecentFeedback returns the value that was added to the "upwork_recent_feedback" field in this mutation.
func (m *FreelancerMutation) AddedUpworkRecentFeedback() (r float64, exists bool) {
	v := m.addupwork_recent_feedback
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpworkRecentFeedback resets all changes to the "upwork_recent_feedback" field.
func (m *FreelancerMutation) ResetUpworkRecentFeedback() {
	m.upwork_recent_feedback = nil
	m.addupwork_recent_feedback = nil
}

// SetUpworkTopRatedStatus sets the "upwork_top_rated_status" field.
func (m *FreelancerMutation) SetUpworkTopRatedStatus(b bool) {
	m.upwork_top_rated_status = &b
}

// UpworkTopRatedStatus returns the value of the "upwork_top_rated_status" field in the mutation.
func (m *FreelancerMutation) UpworkTopRatedStatus() (r bool, exists bool) {
	v := m.upwork_top_rated_status
	if v == nil {
		return
	}
	return *v, true
}

// OldUpworkTopRatedStatus returns the old "upwork_top_rated_status" field's value of the Freelancer entity.
// If the Freelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FreelancerMutation) OldUpworkTopRatedStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpworkTopRatedStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpworkTopRatedStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpworkTopRatedStatus: %w", err)
	}
	return oldValue.UpworkTopRatedStatus, nil
}

// ResetUpworkTopRatedStatus resets all changes to the "upwork_top_rated_status" field.
func (m *FreelancerMutation) ResetUpworkTopRatedStatus() {
	m.upwork_top_rated_status = nil
}

// SetUpworkTopRatedPlusStatus sets the "upwork_top_rated_plus_status" field.
func (m *FreelancerMutation) SetUpworkTopRatedPlusStatus(b bool) {
	m.upwork_top_rated_plus_status = &b
}

// UpworkTopRatedPlusStatus returns the value of the "upwork_top_rated_plus_status" field in the mutation.
func (m *FreelancerMutation) UpworkTopRatedPlusStatus() (r bool, exists bool) {
	v := m.upwork_top_rated_plus_status
	if v == nil {
		return
	}
	return *v, true
}

// OldUpworkTopRatedPlusStatus returns the old "upwork_top_rated_plus_status" field's value of the Freelancer entity.
// If the Freelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FreelancerMutation) OldUpworkTopRatedPlusStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpworkTopRatedPlusStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpworkTopRatedPlusStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpworkTopRatedPlusStatus: %w", err)
	}
	return oldValue.UpworkTopRatedPlusStatus, nil
}

// ResetUpworkTopRatedPlusStatus resets all changes to the "upwork_top_rated_plus_status" field.
func (m *FreelancerMutation) ResetUpworkTopRatedPlusStatus() {
	m.upwork_top_rated_plus_status = nil
}

// SetUpworkSponsored sets the "upwork_sponsored" field.
func (m *FreelancerMutation) SetUpworkSponsored(b bool) {
	m.upwork_sponsored = &b
}

// UpworkSponsored returns the value of the "upwork_sponsored" field in the mutation.
func (m *FreelancerMutation) UpworkSponsored() (r bool, exists bool) {
	v := m.upwork_sponsored
	if v == nil {
		return
	}
	return *v, true
}

// OldUpworkSponsored returns the old "upwork_sponsored" field's value of the Freelancer entity.
// If the Freelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FreelancerMutation) OldUpworkSponsored(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpworkSponsored is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpworkSponsored requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpworkSponsored: %w", err)
	}
	return oldValue.UpworkSponsored, nil
}

// ResetUpworkSponsored resets all changes to the "upwork_sponsored" field.
func (m *FreelancerMutation) ResetUpworkSponsored() {
	m.upwork_sponsored = nil
}

// SetUpworkJobSuccessScore sets the "upwork_job_success_score" field.
func (m *FreelancerMutation) SetUpworkJobSuccessScore(f float64) {
	m.upwork_job_success_score = &f
	m.addupwork_job_success_score = nil
}

// UpworkJobSuccessScore returns the value of the "upwork_job_success_score" field in the mutation.
func (m *FreelancerMutation) UpworkJobSuccessScore() (r float64, exists bool) {
	v := m.upwork_job_success_score
	if v == nil {
		return
	}
	return *v, true
}

// OldUpworkJobSuccessScore returns the old "upwork_job_success_score" field's value of the Freelancer entity.
// If the Freelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FreelancerMutation) OldUpworkJobSuccessScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpworkJobSuccessScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpworkJobSuccessScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpworkJobSuccessScore: %w", err)
	}
	return oldValue.UpworkJobSuccessScore, nil
}

// AddUpworkJobSuccessScore adds f to the "upwork_job_success_score" field.
func (m *FreelancerMutation) AddUpworkJobSuccessScore(f float64) {
	if m.addupwork_job_success_score != nil {
		*m.addupwork_job_success_score += f
	} else {
		m.addupwork_job_success_score = &f
	}
}

// AddedUpworkJobSuccessScore returns the value that was added to the "upwork_job_success_score" field in this mutation.
func (m *FreelancerMutation) AddedUpworkJobSuccessScore() (r float64, exists bool) {
	v := m.addupwork_job_success_score
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpworkJobSuccessScore resets all changes to the "upwork_job_success_score" field.
func (m *FreelancerMutation) ResetUpworkJobSuccessScore() {
	m.upwork_job_success_score = nil
	m.addupwork_job_success_score = nil
}

// SetUpworkReccomended sets the "upwork_reccomended" field.
func (m *FreelancerMutation) SetUpworkReccomended(b bool) {
	m.upwork_reccomended = &b
}

// UpworkReccomended returns the value of the "upwork_reccomended" field in the mutation.
func (m *FreelancerMutation) UpworkReccomended() (r bool, exists bool) {
	v := m.upwork_reccomended
	if v == nil {
		return
	}
	return *v, true
}

// OldUpworkReccomended returns the old "upwork_reccomended" field's value of the Freelancer entity.
// If the Freelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FreelancerMutation) OldUpworkReccomended(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpworkReccomended is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpworkReccomended requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpworkReccomended: %w", err)
	}
	return oldValue.UpworkReccomended, nil
}

// ResetUpworkReccomended resets all changes to the "upwork_reccomended" field.
func (m *FreelancerMutation) ResetUpworkReccomended() {
	m.upwork_reccomended = nil
}

// SetSkills sets the "skills" field.
func (m *FreelancerMutation) SetSkills(s []string) {
	m.skills = &s
	m.appendskills = nil
}

// Skills returns the value of the "skills" field in the mutation.
func (m *FreelancerMutation) Skills() (r []string, exists bool) {
	v := m.skills
	if v == nil {
		return
	}
	return *v, true
}

// OldSkills returns the old "skills" field's value of the Freelancer entity.
// If the Freelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FreelancerMutation) OldSkills(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkills is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkills requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkills: %w", err)
	}
	return oldValue.Skills, nil
}

// AppendSkills adds s to the "skills" field.
func (m *FreelancerMutation) AppendSkills(s []string) {
	m.appendskills = append(m.appendskills, s...)
}

// AppendedSkills returns the list of values that were appended to the "skills" field in this mutation.
func (m *FreelancerMutation) AppendedSkills() ([]string, bool) {
	if len(m.appendskills) == 0 {
		return nil, false
	}
	return m.appendskills, true
}

// ResetSkills resets all changes to the "skills" field.
func (m *FreelancerMutation) ResetSkills() {
	m.skills = nil
	m.appendskills = nil
}

// SetAverageRecentEarnings sets the "average_recent_earnings" field.
func (m *FreelancerMutation) SetAverageRecentEarnings(f float64) {
	m.average_recent_earnings = &f
	m.addaverage_recent_earnings = nil
}

// AverageRecentEarnings returns the value of the "average_recent_earnings" field in the mutation.
func (m *FreelancerMutation) AverageRecentEarnings() (r float64, exists bool) {
	v := m.average_recent_earnings
	if v == nil {
		return
	}
	return *v, true
}

// OldAverageRecentEarnings returns the old "average_recent_earnings" field's value of the Freelancer entity.
// If the Freelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FreelancerMutation) OldAverageRecentEarnings(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAverageRecentEarnings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAverageRecentEarnings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAverageRecentEarnings: %w", err)
	}
	return oldValue.AverageRecentEarnings, nil
}

// AddAverageRecentEarnings adds f to the "average_recent_earnings" field.
func (m *FreelancerMutation) AddAverageRecentEarnings(f float64) {
	if m.addaverage_recent_earnings != nil {
		*m.addaverage_recent_earnings += f
	} else {
		m.addaverage_recent_earnings = &f
	}
}

// AddedAverageRecentEarnings returns the value that was added to the "average_recent_earnings" field in this mutation.
func (m *FreelancerMutation) AddedAverageRecentEarnings() (r float64, exists bool) {
	v := m.addaverage_recent_earnings
	if v == nil {
		return
	}
	return *v, true
}

// ResetAverageRecentEarnings resets all changes to the "average_recent_earnings" field.
func (m *FreelancerMutation) ResetAverageRecentEarnings() {
	m.average_recent_earnings = nil
	m.addaverage_recent_earnings = nil
}

// SetCombinedAverageRecentEarnings sets the "combined_average_recent_earnings" field.
func (m *FreelancerMutation) SetCombinedAverageRecentEarnings(f float64) {
	m.combined_average_recent_earnings = &f
	m.addcombined_average_recent_earnings = nil
}

// CombinedAverageRecentEarnings returns the value of the "combined_average_recent_earnings" field in the mutation.
func (m *FreelancerMutation) CombinedAverageRecentEarnings() (r float64, exists bool) {
	v := m.combined_average_recent_earnings
	if v == nil {
		return
	}
	return *v, true
}

// OldCombinedAverageRecentEarnings returns the old "combined_average_recent_earnings" field's value of the Freelancer entity.
// If the Freelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FreelancerMutation) OldCombinedAverageRecentEarnings(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCombinedAverageRecentEarnings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCombinedAverageRecentEarnings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCombinedAverageRecentEarnings: %w", err)
	}
	return oldValue.CombinedAverageRecentEarnings, nil
}

// AddCombinedAverageRecentEarnings adds f to the "combined_average_recent_earnings" field.
func (m *FreelancerMutation) AddCombinedAverageRecentEarnings(f float64) {
	if m.addcombined_average_recent_earnings != nil {
		*m.addcombined_average_recent_earnings += f
	} else {
		m.addcombined_average_recent_earnings = &f
	}
}

// AddedCombinedAverageRecentEarnings returns the value that was added to the "combined_average_recent_earnings" field in this mutation.
func (m *FreelancerMutation) AddedCombinedAverageRecentEarnings() (r float64, exists bool) {
	v := m.addcombined_average_recent_earnings
	if v == nil {
		return
	}
	return *v, true
}

// ResetCombinedAverageRecentEarnings resets all changes to the "combined_average_recent_earnings" field.
func (m *FreelancerMutation) ResetCombinedAverageRecentEarnings() {
	m.combined_average_recent_earnings = nil
	m.addcombined_average_recent_earnings = nil
}

// SetCombinedRecentEarnings sets the "combined_recent_earnings" field.
func (m *FreelancerMutation) SetCombinedRecentEarnings(f float64) {
	m.combined_recent_earnings = &f
	m.addcombined_recent_earnings = nil
}

// CombinedRecentEarnings returns the value of the "combined_recent_earnings" field in the mutation.
func (m *FreelancerMutation) CombinedRecentEarnings() (r float64, exists bool) {
	v := m.combined_recent_earnings
	if v == nil {
		return
	}
	return *v, true
}

// OldCombinedRecentEarnings returns the old "combined_recent_earnings" field's value of the Freelancer entity.
// If the Freelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FreelancerMutation) OldCombinedRecentEarnings(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCombinedRecentEarnings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCombinedRecentEarnings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCombinedRecentEarnings: %w", err)
	}
	return oldValue.CombinedRecentEarnings, nil
}

// AddCombinedRecentEarnings adds f to the "combined_recent_earnings" field.
func (m *FreelancerMutation) AddCombinedRecentEarnings(f float64) {
	if m.addcombined_recent_earnings != nil {
		*m.addcombined_recent_earnings += f
	} else {
		m.addcombined_recent_earnings = &f
	}
}

// AddedCombinedRecentEarnings returns the value that was added to the "combined_recent_earnings" field in this mutation.
func (m *FreelancerMutation) AddedCombinedRecentEarnings() (r float64, exists bool) {
	v := m.addcombined_recent_earnings
	if v == nil {
		return
	}
	return *v, true
}

// ResetCombinedRecentEarnings resets all changes to the "combined_recent_earnings" field.
func (m *FreelancerMutation) ResetCombinedRecentEarnings() {
	m.combined_recent_earnings = nil
	m.addcombined_recent_earnings = nil
}

// SetCombinedTotalEarnings sets the "combined_total_earnings" field.
func (m *FreelancerMutation) SetCombinedTotalEarnings(f float64) {
	m.combined_total_earnings = &f
	m.addcombined_total_earnings = nil
}

// CombinedTotalEarnings returns the value of the "combined_total_earnings" field in the mutation.
func (m *FreelancerMutation) CombinedTotalEarnings() (r float64, exists bool) {
	v := m.combined_total_earnings
	if v == nil {
		return
	}
	return *v, true
}

// OldCombinedTotalEarnings returns the old "combined_total_earnings" field's value of the Freelancer entity.
// If the Freelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FreelancerMutation) OldCombinedTotalEarnings(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCombinedTotalEarnings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCombinedTotalEarnings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCombinedTotalEarnings: %w", err)
	}
	return oldValue.CombinedTotalEarnings, nil
}

// AddCombinedTotalEarnings adds f to the "combined_total_earnings" field.
func (m *FreelancerMutation) AddCombinedTotalEarnings(f float64) {
	if m.addcombined_total_earnings != nil {
		*m.addcombined_total_earnings += f
	} else {
		m.addcombined_total_earnings = &f
	}
}

// AddedCombinedTotalEarnings returns the value that was added to the "combined_total_earnings" field in this mutation.
func (m *FreelancerMutation) AddedCombinedTotalEarnings() (r float64, exists bool) {
	v := m.addcombined_total_earnings
	if v == nil {
		return
	}
	return *v, true
}

// ResetCombinedTotalEarnings resets all changes to the "combined_total_earnings" field.
func (m *FreelancerMutation) ResetCombinedTotalEarnings() {
	m.combined_total_earnings = nil
	m.addcombined_total_earnings = nil
}

// SetCombinedTotalRevenue sets the "combined_total_revenue" field.
func (m *FreelancerMutation) SetCombinedTotalRevenue(f float64) {
	m.combined_total_revenue = &f
	m.addcombined_total_revenue = nil
}

// CombinedTotalRevenue returns the value of the "combined_total_revenue" field in the mutation.
func (m *FreelancerMutation) CombinedTotalRevenue() (r float64, exists bool) {
	v := m.combined_total_revenue
	if v == nil {
		return
	}
	return *v, true
}

// OldCombinedTotalRevenue returns the old "combined_total_revenue" field's value of the Freelancer entity.
// If the Freelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FreelancerMutation) OldCombinedTotalRevenue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCombinedTotalRevenue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCombinedTotalRevenue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCombinedTotalRevenue: %w", err)
	}
	return oldValue.CombinedTotalRevenue, nil
}

// AddCombinedTotalRevenue adds f to the "combined_total_revenue" field.
func (m *FreelancerMutation) AddCombinedTotalRevenue(f float64) {
	if m.addcombined_total_revenue != nil {
		*m.addcombined_total_revenue += f
	} else {
		m.addcombined_total_revenue = &f
	}
}

// AddedCombinedTotalRevenue returns the value that was added to the "combined_total_revenue" field in this mutation.
func (m *FreelancerMutation) AddedCombinedTotalRevenue() (r float64, exists bool) {
	v := m.addcombined_total_revenue
	if v == nil {
		return
	}
	return *v, true
}

// ResetCombinedTotalRevenue resets all changes to the "combined_total_revenue" field.
func (m *FreelancerMutation) ResetCombinedTotalRevenue() {
	m.combined_total_revenue = nil
	m.addcombined_total_revenue = nil
}

// SetRecentEarnings sets the "recent_earnings" field.
func (m *FreelancerMutation) SetRecentEarnings(f float64) {
	m.recent_earnings = &f
	m.addrecent_earnings = nil
}

// RecentEarnings returns the value of the "recent_earnings" field in the mutation.
func (m *FreelancerMutation) RecentEarnings() (r float64, exists bool) {
	v := m.recent_earnings
	if v == nil {
		return
	}
	return *v, true
}

// OldRecentEarnings returns the old "recent_earnings" field's value of the Freelancer entity.
// If the Freelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FreelancerMutation) OldRecentEarnings(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecentEarnings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecentEarnings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecentEarnings: %w", err)
	}
	return oldValue.RecentEarnings, nil
}

// AddRecentEarnings adds f to the "recent_earnings" field.
func (m *FreelancerMutation) AddRecentEarnings(f float64) {
	if m.addrecent_earnings != nil {
		*m.addrecent_earnings += f
	} else {
		m.addrecent_earnings = &f
	}
}

// AddedRecentEarnings returns the value that was added to the "recent_earnings" field in this mutation.
func (m *FreelancerMutation) AddedRecentEarnings() (r float64, exists bool) {
	v := m.addrecent_earnings
	if v == nil {
		return
	}
	return *v, true
}

// ResetRecentEarnings resets all changes to the "recent_earnings" field.
func (m *FreelancerMutation) ResetRecentEarnings() {
	m.recent_earnings = nil
	m.addrecent_earnings = nil
}

// SetTotalRevenue sets the "total_revenue" field.
func (m *FreelancerMutation) SetTotalRevenue(f float64) {
	m.total_revenue = &f
	m.addtotal_revenue = nil
}

// TotalRevenue returns the value of the "total_revenue" field in the mutation.
func (m *FreelancerMutation) TotalRevenue() (r float64, exists bool) {
	v := m.total_revenue
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalRevenue returns the old "total_revenue" field's value of the Freelancer entity.
// If the Freelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FreelancerMutation) OldTotalRevenue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalRevenue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalRevenue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalRevenue: %w", err)
	}
	return oldValue.TotalRevenue, nil
}

// AddTotalRevenue adds f to the "total_revenue" field.
func (m *FreelancerMutation) AddTotalRevenue(f float64) {
	if m.addtotal_revenue != nil {
		*m.addtotal_revenue += f
	} else {
		m.addtotal_revenue = &f
	}
}

// AddedTotalRevenue returns the value that was added to the "total_revenue" field in this mutation.
func (m *FreelancerMutation) AddedTotalRevenue() (r float64, exists bool) {
	v := m.addtotal_revenue
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalRevenue resets all changes to the "total_revenue" field.
func (m *FreelancerMutation) ResetTotalRevenue() {
	m.total_revenue = nil
	m.addtotal_revenue = nil
}

// SetUprankScore sets the "uprank_score" field.
func (m *FreelancerMutation) SetUprankScore(i int) {
	m.uprank_score = &i
	m.adduprank_score = nil
}

// UprankScore returns the value of the "uprank_score" field in the mutation.
func (m *FreelancerMutation) UprankScore() (r int, exists bool) {
	v := m.uprank_score
	if v == nil {
		return
	}
	return *v, true
}

// OldUprankScore returns the old "uprank_score" field's value of the Freelancer entity.
// If the Freelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FreelancerMutation) OldUprankScore(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUprankScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUprankScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUprankScore: %w", err)
	}
	return oldValue.UprankScore, nil
}

// AddUprankScore adds i to the "uprank_score" field.
func (m *FreelancerMutation) AddUprankScore(i int) {
	if m.adduprank_score != nil {
		*m.adduprank_score += i
	} else {
		m.adduprank_score = &i
	}
}

// AddedUprankScore returns the value that was added to the "uprank_score" field in this mutation.
func (m *FreelancerMutation) AddedUprankScore() (r int, exists bool) {
	v := m.adduprank_score
	if v == nil {
		return
	}
	return *v, true
}

// ClearUprankScore clears the value of the "uprank_score" field.
func (m *FreelancerMutation) ClearUprankScore() {
	m.uprank_score = nil
	m.adduprank_score = nil
	m.clearedFields[freelancer.FieldUprankScore] = struct{}{}
}

// UprankScoreCleared returns if the "uprank_score" field was cleared in this mutation.
func (m *FreelancerMutation) UprankScoreCleared() bool {
	_, ok := m.clearedFields[freelancer.FieldUprankScore]
	return ok
}

// ResetUprankScore resets all changes to the "uprank_score" field.
func (m *FreelancerMutation) ResetUprankScore() {
	m.uprank_score = nil
	m.adduprank_score = nil
	delete(m.clearedFields, freelancer.FieldUprankScore)
}

// SetUprankUpdatedAt sets the "uprank_updated_at" field.
func (m *FreelancerMutation) SetUprankUpdatedAt(t time.Time) {
	m.uprank_updated_at = &t
}

// UprankUpdatedAt returns the value of the "uprank_updated_at" field in the mutation.
func (m *FreelancerMutation) UprankUpdatedAt() (r time.Time, exists bool) {
	v := m.uprank_updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUprankUpdatedAt returns the old "uprank_updated_at" field's value of the Freelancer entity.
// If the Freelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FreelancerMutation) OldUprankUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUprankUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUprankUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUprankUpdatedAt: %w", err)
	}
	return oldValue.UprankUpdatedAt, nil
}

// ResetUprankUpdatedAt resets all changes to the "uprank_updated_at" field.
func (m *FreelancerMutation) ResetUprankUpdatedAt() {
	m.uprank_updated_at = nil
}

// SetUprankReccomended sets the "uprank_reccomended" field.
func (m *FreelancerMutation) SetUprankReccomended(b bool) {
	m.uprank_reccomended = &b
}

// UprankReccomended returns the value of the "uprank_reccomended" field in the mutation.
func (m *FreelancerMutation) UprankReccomended() (r bool, exists bool) {
	v := m.uprank_reccomended
	if v == nil {
		return
	}
	return *v, true
}

// OldUprankReccomended returns the old "uprank_reccomended" field's value of the Freelancer entity.
// If the Freelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FreelancerMutation) OldUprankReccomended(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUprankReccomended is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUprankReccomended requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUprankReccomended: %w", err)
	}
	return oldValue.UprankReccomended, nil
}

// ClearUprankReccomended clears the value of the "uprank_reccomended" field.
func (m *FreelancerMutation) ClearUprankReccomended() {
	m.uprank_reccomended = nil
	m.clearedFields[freelancer.FieldUprankReccomended] = struct{}{}
}

// UprankReccomendedCleared returns if the "uprank_reccomended" field was cleared in this mutation.
func (m *FreelancerMutation) UprankReccomendedCleared() bool {
	_, ok := m.clearedFields[freelancer.FieldUprankReccomended]
	return ok
}

// ResetUprankReccomended resets all changes to the "uprank_reccomended" field.
func (m *FreelancerMutation) ResetUprankReccomended() {
	m.uprank_reccomended = nil
	delete(m.clearedFields, freelancer.FieldUprankReccomended)
}

// SetUprankReccomendedReasons sets the "uprank_reccomended_reasons" field.
func (m *FreelancerMutation) SetUprankReccomendedReasons(s string) {
	m.uprank_reccomended_reasons = &s
}

// UprankReccomendedReasons returns the value of the "uprank_reccomended_reasons" field in the mutation.
func (m *FreelancerMutation) UprankReccomendedReasons() (r string, exists bool) {
	v := m.uprank_reccomended_reasons
	if v == nil {
		return
	}
	return *v, true
}

// OldUprankReccomendedReasons returns the old "uprank_reccomended_reasons" field's value of the Freelancer entity.
// If the Freelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FreelancerMutation) OldUprankReccomendedReasons(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUprankReccomendedReasons is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUprankReccomendedReasons requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUprankReccomendedReasons: %w", err)
	}
	return oldValue.UprankReccomendedReasons, nil
}

// ClearUprankReccomendedReasons clears the value of the "uprank_reccomended_reasons" field.
func (m *FreelancerMutation) ClearUprankReccomendedReasons() {
	m.uprank_reccomended_reasons = nil
	m.clearedFields[freelancer.FieldUprankReccomendedReasons] = struct{}{}
}

// UprankReccomendedReasonsCleared returns if the "uprank_reccomended_reasons" field was cleared in this mutation.
func (m *FreelancerMutation) UprankReccomendedReasonsCleared() bool {
	_, ok := m.clearedFields[freelancer.FieldUprankReccomendedReasons]
	return ok
}

// ResetUprankReccomendedReasons resets all changes to the "uprank_reccomended_reasons" field.
func (m *FreelancerMutation) ResetUprankReccomendedReasons() {
	m.uprank_reccomended_reasons = nil
	delete(m.clearedFields, freelancer.FieldUprankReccomendedReasons)
}

// SetUprankNotEnoughData sets the "uprank_not_enough_data" field.
func (m *FreelancerMutation) SetUprankNotEnoughData(b bool) {
	m.uprank_not_enough_data = &b
}

// UprankNotEnoughData returns the value of the "uprank_not_enough_data" field in the mutation.
func (m *FreelancerMutation) UprankNotEnoughData() (r bool, exists bool) {
	v := m.uprank_not_enough_data
	if v == nil {
		return
	}
	return *v, true
}

// OldUprankNotEnoughData returns the old "uprank_not_enough_data" field's value of the Freelancer entity.
// If the Freelancer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FreelancerMutation) OldUprankNotEnoughData(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUprankNotEnoughData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUprankNotEnoughData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUprankNotEnoughData: %w", err)
	}
	return oldValue.UprankNotEnoughData, nil
}

// ClearUprankNotEnoughData clears the value of the "uprank_not_enough_data" field.
func (m *FreelancerMutation) ClearUprankNotEnoughData() {
	m.uprank_not_enough_data = nil
	m.clearedFields[freelancer.FieldUprankNotEnoughData] = struct{}{}
}

// UprankNotEnoughDataCleared returns if the "uprank_not_enough_data" field was cleared in this mutation.
func (m *FreelancerMutation) UprankNotEnoughDataCleared() bool {
	_, ok := m.clearedFields[freelancer.FieldUprankNotEnoughData]
	return ok
}

// ResetUprankNotEnoughData resets all changes to the "uprank_not_enough_data" field.
func (m *FreelancerMutation) ResetUprankNotEnoughData() {
	m.uprank_not_enough_data = nil
	delete(m.clearedFields, freelancer.FieldUprankNotEnoughData)
}

// SetJobID sets the "job" edge to the Job entity by id.
func (m *FreelancerMutation) SetJobID(id int) {
	m.job = &id
}

// ClearJob clears the "job" edge to the Job entity.
func (m *FreelancerMutation) ClearJob() {
	m.clearedjob = true
}

// JobCleared reports if the "job" edge to the Job entity was cleared.
func (m *FreelancerMutation) JobCleared() bool {
	return m.clearedjob
}

// JobID returns the "job" edge ID in the mutation.
func (m *FreelancerMutation) JobID() (id int, exists bool) {
	if m.job != nil {
		return *m.job, true
	}
	return
}

// JobIDs returns the "job" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// JobID instead. It exists only for internal usage by the builders.
func (m *FreelancerMutation) JobIDs() (ids []int) {
	if id := m.job; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJob resets all changes to the "job" edge.
func (m *FreelancerMutation) ResetJob() {
	m.job = nil
	m.clearedjob = false
}

// AddAttachmentIDs adds the "attachments" edge to the AttachmentRef entity by ids.
func (m *FreelancerMutation) AddAttachmentIDs(ids ...int) {
	if m.attachments == nil {
		m.attachments = make(map[int]struct{})
	}
	for i := range ids {
		m.attachments[ids[i]] = struct{}{}
	}
}

// ClearAttachments clears the "attachments" edge to the AttachmentRef entity.
func (m *FreelancerMutation) ClearAttachments() {
	m.clearedattachments = true
}

// AttachmentsCleared reports if the "attachments" edge to the AttachmentRef entity was cleared.
func (m *FreelancerMutation) AttachmentsCleared() bool {
	return m.clearedattachments
}

// RemoveAttachmentIDs removes the "attachments" edge to the AttachmentRef entity by IDs.
func (m *FreelancerMutation) RemoveAttachmentIDs(ids ...int) {
	if m.removedattachments == nil {
		m.removedattachments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.attachments, ids[i])
		m.removedattachments[ids[i]] = struct{}{}
	}
}

// RemovedAttachments returns the removed IDs of the "attachments" edge to the AttachmentRef entity.
func (m *FreelancerMutation) RemovedAttachmentsIDs() (ids []int) {
	for id := range m.removedattachments {
		ids = append(ids, id)
	}
	return
}

// AttachmentsIDs returns the "attachments" edge IDs in the mutation.
func (m *FreelancerMutation) AttachmentsIDs() (ids []int) {
	for id := range m.attachments {
		ids = append(ids, id)
	}
	return
}

// ResetAttachments resets all changes to the "attachments" edge.
func (m *FreelancerMutation) ResetAttachments() {
	m.attachments = nil
	m.clearedattachments = false
	m.removedattachments = nil
}

// AddWorkHistoryIDs adds the "work_histories" edge to the WorkHistory entity by ids.
func (m *FreelancerMutation) AddWorkHistoryIDs(ids ...int) {
	if m.work_histories == nil {
		m.work_histories = make(map[int]struct{})
	}
	for i := range ids {
		m.work_histories[ids[i]] = struct{}{}
	}
}

// ClearWorkHistories clears the "work_histories" edge to the WorkHistory entity.
func (m *FreelancerMutation) ClearWorkHistories() {
	m.clearedwork_histories = true
}

// WorkHistoriesCleared reports if the "work_histories" edge to the WorkHistory entity was cleared.
func (m *FreelancerMutation) WorkHistoriesCleared() bool {
	return m.clearedwork_histories
}

// RemoveWorkHistoryIDs removes the "work_histories" edge to the WorkHistory entity by IDs.
func (m *FreelancerMutation) RemoveWorkHistoryIDs(ids ...int) {
	if m.removedwork_histories == nil {
		m.removedwork_histories = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.work_histories, ids[i])
		m.removedwork_histories[ids[i]] = struct{}{}
	}
}

// RemovedWorkHistories returns the removed IDs of the "work_histories" edge to the WorkHistory entity.
func (m *FreelancerMutation) RemovedWorkHistoriesIDs() (ids []int) {
	for id := range m.removedwork_histories {
		ids = append(ids, id)
	}
	return
}

// WorkHistoriesIDs returns the "work_histories" edge IDs in the mutation.
func (m *FreelancerMutation) WorkHistoriesIDs() (ids []int) {
	for id := range m.work_histories {
		ids = append(ids, id)
	}
	return
}

// ResetWorkHistories resets all changes to the "work_histories" edge.
func (m *FreelancerMutation) ResetWorkHistories() {
	m.work_histories = nil
	m.clearedwork_histories = false
	m.removedwork_histories = nil
}

// Where appends a list predicates to the FreelancerMutation builder.
func (m *FreelancerMutation) Where(ps ...predicate.Freelancer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FreelancerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FreelancerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Freelancer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FreelancerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FreelancerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Freelancer).
func (m *FreelancerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FreelancerMutation) Fields() []string {
	fields := make([]string, 0, 39)
	if m.url != nil {
		fields = append(fields, freelancer.FieldURL)
	}
	if m.name != nil {
		fields = append(fields, freelancer.FieldName)
	}
	if m.title != nil {
		fields = append(fields, freelancer.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, freelancer.FieldDescription)
	}
	if m.city != nil {
		fields = append(fields, freelancer.FieldCity)
	}
	if m.country != nil {
		fields = append(fields, freelancer.FieldCountry)
	}
	if m.timezone != nil {
		fields = append(fields, freelancer.FieldTimezone)
	}
	if m.cv != nil {
		fields = append(fields, freelancer.FieldCv)
	}
	if m.ai_reccomended != nil {
		fields = append(fields, freelancer.FieldAiReccomended)
	}
	if m.fixed_charge_amount != nil {
		fields = append(fields, freelancer.FieldFixedChargeAmount)
	}
	if m.fixed_charge_currency != nil {
		fields = append(fields, freelancer.FieldFixedChargeCurrency)
	}
	if m.hourly_charge_amount != nil {
		fields = append(fields, freelancer.FieldHourlyChargeAmount)
	}
	if m.hourly_charge_currency != nil {
		fields = append(fields, freelancer.FieldHourlyChargeCurrency)
	}
	if m.invited != nil {
		fields = append(fields, freelancer.FieldInvited)
	}
	if m.photo_url != nil {
		fields = append(fields, freelancer.FieldPhotoURL)
	}
	if m.recent_hours != nil {
		fields = append(fields, freelancer.FieldRecentHours)
	}
	if m.total_hours != nil {
		fields = append(fields, freelancer.FieldTotalHours)
	}
	if m.total_portfolio_items != nil {
		fields = append(fields, freelancer.FieldTotalPortfolioItems)
	}
	if m.total_portfolio_v2_items != nil {
		fields = append(fields, freelancer.FieldTotalPortfolioV2Items)
	}
	if m.upwork_total_feedback != nil {
		fields = append(fields, freelancer.FieldUpworkTotalFeedback)
	}
	if m.upwork_recent_feedback != nil {
		fields = append(fields, freelancer.FieldUpworkRecentFeedback)
	}
	if m.upwork_top_rated_status != nil {
		fields = append(fields, freelancer.FieldUpworkTopRatedStatus)
	}
	if m.upwork_top_rated_plus_status != nil {
		fields = append(fields, freelancer.FieldUpworkTopRatedPlusStatus)
	}
	if m.upwork_sponsored != nil {
		fields = append(fields, freelancer.FieldUpworkSponsored)
	}
	if m.upwork_job_success_score != nil {
		fields = append(fields, freelancer.FieldUpworkJobSuccessScore)
	}
	if m.upwork_reccomended != nil {
		fields = append(fields, freelancer.FieldUpworkReccomended)
	}
	if m.skills != nil {
		fields = append(fields, freelancer.FieldSkills)
	}
	if m.average_recent_earnings != nil {
		fields = append(fields, freelancer.FieldAverageRecentEarnings)
	}
	if m.combined_average_recent_earnings != nil {
		fields = append(fields, freelancer.FieldCombinedAverageRecentEarnings)
	}
	if m.combined_recent_earnings != nil {
		fields = append(fields, freelancer.FieldCombinedRecentEarnings)
	}
	if m.combined_total_earnings != nil {
		fields = append(fields, freelancer.FieldCombinedTotalEarnings)
	}
	if m.combined_total_revenue != nil {
		fields = append(fields, freelancer.FieldCombinedTotalRevenue)
	}
	if m.recent_earnings != nil {
		fields = append(fields, freelancer.FieldRecentEarnings)
	}
	if m.total_revenue != nil {
		fields = append(fields, freelancer.FieldTotalRevenue)
	}
	if m.uprank_score != nil {
		fields = append(fields, freelancer.FieldUprankScore)
	}
	if m.uprank_updated_at != nil {
		fields = append(fields, freelancer.FieldUprankUpdatedAt)
	}
	if m.uprank_reccomended != nil {
		fields = append(fields, freelancer.FieldUprankReccomended)
	}
	if m.uprank_reccomended_reasons != nil {
		fields = append(fields, freelancer.FieldUprankReccomendedReasons)
	}
	if m.uprank_not_enough_data != nil {
		fields = append(fields, freelancer.FieldUprankNotEnoughData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FreelancerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case freelancer.FieldURL:
		return m.URL()
	case freelancer.FieldName:
		return m.Name()
	case freelancer.FieldTitle:
		return m.Title()
	case freelancer.FieldDescription:
		return m.Description()
	case freelancer.FieldCity:
		return m.City()
	case freelancer.FieldCountry:
		return m.Country()
	case freelancer.FieldTimezone:
		return m.Timezone()
	case freelancer.FieldCv:
		return m.Cv()
	case freelancer.FieldAiReccomended:
		return m.AiReccomended()
	case freelancer.FieldFixedChargeAmount:
		return m.FixedChargeAmount()
	case freelancer.FieldFixedChargeCurrency:
		return m.FixedChargeCurrency()
	case freelancer.FieldHourlyChargeAmount:
		return m.HourlyChargeAmount()
	case freelancer.FieldHourlyChargeCurrency:
		return m.HourlyChargeCurrency()
	case freelancer.FieldInvited:
		return m.Invited()
	case freelancer.FieldPhotoURL:
		return m.PhotoURL()
	case freelancer.FieldRecentHours:
		return m.RecentHours()
	case freelancer.FieldTotalHours:
		return m.TotalHours()
	case freelancer.FieldTotalPortfolioItems:
		return m.TotalPortfolioItems()
	case freelancer.FieldTotalPortfolioV2Items:
		return m.TotalPortfolioV2Items()
	case freelancer.FieldUpworkTotalFeedback:
		return m.UpworkTotalFeedback()
	case freelancer.FieldUpworkRecentFeedback:
		return m.UpworkRecentFeedback()
	case freelancer.FieldUpworkTopRatedStatus:
		return m.UpworkTopRatedStatus()
	case freelancer.FieldUpworkTopRatedPlusStatus:
		return m.UpworkTopRatedPlusStatus()
	case freelancer.FieldUpworkSponsored:
		return m.UpworkSponsored()
	case freelancer.FieldUpworkJobSuccessScore:
		return m.UpworkJobSuccessScore()
	case freelancer.FieldUpworkReccomended:
		return m.UpworkReccomended()
	case freelancer.FieldSkills:
		return m.Skills()
	case freelancer.FieldAverageRecentEarnings:
		return m.AverageRecentEarnings()
	case freelancer.FieldCombinedAverageRecentEarnings:
		return m.CombinedAverageRecentEarnings()
	case freelancer.FieldCombinedRecentEarnings:
		return m.CombinedRecentEarnings()
	case freelancer.FieldCombinedTotalEarnings:
		return m.CombinedTotalEarnings()
	case freelancer.FieldCombinedTotalRevenue:
		return m.CombinedTotalRevenue()
	case freelancer.FieldRecentEarnings:
		return m.RecentEarnings()
	case freelancer.FieldTotalRevenue:
		return m.TotalRevenue()
	case freelancer.FieldUprankScore:
		return m.UprankScore()
	case freelancer.FieldUprankUpdatedAt:
		return m.UprankUpdatedAt()
	case freelancer.FieldUprankReccomended:
		return m.UprankReccomended()
	case freelancer.FieldUprankReccomendedReasons:
		return m.UprankReccomendedReasons()
	case freelancer.FieldUprankNotEnoughData:
		return m.UprankNotEnoughData()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FreelancerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case freelancer.FieldURL:
		return m.OldURL(ctx)
	case freelancer.FieldName:
		return m.OldName(ctx)
	case freelancer.FieldTitle:
		return m.OldTitle(ctx)
	case freelancer.FieldDescription:
		return m.OldDescription(ctx)
	case freelancer.FieldCity:
		return m.OldCity(ctx)
	case freelancer.FieldCountry:
		return m.OldCountry(ctx)
	case freelancer.FieldTimezone:
		return m.OldTimezone(ctx)
	case freelancer.FieldCv:
		return m.OldCv(ctx)
	case freelancer.FieldAiReccomended:
		return m.OldAiReccomended(ctx)
	case freelancer.FieldFixedChargeAmount:
		return m.OldFixedChargeAmount(ctx)
	case freelancer.FieldFixedChargeCurrency:
		return m.OldFixedChargeCurrency(ctx)
	case freelancer.FieldHourlyChargeAmount:
		return m.OldHourlyChargeAmount(ctx)
	case freelancer.FieldHourlyChargeCurrency:
		return m.OldHourlyChargeCurrency(ctx)
	case freelancer.FieldInvited:
		return m.OldInvited(ctx)
	case freelancer.FieldPhotoURL:
		return m.OldPhotoURL(ctx)
	case freelancer.FieldRecentHours:
		return m.OldRecentHours(ctx)
	case freelancer.FieldTotalHours:
		return m.OldTotalHours(ctx)
	case freelancer.FieldTotalPortfolioItems:
		return m.OldTotalPortfolioItems(ctx)
	case freelancer.FieldTotalPortfolioV2Items:
		return m.OldTotalPortfolioV2Items(ctx)
	case freelancer.FieldUpworkTotalFeedback:
		return m.OldUpworkTotalFeedback(ctx)
	case freelancer.FieldUpworkRecentFeedback:
		return m.OldUpworkRecentFeedback(ctx)
	case freelancer.FieldUpworkTopRatedStatus:
		return m.OldUpworkTopRatedStatus(ctx)
	case freelancer.FieldUpworkTopRatedPlusStatus:
		return m.OldUpworkTopRatedPlusStatus(ctx)
	case freelancer.FieldUpworkSponsored:
		return m.OldUpworkSponsored(ctx)
	case freelancer.FieldUpworkJobSuccessScore:
		return m.OldUpworkJobSuccessScore(ctx)
	case freelancer.FieldUpworkReccomended:
		return m.OldUpworkReccomended(ctx)
	case freelancer.FieldSkills:
		return m.OldSkills(ctx)
	case freelancer.FieldAverageRecentEarnings:
		return m.OldAverageRecentEarnings(ctx)
	case freelancer.FieldCombinedAverageRecentEarnings:
		return m.OldCombinedAverageRecentEarnings(ctx)
	case freelancer.FieldCombinedRecentEarnings:
		return m.OldCombinedRecentEarnings(ctx)
	case freelancer.FieldCombinedTotalEarnings:
		return m.OldCombinedTotalEarnings(ctx)
	case freelancer.FieldCombinedTotalRevenue:
		return m.OldCombinedTotalRevenue(ctx)
	case freelancer.FieldRecentEarnings:
		return m.OldRecentEarnings(ctx)
	case freelancer.FieldTotalRevenue:
		return m.OldTotalRevenue(ctx)
	case freelancer.FieldUprankScore:
		return m.OldUprankScore(ctx)
	case freelancer.FieldUprankUpdatedAt:
		return m.OldUprankUpdatedAt(ctx)
	case freelancer.FieldUprankReccomended:
		return m.OldUprankReccomended(ctx)
	case freelancer.FieldUprankReccomendedReasons:
		return m.OldUprankReccomendedReasons(ctx)
	case freelancer.FieldUprankNotEnoughData:
		return m.OldUprankNotEnoughData(ctx)
	}
	return nil, fmt.Errorf("unknown Freelancer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FreelancerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case freelancer.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case freelancer.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case freelancer.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case freelancer.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case freelancer.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case freelancer.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case freelancer.FieldTimezone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimezone(v)
		return nil
	case freelancer.FieldCv:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCv(v)
		return nil
	case freelancer.FieldAiReccomended:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAiReccomended(v)
		return nil
	case freelancer.FieldFixedChargeAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFixedChargeAmount(v)
		return nil
	case freelancer.FieldFixedChargeCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFixedChargeCurrency(v)
		return nil
	case freelancer.FieldHourlyChargeAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHourlyChargeAmount(v)
		return nil
	case freelancer.FieldHourlyChargeCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHourlyChargeCurrency(v)
		return nil
	case freelancer.FieldInvited:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvited(v)
		return nil
	case freelancer.FieldPhotoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhotoURL(v)
		return nil
	case freelancer.FieldRecentHours:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecentHours(v)
		return nil
	case freelancer.FieldTotalHours:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalHours(v)
		return nil
	case freelancer.FieldTotalPortfolioItems:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalPortfolioItems(v)
		return nil
	case freelancer.FieldTotalPortfolioV2Items:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalPortfolioV2Items(v)
		return nil
	case freelancer.FieldUpworkTotalFeedback:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpworkTotalFeedback(v)
		return nil
	case freelancer.FieldUpworkRecentFeedback:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpworkRecentFeedback(v)
		return nil
	case freelancer.FieldUpworkTopRatedStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpworkTopRatedStatus(v)
		return nil
	case freelancer.FieldUpworkTopRatedPlusStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpworkTopRatedPlusStatus(v)
		return nil
	case freelancer.FieldUpworkSponsored:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpworkSponsored(v)
		return nil
	case freelancer.FieldUpworkJobSuccessScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpworkJobSuccessScore(v)
		return nil
	case freelancer.FieldUpworkReccomended:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpworkReccomended(v)
		return nil
	case freelancer.FieldSkills:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkills(v)
		return nil
	case freelancer.FieldAverageRecentEarnings:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAverageRecentEarnings(v)
		return nil
	case freelancer.FieldCombinedAverageRecentEarnings:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCombinedAverageRecentEarnings(v)
		return nil
	case freelancer.FieldCombinedRecentEarnings:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCombinedRecentEarnings(v)
		return nil
	case freelancer.FieldCombinedTotalEarnings:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCombinedTotalEarnings(v)
		return nil
	case freelancer.FieldCombinedTotalRevenue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCombinedTotalRevenue(v)
		return nil
	case freelancer.FieldRecentEarnings:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecentEarnings(v)
		return nil
	case freelancer.FieldTotalRevenue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalRevenue(v)
		return nil
	case freelancer.FieldUprankScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUprankScore(v)
		return nil
	case freelancer.FieldUprankUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUprankUpdatedAt(v)
		return nil
	case freelancer.FieldUprankReccomended:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUprankReccomended(v)
		return nil
	case freelancer.FieldUprankReccomendedReasons:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUprankReccomendedReasons(v)
		return nil
	case freelancer.FieldUprankNotEnoughData:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUprankNotEnoughData(v)
		return nil
	}
	return fmt.Errorf("unknown Freelancer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FreelancerMutation) AddedFields() []string {
	var fields []string
	if m.addfixed_charge_amount != nil {
		fields = append(fields, freelancer.FieldFixedChargeAmount)
	}
	if m.addhourly_charge_amount != nil {
		fields = append(fields, freelancer.FieldHourlyChargeAmount)
	}
	if m.addrecent_hours != nil {
		fields = append(fields, freelancer.FieldRecentHours)
	}
	if m.addtotal_hours != nil {
		fields = append(fields, freelancer.FieldTotalHours)
	}
	if m.addtotal_portfolio_items != nil {
		fields = append(fields, freelancer.FieldTotalPortfolioItems)
	}
	if m.addtotal_portfolio_v2_items != nil {
		fields = append(fields, freelancer.FieldTotalPortfolioV2Items)
	}
	if m.addupwork_total_feedback != nil {
		fields = append(fields, freelancer.FieldUpworkTotalFeedback)
	}
	if m.addupwork_recent_feedback != nil {
		fields = append(fields, freelancer.FieldUpworkRecentFeedback)
	}
	if m.addupwork_job_success_score != nil {
		fields = append(fields, freelancer.FieldUpworkJobSuccessScore)
	}
	if m.addaverage_recent_earnings != nil {
		fields = append(fields, freelancer.FieldAverageRecentEarnings)
	}
	if m.addcombined_average_recent_earnings != nil {
		fields = append(fields, freelancer.FieldCombinedAverageRecentEarnings)
	}
	if m.addcombined_recent_earnings != nil {
		fields = append(fields, freelancer.FieldCombinedRecentEarnings)
	}
	if m.addcombined_total_earnings != nil {
		fields = append(fields, freelancer.FieldCombinedTotalEarnings)
	}
	if m.addcombined_total_revenue != nil {
		fields = append(fields, freelancer.FieldCombinedTotalRevenue)
	}
	if m.addrecent_earnings != nil {
		fields = append(fields, freelancer.FieldRecentEarnings)
	}
	if m.addtotal_revenue != nil {
		fields = append(fields, freelancer.FieldTotalRevenue)
	}
	if m.adduprank_score != nil {
		fields = append(fields, freelancer.FieldUprankScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FreelancerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case freelancer.FieldFixedChargeAmount:
		return m.AddedFixedChargeAmount()
	case freelancer.FieldHourlyChargeAmount:
		return m.AddedHourlyChargeAmount()
	case freelancer.FieldRecentHours:
		return m.AddedRecentHours()
	case freelancer.FieldTotalHours:
		return m.AddedTotalHours()
	case freelancer.FieldTotalPortfolioItems:
		return m.AddedTotalPortfolioItems()
	case freelancer.FieldTotalPortfolioV2Items:
		return m.AddedTotalPortfolioV2Items()
	case freelancer.FieldUpworkTotalFeedback:
		return m.AddedUpworkTotalFeedback()
	case freelancer.FieldUpworkRecentFeedback:
		return m.AddedUpworkRecentFeedback()
	case freelancer.FieldUpworkJobSuccessScore:
		return m.AddedUpworkJobSuccessScore()
	case freelancer.FieldAverageRecentEarnings:
		return m.AddedAverageRecentEarnings()
	case freelancer.FieldCombinedAverageRecentEarnings:
		return m.AddedCombinedAverageRecentEarnings()
	case freelancer.FieldCombinedRecentEarnings:
		return m.AddedCombinedRecentEarnings()
	case freelancer.FieldCombinedTotalEarnings:
		return m.AddedCombinedTotalEarnings()
	case freelancer.FieldCombinedTotalRevenue:
		return m.AddedCombinedTotalRevenue()
	case freelancer.FieldRecentEarnings:
		return m.AddedRecentEarnings()
	case freelancer.FieldTotalRevenue:
		return m.AddedTotalRevenue()
	case freelancer.FieldUprankScore:
		return m.AddedUprankScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FreelancerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case freelancer.FieldFixedChargeAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFixedChargeAmount(v)
		return nil
	case freelancer.FieldHourlyChargeAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHourlyChargeAmount(v)
		return nil
	case freelancer.FieldRecentHours:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRecentHours(v)
		return nil
	case freelancer.FieldTotalHours:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalHours(v)
		return nil
	case freelancer.FieldTotalPortfolioItems:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalPortfolioItems(v)
		return nil
	case freelancer.FieldTotalPortfolioV2Items:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalPortfolioV2Items(v)
		return nil
	case freelancer.FieldUpworkTotalFeedback:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpworkTotalFeedback(v)
		return nil
	case freelancer.FieldUpworkRecentFeedback:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpworkRecentFeedback(v)
		return nil
	case freelancer.FieldUpworkJobSuccessScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpworkJobSuccessScore(v)
		return nil
	case freelancer.FieldAverageRecentEarnings:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAverageRecentEarnings(v)
		return nil
	case freelancer.FieldCombinedAverageRecentEarnings:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCombinedAverageRecentEarnings(v)
		return nil
	case freelancer.FieldCombinedRecentEarnings:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCombinedRecentEarnings(v)
		return nil
	case freelancer.FieldCombinedTotalEarnings:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCombinedTotalEarnings(v)
		return nil
	case freelancer.FieldCombinedTotalRevenue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCombinedTotalRevenue(v)
		return nil
	case freelancer.FieldRecentEarnings:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRecentEarnings(v)
		return nil
	case freelancer.FieldTotalRevenue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalRevenue(v)
		return nil
	case freelancer.FieldUprankScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUprankScore(v)
		return nil
	}
	return fmt.Errorf("unknown Freelancer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FreelancerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(freelancer.FieldFixedChargeAmount) {
		fields = append(fields, freelancer.FieldFixedChargeAmount)
	}
	if m.FieldCleared(freelancer.FieldHourlyChargeAmount) {
		fields = append(fields, freelancer.FieldHourlyChargeAmount)
	}
	if m.FieldCleared(freelancer.FieldUprankScore) {
		fields = append(fields, freelancer.FieldUprankScore)
	}
	if m.FieldCleared(freelancer.FieldUprankReccomended) {
		fields = append(fields, freelancer.FieldUprankReccomended)
	}
	if m.FieldCleared(freelancer.FieldUprankReccomendedReasons) {
		fields = append(fields, freelancer.FieldUprankReccomendedReasons)
	}
	if m.FieldCleared(freelancer.FieldUprankNotEnoughData) {
		fields = append(fields, freelancer.FieldUprankNotEnoughData)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FreelancerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FreelancerMutation) ClearField(name string) error {
	switch name {
	case freelancer.FieldFixedChargeAmount:
		m.ClearFixedChargeAmount()
		return nil
	case freelancer.FieldHourlyChargeAmount:
		m.ClearHourlyChargeAmount()
		return nil
	case freelancer.FieldUprankScore:
		m.ClearUprankScore()
		return nil
	case freelancer.FieldUprankReccomended:
		m.ClearUprankReccomended()
		return nil
	case freelancer.FieldUprankReccomendedReasons:
		m.ClearUprankReccomendedReasons()
		return nil
	case freelancer.FieldUprankNotEnoughData:
		m.ClearUprankNotEnoughData()
		return nil
	}
	return fmt.Errorf("unknown Freelancer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FreelancerMutation) ResetField(name string) error {
	switch name {
	case freelancer.FieldURL:
		m.ResetURL()
		return nil
	case freelancer.FieldName:
		m.ResetName()
		return nil
	case freelancer.FieldTitle:
		m.ResetTitle()
		return nil
	case freelancer.FieldDescription:
		m.ResetDescription()
		return nil
	case freelancer.FieldCity:
		m.ResetCity()
		return nil
	case freelancer.FieldCountry:
		m.ResetCountry()
		return nil
	case freelancer.FieldTimezone:
		m.ResetTimezone()
		return nil
	case freelancer.FieldCv:
		m.ResetCv()
		return nil
	case freelancer.FieldAiReccomended:
		m.ResetAiReccomended()
		return nil
	case freelancer.FieldFixedChargeAmount:
		m.ResetFixedChargeAmount()
		return nil
	case freelancer.FieldFixedChargeCurrency:
		m.ResetFixedChargeCurrency()
		return nil
	case freelancer.FieldHourlyChargeAmount:
		m.ResetHourlyChargeAmount()
		return nil
	case freelancer.FieldHourlyChargeCurrency:
		m.ResetHourlyChargeCurrency()
		return nil
	case freelancer.FieldInvited:
		m.ResetInvited()
		return nil
	case freelancer.FieldPhotoURL:
		m.ResetPhotoURL()
		return nil
	case freelancer.FieldRecentHours:
		m.ResetRecentHours()
		return nil
	case freelancer.FieldTotalHours:
		m.ResetTotalHours()
		return nil
	case freelancer.FieldTotalPortfolioItems:
		m.ResetTotalPortfolioItems()
		return nil
	case freelancer.FieldTotalPortfolioV2Items:
		m.ResetTotalPortfolioV2Items()
		return nil
	case freelancer.FieldUpworkTotalFeedback:
		m.ResetUpworkTotalFeedback()
		return nil
	case freelancer.FieldUpworkRecentFeedback:
		m.ResetUpworkRecentFeedback()
		return nil
	case freelancer.FieldUpworkTopRatedStatus:
		m.ResetUpworkTopRatedStatus()
		return nil
	case freelancer.FieldUpworkTopRatedPlusStatus:
		m.ResetUpworkTopRatedPlusStatus()
		return nil
	case freelancer.FieldUpworkSponsored:
		m.ResetUpworkSponsored()
		return nil
	case freelancer.FieldUpworkJobSuccessScore:
		m.ResetUpworkJobSuccessScore()
		return nil
	case freelancer.FieldUpworkReccomended:
		m.ResetUpworkReccomended()
		return nil
	case freelancer.FieldSkills:
		m.ResetSkills()
		return nil
	case freelancer.FieldAverageRecentEarnings:
		m.ResetAverageRecentEarnings()
		return nil
	case freelancer.FieldCombinedAverageRecentEarnings:
		m.ResetCombinedAverageRecentEarnings()
		return nil
	case freelancer.FieldCombinedRecentEarnings:
		m.ResetCombinedRecentEarnings()
		return nil
	case freelancer.FieldCombinedTotalEarnings:
		m.ResetCombinedTotalEarnings()
		return nil
	case freelancer.FieldCombinedTotalRevenue:
		m.ResetCombinedTotalRevenue()
		return nil
	case freelancer.FieldRecentEarnings:
		m.ResetRecentEarnings()
		return nil
	case freelancer.FieldTotalRevenue:
		m.ResetTotalRevenue()
		return nil
	case freelancer.FieldUprankScore:
		m.ResetUprankScore()
		return nil
	case freelancer.FieldUprankUpdatedAt:
		m.ResetUprankUpdatedAt()
		return nil
	case freelancer.FieldUprankReccomended:
		m.ResetUprankReccomended()
		return nil
	case freelancer.FieldUprankReccomendedReasons:
		m.ResetUprankReccomendedReasons()
		return nil
	case freelancer.FieldUprankNotEnoughData:
		m.ResetUprankNotEnoughData()
		return nil
	}
	return fmt.Errorf("unknown Freelancer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FreelancerMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.job != nil {
		edges = append(edges, freelancer.EdgeJob)
	}
	if m.attachments != nil {
		edges = append(edges, freelancer.EdgeAttachments)
	}
	if m.work_histories != nil {
		edges = append(edges, freelancer.EdgeWorkHistories)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FreelancerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case freelancer.EdgeJob:
		if id := m.job; id != nil {
			return []ent.Value{*id}
		}
	case freelancer.EdgeAttachments:
		ids := make([]ent.Value, 0, len(m.attachments))
		for id := range m.attachments {
			ids = append(ids, id)
		}
		return ids
	case freelancer.EdgeWorkHistories:
		ids := make([]ent.Value, 0, len(m.work_histories))
		for id := range m.work_histories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FreelancerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedattachments != nil {
		edges = append(edges, freelancer.EdgeAttachments)
	}
	if m.removedwork_histories != nil {
		edges = append(edges, freelancer.EdgeWorkHistories)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FreelancerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case freelancer.EdgeAttachments:
		ids := make([]ent.Value, 0, len(m.removedattachments))
		for id := range m.removedattachments {
			ids = append(ids, id)
		}
		return ids
	case freelancer.EdgeWorkHistories:
		ids := make([]ent.Value, 0, len(m.removedwork_histories))
		for id := range m.removedwork_histories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FreelancerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedjob {
		edges = append(edges, freelancer.EdgeJob)
	}
	if m.clearedattachments {
		edges = append(edges, freelancer.EdgeAttachments)
	}
	if m.clearedwork_histories {
		edges = append(edges, freelancer.EdgeWorkHistories)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FreelancerMutation) EdgeCleared(name string) bool {
	switch name {
	case freelancer.EdgeJob:
		return m.clearedjob
	case freelancer.EdgeAttachments:
		return m.clearedattachments
	case freelancer.EdgeWorkHistories:
		return m.clearedwork_histories
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FreelancerMutation) ClearEdge(name string) error {
	switch name {
	case freelancer.EdgeJob:
		m.ClearJob()
		return nil
	}
	return fmt.Errorf("unknown Freelancer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FreelancerMutation) ResetEdge(name string) error {
	switch name {
	case freelancer.EdgeJob:
		m.ResetJob()
		return nil
	case freelancer.EdgeAttachments:
		m.ResetAttachments()
		return nil
	case freelancer.EdgeWorkHistories:
		m.ResetWorkHistories()
		return nil
	}
	return fmt.Errorf("unknown Freelancer edge %s", name)
}

// JobMutation represents an operation that mutates the Job nodes in the graph.
type JobMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	title                   *string
	created_at              *time.Time
	location                *string
	description             *string
	skills                  *[]string
	appendskills            []string
	experience_level        *string
	hourly                  *bool
	fixed                   *bool
	hourly_rate             *[]int
	appendhourly_rate       []int
	fixed_rate              *float64
	addfixed_rate           *float64
	average_uprank_score    *float64
	addaverage_uprank_score *float64
	max_uprank_score        *float64
	addmax_uprank_score     *float64
	min_uprank_score        *float64
	addmin_uprank_score     *float64
	clearedFields           map[string]struct{}
	user                    *string
	cleareduser             bool
	freelancers             map[uuid.UUID]struct{}
	removedfreelancers      map[uuid.UUID]struct{}
	clearedfreelancers      bool
	done                    bool
	oldValue                func(context.Context) (*Job, error)
	predicates              []predicate.Job
}

var _ ent.Mutation = (*JobMutation)(nil)

// jobOption allows management of the mutation configuration using functional options.
type jobOption func(*JobMutation)

// newJobMutation creates new mutation for the Job entity.
func newJobMutation(c config, op Op, opts ...jobOption) *JobMutation {
	m := &JobMutation{
		config:        c,
		op:            op,
		typ:           TypeJob,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobID sets the ID field of the mutation.
func withJobID(id int) jobOption {
	return func(m *JobMutation) {
		var (
			err   error
			once  sync.Once
			value *Job
		)
		m.oldValue = func(ctx context.Context) (*Job, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Job.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJob sets the old Job of the mutation.
func withJob(node *Job) jobOption {
	return func(m *JobMutation) {
		m.oldValue = func(context.Context) (*Job, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Job.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *JobMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *JobMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *JobMutation) ResetTitle() {
	m.title = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *JobMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *JobMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *JobMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetLocation sets the "location" field.
func (m *JobMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *JobMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *JobMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[job.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *JobMutation) LocationCleared() bool {
	_, ok := m.clearedFields[job.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *JobMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, job.FieldLocation)
}

// SetDescription sets the "description" field.
func (m *JobMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *JobMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *JobMutation) ResetDescription() {
	m.description = nil
}

// SetSkills sets the "skills" field.
func (m *JobMutation) SetSkills(s []string) {
	m.skills = &s
	m.appendskills = nil
}

// Skills returns the value of the "skills" field in the mutation.
func (m *JobMutation) Skills() (r []string, exists bool) {
	v := m.skills
	if v == nil {
		return
	}
	return *v, true
}

// OldSkills returns the old "skills" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldSkills(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkills is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkills requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkills: %w", err)
	}
	return oldValue.Skills, nil
}

// AppendSkills adds s to the "skills" field.
func (m *JobMutation) AppendSkills(s []string) {
	m.appendskills = append(m.appendskills, s...)
}

// AppendedSkills returns the list of values that were appended to the "skills" field in this mutation.
func (m *JobMutation) AppendedSkills() ([]string, bool) {
	if len(m.appendskills) == 0 {
		return nil, false
	}
	return m.appendskills, true
}

// ClearSkills clears the value of the "skills" field.
func (m *JobMutation) ClearSkills() {
	m.skills = nil
	m.appendskills = nil
	m.clearedFields[job.FieldSkills] = struct{}{}
}

// SkillsCleared returns if the "skills" field was cleared in this mutation.
func (m *JobMutation) SkillsCleared() bool {
	_, ok := m.clearedFields[job.FieldSkills]
	return ok
}

// ResetSkills resets all changes to the "skills" field.
func (m *JobMutation) ResetSkills() {
	m.skills = nil
	m.appendskills = nil
	delete(m.clearedFields, job.FieldSkills)
}

// SetExperienceLevel sets the "experience_level" field.
func (m *JobMutation) SetExperienceLevel(s string) {
	m.experience_level = &s
}

// ExperienceLevel returns the value of the "experience_level" field in the mutation.
func (m *JobMutation) ExperienceLevel() (r string, exists bool) {
	v := m.experience_level
	if v == nil {
		return
	}
	return *v, true
}

// OldExperienceLevel returns the old "experience_level" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldExperienceLevel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExperienceLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExperienceLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExperienceLevel: %w", err)
	}
	return oldValue.ExperienceLevel, nil
}

// ClearExperienceLevel clears the value of the "experience_level" field.
func (m *JobMutation) ClearExperienceLevel() {
	m.experience_level = nil
	m.clearedFields[job.FieldExperienceLevel] = struct{}{}
}

// ExperienceLevelCleared returns if the "experience_level" field was cleared in this mutation.
func (m *JobMutation) ExperienceLevelCleared() bool {
	_, ok := m.clearedFields[job.FieldExperienceLevel]
	return ok
}

// ResetExperienceLevel resets all changes to the "experience_level" field.
func (m *JobMutation) ResetExperienceLevel() {
	m.experience_level = nil
	delete(m.clearedFields, job.FieldExperienceLevel)
}

// SetHourly sets the "hourly" field.
func (m *JobMutation) SetHourly(b bool) {
	m.hourly = &b
}

// Hourly returns the value of the "hourly" field in the mutation.
func (m *JobMutation) Hourly() (r bool, exists bool) {
	v := m.hourly
	if v == nil {
		return
	}
	return *v, true
}

// OldHourly returns the old "hourly" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldHourly(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHourly is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHourly requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHourly: %w", err)
	}
	return oldValue.Hourly, nil
}

// ResetHourly resets all changes to the "hourly" field.
func (m *JobMutation) ResetHourly() {
	m.hourly = nil
}

// SetFixed sets the "fixed" field.
func (m *JobMutation) SetFixed(b bool) {
	m.fixed = &b
}

// Fixed returns the value of the "fixed" field in the mutation.
func (m *JobMutation) Fixed() (r bool, exists bool) {
	v := m.fixed
	if v == nil {
		return
	}
	return *v, true
}

// OldFixed returns the old "fixed" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldFixed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFixed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFixed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFixed: %w", err)
	}
	return oldValue.Fixed, nil
}

// ResetFixed resets all changes to the "fixed" field.
func (m *JobMutation) ResetFixed() {
	m.fixed = nil
}

// SetHourlyRate sets the "hourly_rate" field.
func (m *JobMutation) SetHourlyRate(i []int) {
	m.hourly_rate = &i
	m.appendhourly_rate = nil
}

// HourlyRate returns the value of the "hourly_rate" field in the mutation.
func (m *JobMutation) HourlyRate() (r []int, exists bool) {
	v := m.hourly_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldHourlyRate returns the old "hourly_rate" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldHourlyRate(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHourlyRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHourlyRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHourlyRate: %w", err)
	}
	return oldValue.HourlyRate, nil
}

// AppendHourlyRate adds i to the "hourly_rate" field.
func (m *JobMutation) AppendHourlyRate(i []int) {
	m.appendhourly_rate = append(m.appendhourly_rate, i...)
}

// AppendedHourlyRate returns the list of values that were appended to the "hourly_rate" field in this mutation.
func (m *JobMutation) AppendedHourlyRate() ([]int, bool) {
	if len(m.appendhourly_rate) == 0 {
		return nil, false
	}
	return m.appendhourly_rate, true
}

// ClearHourlyRate clears the value of the "hourly_rate" field.
func (m *JobMutation) ClearHourlyRate() {
	m.hourly_rate = nil
	m.appendhourly_rate = nil
	m.clearedFields[job.FieldHourlyRate] = struct{}{}
}

// HourlyRateCleared returns if the "hourly_rate" field was cleared in this mutation.
func (m *JobMutation) HourlyRateCleared() bool {
	_, ok := m.clearedFields[job.FieldHourlyRate]
	return ok
}

// ResetHourlyRate resets all changes to the "hourly_rate" field.
func (m *JobMutation) ResetHourlyRate() {
	m.hourly_rate = nil
	m.appendhourly_rate = nil
	delete(m.clearedFields, job.FieldHourlyRate)
}

// SetFixedRate sets the "fixed_rate" field.
func (m *JobMutation) SetFixedRate(f float64) {
	m.fixed_rate = &f
	m.addfixed_rate = nil
}

// FixedRate returns the value of the "fixed_rate" field in the mutation.
func (m *JobMutation) FixedRate() (r float64, exists bool) {
	v := m.fixed_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldFixedRate returns the old "fixed_rate" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldFixedRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFixedRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFixedRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFixedRate: %w", err)
	}
	return oldValue.FixedRate, nil
}

// AddFixedRate adds f to the "fixed_rate" field.
func (m *JobMutation) AddFixedRate(f float64) {
	if m.addfixed_rate != nil {
		*m.addfixed_rate += f
	} else {
		m.addfixed_rate = &f
	}
}

// AddedFixedRate returns the value that was added to the "fixed_rate" field in this mutation.
func (m *JobMutation) AddedFixedRate() (r float64, exists bool) {
	v := m.addfixed_rate
	if v == nil {
		return
	}
	return *v, true
}

// ClearFixedRate clears the value of the "fixed_rate" field.
func (m *JobMutation) ClearFixedRate() {
	m.fixed_rate = nil
	m.addfixed_rate = nil
	m.clearedFields[job.FieldFixedRate] = struct{}{}
}

// FixedRateCleared returns if the "fixed_rate" field was cleared in this mutation.
func (m *JobMutation) FixedRateCleared() bool {
	_, ok := m.clearedFields[job.FieldFixedRate]
	return ok
}

// ResetFixedRate resets all changes to the "fixed_rate" field.
func (m *JobMutation) ResetFixedRate() {
	m.fixed_rate = nil
	m.addfixed_rate = nil
	delete(m.clearedFields, job.FieldFixedRate)
}

// SetAverageUprankScore sets the "average_uprank_score" field.
func (m *JobMutation) SetAverageUprankScore(f float64) {
	m.average_uprank_score = &f
	m.addaverage_uprank_score = nil
}

// AverageUprankScore returns the value of the "average_uprank_score" field in the mutation.
func (m *JobMutation) AverageUprankScore() (r float64, exists bool) {
	v := m.average_uprank_score
	if v == nil {
		return
	}
	return *v, true
}

// OldAverageUprankScore returns the old "average_uprank_score" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldAverageUprankScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAverageUprankScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAverageUprankScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAverageUprankScore: %w", err)
	}
	return oldValue.AverageUprankScore, nil
}

// AddAverageUprankScore adds f to the "average_uprank_score" field.
func (m *JobMutation) AddAverageUprankScore(f float64) {
	if m.addaverage_uprank_score != nil {
		*m.addaverage_uprank_score += f
	} else {
		m.addaverage_uprank_score = &f
	}
}

// AddedAverageUprankScore returns the value that was added to the "average_uprank_score" field in this mutation.
func (m *JobMutation) AddedAverageUprankScore() (r float64, exists bool) {
	v := m.addaverage_uprank_score
	if v == nil {
		return
	}
	return *v, true
}

// ClearAverageUprankScore clears the value of the "average_uprank_score" field.
func (m *JobMutation) ClearAverageUprankScore() {
	m.average_uprank_score = nil
	m.addaverage_uprank_score = nil
	m.clearedFields[job.FieldAverageUprankScore] = struct{}{}
}

// AverageUprankScoreCleared returns if the "average_uprank_score" field was cleared in this mutation.
func (m *JobMutation) AverageUprankScoreCleared() bool {
	_, ok := m.clearedFields[job.FieldAverageUprankScore]
	return ok
}

// ResetAverageUprankScore resets all changes to the "average_uprank_score" field.
func (m *JobMutation) ResetAverageUprankScore() {
	m.average_uprank_score = nil
	m.addaverage_uprank_score = nil
	delete(m.clearedFields, job.FieldAverageUprankScore)
}

// SetMaxUprankScore sets the "max_uprank_score" field.
func (m *JobMutation) SetMaxUprankScore(f float64) {
	m.max_uprank_score = &f
	m.addmax_uprank_score = nil
}

// MaxUprankScore returns the value of the "max_uprank_score" field in the mutation.
func (m *JobMutation) MaxUprankScore() (r float64, exists bool) {
	v := m.max_uprank_score
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxUprankScore returns the old "max_uprank_score" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldMaxUprankScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxUprankScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxUprankScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxUprankScore: %w", err)
	}
	return oldValue.MaxUprankScore, nil
}

// AddMaxUprankScore adds f to the "max_uprank_score" field.
func (m *JobMutation) AddMaxUprankScore(f float64) {
	if m.addmax_uprank_score != nil {
		*m.addmax_uprank_score += f
	} else {
		m.addmax_uprank_score = &f
	}
}

// AddedMaxUprankScore returns the value that was added to the "max_uprank_score" field in this mutation.
func (m *JobMutation) AddedMaxUprankScore() (r float64, exists bool) {
	v := m.addmax_uprank_score
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxUprankScore clears the value of the "max_uprank_score" field.
func (m *JobMutation) ClearMaxUprankScore() {
	m.max_uprank_score = nil
	m.addmax_uprank_score = nil
	m.clearedFields[job.FieldMaxUprankScore] = struct{}{}
}

// MaxUprankScoreCleared returns if the "max_uprank_score" field was cleared in this mutation.
func (m *JobMutation) MaxUprankScoreCleared() bool {
	_, ok := m.clearedFields[job.FieldMaxUprankScore]
	return ok
}

// ResetMaxUprankScore resets all changes to the "max_uprank_score" field.
func (m *JobMutation) ResetMaxUprankScore() {
	m.max_uprank_score = nil
	m.addmax_uprank_score = nil
	delete(m.clearedFields, job.FieldMaxUprankScore)
}

// SetMinUprankScore sets the "min_uprank_score" field.
func (m *JobMutation) SetMinUprankScore(f float64) {
	m.min_uprank_score = &f
	m.addmin_uprank_score = nil
}

// MinUprankScore returns the value of the "min_uprank_score" field in the mutation.
func (m *JobMutation) MinUprankScore() (r float64, exists bool) {
	v := m.min_uprank_score
	if v == nil {
		return
	}
	return *v, true
}

// OldMinUprankScore returns the old "min_uprank_score" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldMinUprankScore(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinUprankScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinUprankScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinUprankScore: %w", err)
	}
	return oldValue.MinUprankScore, nil
}

// AddMinUprankScore adds f to the "min_uprank_score" field.
func (m *JobMutation) AddMinUprankScore(f float64) {
	if m.addmin_uprank_score != nil {
		*m.addmin_uprank_score += f
	} else {
		m.addmin_uprank_score = &f
	}
}

// AddedMinUprankScore returns the value that was added to the "min_uprank_score" field in this mutation.
func (m *JobMutation) AddedMinUprankScore() (r float64, exists bool) {
	v := m.addmin_uprank_score
	if v == nil {
		return
	}
	return *v, true
}

// ClearMinUprankScore clears the value of the "min_uprank_score" field.
func (m *JobMutation) ClearMinUprankScore() {
	m.min_uprank_score = nil
	m.addmin_uprank_score = nil
	m.clearedFields[job.FieldMinUprankScore] = struct{}{}
}

// MinUprankScoreCleared returns if the "min_uprank_score" field was cleared in this mutation.
func (m *JobMutation) MinUprankScoreCleared() bool {
	_, ok := m.clearedFields[job.FieldMinUprankScore]
	return ok
}

// ResetMinUprankScore resets all changes to the "min_uprank_score" field.
func (m *JobMutation) ResetMinUprankScore() {
	m.min_uprank_score = nil
	m.addmin_uprank_score = nil
	delete(m.clearedFields, job.FieldMinUprankScore)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *JobMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *JobMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *JobMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *JobMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *JobMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *JobMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddFreelancerIDs adds the "freelancers" edge to the Freelancer entity by ids.
func (m *JobMutation) AddFreelancerIDs(ids ...uuid.UUID) {
	if m.freelancers == nil {
		m.freelancers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.freelancers[ids[i]] = struct{}{}
	}
}

// ClearFreelancers clears the "freelancers" edge to the Freelancer entity.
func (m *JobMutation) ClearFreelancers() {
	m.clearedfreelancers = true
}

// FreelancersCleared reports if the "freelancers" edge to the Freelancer entity was cleared.
func (m *JobMutation) FreelancersCleared() bool {
	return m.clearedfreelancers
}

// RemoveFreelancerIDs removes the "freelancers" edge to the Freelancer entity by IDs.
func (m *JobMutation) RemoveFreelancerIDs(ids ...uuid.UUID) {
	if m.removedfreelancers == nil {
		m.removedfreelancers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.freelancers, ids[i])
		m.removedfreelancers[ids[i]] = struct{}{}
	}
}

// RemovedFreelancers returns the removed IDs of the "freelancers" edge to the Freelancer entity.
func (m *JobMutation) RemovedFreelancersIDs() (ids []uuid.UUID) {
	for id := range m.removedfreelancers {
		ids = append(ids, id)
	}
	return
}

// FreelancersIDs returns the "freelancers" edge IDs in the mutation.
func (m *JobMutation) FreelancersIDs() (ids []uuid.UUID) {
	for id := range m.freelancers {
		ids = append(ids, id)
	}
	return
}

// ResetFreelancers resets all changes to the "freelancers" edge.
func (m *JobMutation) ResetFreelancers() {
	m.freelancers = nil
	m.clearedfreelancers = false
	m.removedfreelancers = nil
}

// Where appends a list predicates to the JobMutation builder.
func (m *JobMutation) Where(ps ...predicate.Job) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Job, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Job).
func (m *JobMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.title != nil {
		fields = append(fields, job.FieldTitle)
	}
	if m.created_at != nil {
		fields = append(fields, job.FieldCreatedAt)
	}
	if m.location != nil {
		fields = append(fields, job.FieldLocation)
	}
	if m.description != nil {
		fields = append(fields, job.FieldDescription)
	}
	if m.skills != nil {
		fields = append(fields, job.FieldSkills)
	}
	if m.experience_level != nil {
		fields = append(fields, job.FieldExperienceLevel)
	}
	if m.hourly != nil {
		fields = append(fields, job.FieldHourly)
	}
	if m.fixed != nil {
		fields = append(fields, job.FieldFixed)
	}
	if m.hourly_rate != nil {
		fields = append(fields, job.FieldHourlyRate)
	}
	if m.fixed_rate != nil {
		fields = append(fields, job.FieldFixedRate)
	}
	if m.average_uprank_score != nil {
		fields = append(fields, job.FieldAverageUprankScore)
	}
	if m.max_uprank_score != nil {
		fields = append(fields, job.FieldMaxUprankScore)
	}
	if m.min_uprank_score != nil {
		fields = append(fields, job.FieldMinUprankScore)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case job.FieldTitle:
		return m.Title()
	case job.FieldCreatedAt:
		return m.CreatedAt()
	case job.FieldLocation:
		return m.Location()
	case job.FieldDescription:
		return m.Description()
	case job.FieldSkills:
		return m.Skills()
	case job.FieldExperienceLevel:
		return m.ExperienceLevel()
	case job.FieldHourly:
		return m.Hourly()
	case job.FieldFixed:
		return m.Fixed()
	case job.FieldHourlyRate:
		return m.HourlyRate()
	case job.FieldFixedRate:
		return m.FixedRate()
	case job.FieldAverageUprankScore:
		return m.AverageUprankScore()
	case job.FieldMaxUprankScore:
		return m.MaxUprankScore()
	case job.FieldMinUprankScore:
		return m.MinUprankScore()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case job.FieldTitle:
		return m.OldTitle(ctx)
	case job.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case job.FieldLocation:
		return m.OldLocation(ctx)
	case job.FieldDescription:
		return m.OldDescription(ctx)
	case job.FieldSkills:
		return m.OldSkills(ctx)
	case job.FieldExperienceLevel:
		return m.OldExperienceLevel(ctx)
	case job.FieldHourly:
		return m.OldHourly(ctx)
	case job.FieldFixed:
		return m.OldFixed(ctx)
	case job.FieldHourlyRate:
		return m.OldHourlyRate(ctx)
	case job.FieldFixedRate:
		return m.OldFixedRate(ctx)
	case job.FieldAverageUprankScore:
		return m.OldAverageUprankScore(ctx)
	case job.FieldMaxUprankScore:
		return m.OldMaxUprankScore(ctx)
	case job.FieldMinUprankScore:
		return m.OldMinUprankScore(ctx)
	}
	return nil, fmt.Errorf("unknown Job field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobMutation) SetField(name string, value ent.Value) error {
	switch name {
	case job.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case job.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case job.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case job.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case job.FieldSkills:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkills(v)
		return nil
	case job.FieldExperienceLevel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExperienceLevel(v)
		return nil
	case job.FieldHourly:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHourly(v)
		return nil
	case job.FieldFixed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFixed(v)
		return nil
	case job.FieldHourlyRate:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHourlyRate(v)
		return nil
	case job.FieldFixedRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFixedRate(v)
		return nil
	case job.FieldAverageUprankScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAverageUprankScore(v)
		return nil
	case job.FieldMaxUprankScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxUprankScore(v)
		return nil
	case job.FieldMinUprankScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinUprankScore(v)
		return nil
	}
	return fmt.Errorf("unknown Job field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobMutation) AddedFields() []string {
	var fields []string
	if m.addfixed_rate != nil {
		fields = append(fields, job.FieldFixedRate)
	}
	if m.addaverage_uprank_score != nil {
		fields = append(fields, job.FieldAverageUprankScore)
	}
	if m.addmax_uprank_score != nil {
		fields = append(fields, job.FieldMaxUprankScore)
	}
	if m.addmin_uprank_score != nil {
		fields = append(fields, job.FieldMinUprankScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case job.FieldFixedRate:
		return m.AddedFixedRate()
	case job.FieldAverageUprankScore:
		return m.AddedAverageUprankScore()
	case job.FieldMaxUprankScore:
		return m.AddedMaxUprankScore()
	case job.FieldMinUprankScore:
		return m.AddedMinUprankScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobMutation) AddField(name string, value ent.Value) error {
	switch name {
	case job.FieldFixedRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFixedRate(v)
		return nil
	case job.FieldAverageUprankScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAverageUprankScore(v)
		return nil
	case job.FieldMaxUprankScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxUprankScore(v)
		return nil
	case job.FieldMinUprankScore:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinUprankScore(v)
		return nil
	}
	return fmt.Errorf("unknown Job numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(job.FieldLocation) {
		fields = append(fields, job.FieldLocation)
	}
	if m.FieldCleared(job.FieldSkills) {
		fields = append(fields, job.FieldSkills)
	}
	if m.FieldCleared(job.FieldExperienceLevel) {
		fields = append(fields, job.FieldExperienceLevel)
	}
	if m.FieldCleared(job.FieldHourlyRate) {
		fields = append(fields, job.FieldHourlyRate)
	}
	if m.FieldCleared(job.FieldFixedRate) {
		fields = append(fields, job.FieldFixedRate)
	}
	if m.FieldCleared(job.FieldAverageUprankScore) {
		fields = append(fields, job.FieldAverageUprankScore)
	}
	if m.FieldCleared(job.FieldMaxUprankScore) {
		fields = append(fields, job.FieldMaxUprankScore)
	}
	if m.FieldCleared(job.FieldMinUprankScore) {
		fields = append(fields, job.FieldMinUprankScore)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobMutation) ClearField(name string) error {
	switch name {
	case job.FieldLocation:
		m.ClearLocation()
		return nil
	case job.FieldSkills:
		m.ClearSkills()
		return nil
	case job.FieldExperienceLevel:
		m.ClearExperienceLevel()
		return nil
	case job.FieldHourlyRate:
		m.ClearHourlyRate()
		return nil
	case job.FieldFixedRate:
		m.ClearFixedRate()
		return nil
	case job.FieldAverageUprankScore:
		m.ClearAverageUprankScore()
		return nil
	case job.FieldMaxUprankScore:
		m.ClearMaxUprankScore()
		return nil
	case job.FieldMinUprankScore:
		m.ClearMinUprankScore()
		return nil
	}
	return fmt.Errorf("unknown Job nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobMutation) ResetField(name string) error {
	switch name {
	case job.FieldTitle:
		m.ResetTitle()
		return nil
	case job.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case job.FieldLocation:
		m.ResetLocation()
		return nil
	case job.FieldDescription:
		m.ResetDescription()
		return nil
	case job.FieldSkills:
		m.ResetSkills()
		return nil
	case job.FieldExperienceLevel:
		m.ResetExperienceLevel()
		return nil
	case job.FieldHourly:
		m.ResetHourly()
		return nil
	case job.FieldFixed:
		m.ResetFixed()
		return nil
	case job.FieldHourlyRate:
		m.ResetHourlyRate()
		return nil
	case job.FieldFixedRate:
		m.ResetFixedRate()
		return nil
	case job.FieldAverageUprankScore:
		m.ResetAverageUprankScore()
		return nil
	case job.FieldMaxUprankScore:
		m.ResetMaxUprankScore()
		return nil
	case job.FieldMinUprankScore:
		m.ResetMinUprankScore()
		return nil
	}
	return fmt.Errorf("unknown Job field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, job.EdgeUser)
	}
	if m.freelancers != nil {
		edges = append(edges, job.EdgeFreelancers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case job.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case job.EdgeFreelancers:
		ids := make([]ent.Value, 0, len(m.freelancers))
		for id := range m.freelancers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedfreelancers != nil {
		edges = append(edges, job.EdgeFreelancers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case job.EdgeFreelancers:
		ids := make([]ent.Value, 0, len(m.removedfreelancers))
		for id := range m.removedfreelancers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, job.EdgeUser)
	}
	if m.clearedfreelancers {
		edges = append(edges, job.EdgeFreelancers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobMutation) EdgeCleared(name string) bool {
	switch name {
	case job.EdgeUser:
		return m.cleareduser
	case job.EdgeFreelancers:
		return m.clearedfreelancers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobMutation) ClearEdge(name string) error {
	switch name {
	case job.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Job unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobMutation) ResetEdge(name string) error {
	switch name {
	case job.EdgeUser:
		m.ResetUser()
		return nil
	case job.EdgeFreelancers:
		m.ResetFreelancers()
		return nil
	}
	return fmt.Errorf("unknown Job edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *string
	first_name    *string
	company_name  *string
	email         *string
	created_at    *time.Time
	updated_at    *time.Time
	last_login    *time.Time
	clearedFields map[string]struct{}
	jobs          map[int]struct{}
	removedjobs   map[int]struct{}
	clearedjobs   bool
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id string) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFirstName sets the "first_name" field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
}

// SetCompanyName sets the "company_name" field.
func (m *UserMutation) SetCompanyName(s string) {
	m.company_name = &s
}

// CompanyName returns the value of the "company_name" field in the mutation.
func (m *UserMutation) CompanyName() (r string, exists bool) {
	v := m.company_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyName returns the old "company_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCompanyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyName: %w", err)
	}
	return oldValue.CompanyName, nil
}

// ResetCompanyName resets all changes to the "company_name" field.
func (m *UserMutation) ResetCompanyName() {
	m.company_name = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetLastLogin sets the "last_login" field.
func (m *UserMutation) SetLastLogin(t time.Time) {
	m.last_login = &t
}

// LastLogin returns the value of the "last_login" field in the mutation.
func (m *UserMutation) LastLogin() (r time.Time, exists bool) {
	v := m.last_login
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLogin returns the old "last_login" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLogin(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLogin: %w", err)
	}
	return oldValue.LastLogin, nil
}

// ResetLastLogin resets all changes to the "last_login" field.
func (m *UserMutation) ResetLastLogin() {
	m.last_login = nil
}

// AddJobIDs adds the "jobs" edge to the Job entity by ids.
func (m *UserMutation) AddJobIDs(ids ...int) {
	if m.jobs == nil {
		m.jobs = make(map[int]struct{})
	}
	for i := range ids {
		m.jobs[ids[i]] = struct{}{}
	}
}

// ClearJobs clears the "jobs" edge to the Job entity.
func (m *UserMutation) ClearJobs() {
	m.clearedjobs = true
}

// JobsCleared reports if the "jobs" edge to the Job entity was cleared.
func (m *UserMutation) JobsCleared() bool {
	return m.clearedjobs
}

// RemoveJobIDs removes the "jobs" edge to the Job entity by IDs.
func (m *UserMutation) RemoveJobIDs(ids ...int) {
	if m.removedjobs == nil {
		m.removedjobs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.jobs, ids[i])
		m.removedjobs[ids[i]] = struct{}{}
	}
}

// RemovedJobs returns the removed IDs of the "jobs" edge to the Job entity.
func (m *UserMutation) RemovedJobsIDs() (ids []int) {
	for id := range m.removedjobs {
		ids = append(ids, id)
	}
	return
}

// JobsIDs returns the "jobs" edge IDs in the mutation.
func (m *UserMutation) JobsIDs() (ids []int) {
	for id := range m.jobs {
		ids = append(ids, id)
	}
	return
}

// ResetJobs resets all changes to the "jobs" edge.
func (m *UserMutation) ResetJobs() {
	m.jobs = nil
	m.clearedjobs = false
	m.removedjobs = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.company_name != nil {
		fields = append(fields, user.FieldCompanyName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.last_login != nil {
		fields = append(fields, user.FieldLastLogin)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldCompanyName:
		return m.CompanyName()
	case user.FieldEmail:
		return m.Email()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldLastLogin:
		return m.LastLogin()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldCompanyName:
		return m.OldCompanyName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldLastLogin:
		return m.OldLastLogin(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldCompanyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldLastLogin:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLogin(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldCompanyName:
		m.ResetCompanyName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldLastLogin:
		m.ResetLastLogin()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.jobs != nil {
		edges = append(edges, user.EdgeJobs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeJobs:
		ids := make([]ent.Value, 0, len(m.jobs))
		for id := range m.jobs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedjobs != nil {
		edges = append(edges, user.EdgeJobs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeJobs:
		ids := make([]ent.Value, 0, len(m.removedjobs))
		for id := range m.removedjobs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedjobs {
		edges = append(edges, user.EdgeJobs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeJobs:
		return m.clearedjobs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeJobs:
		m.ResetJobs()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// WorkHistoryMutation represents an operation that mutates the WorkHistory nodes in the graph.
type WorkHistoryMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *int
	title                              *string
	client_feedback                    *string
	overall_rating                     *float64
	addoverall_rating                  *float64
	fixed_charge_amount                *int
	addfixed_charge_amount             *int
	fixed_charge_currency              *string
	hourly_charge_amount               *int
	addhourly_charge_amount            *int
	hourly_charge_currency             *string
	start_date                         *time.Time
	end_date                           *time.Time
	job_description                    *string
	total_proposals                    *int
	addtotal_proposals                 *int
	number_of_interviews               *int
	addnumber_of_interviews            *int
	skills                             *[]string
	appendskills                       []string
	client_rating                      *float64
	addclient_rating                   *float64
	client_review_count                *int
	addclient_review_count             *int
	client_country                     *string
	client_total_jobs_posted           *int
	addclient_total_jobs_posted        *int
	client_total_spend                 *float64
	addclient_total_spend              *float64
	client_total_hires                 *int
	addclient_total_hires              *int
	client_total_paid_hours            *int
	addclient_total_paid_hours         *int
	client_average_hourly_rate_paid    *float64
	addclient_average_hourly_rate_paid *float64
	client_company_category            *string
	client_company_size                *string
	clearedFields                      map[string]struct{}
	upwork_Freelancer_Proposal         *uuid.UUID
	clearedupwork_Freelancer_Proposal  bool
	done                               bool
	oldValue                           func(context.Context) (*WorkHistory, error)
	predicates                         []predicate.WorkHistory
}

var _ ent.Mutation = (*WorkHistoryMutation)(nil)

// workhistoryOption allows management of the mutation configuration using functional options.
type workhistoryOption func(*WorkHistoryMutation)

// newWorkHistoryMutation creates new mutation for the WorkHistory entity.
func newWorkHistoryMutation(c config, op Op, opts ...workhistoryOption) *WorkHistoryMutation {
	m := &WorkHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkHistoryID sets the ID field of the mutation.
func withWorkHistoryID(id int) workhistoryOption {
	return func(m *WorkHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkHistory
		)
		m.oldValue = func(ctx context.Context) (*WorkHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkHistory sets the old WorkHistory of the mutation.
func withWorkHistory(node *WorkHistory) workhistoryOption {
	return func(m *WorkHistoryMutation) {
		m.oldValue = func(context.Context) (*WorkHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkHistoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkHistoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *WorkHistoryMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *WorkHistoryMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *WorkHistoryMutation) ResetTitle() {
	m.title = nil
}

// SetClientFeedback sets the "client_feedback" field.
func (m *WorkHistoryMutation) SetClientFeedback(s string) {
	m.client_feedback = &s
}

// ClientFeedback returns the value of the "client_feedback" field in the mutation.
func (m *WorkHistoryMutation) ClientFeedback() (r string, exists bool) {
	v := m.client_feedback
	if v == nil {
		return
	}
	return *v, true
}

// OldClientFeedback returns the old "client_feedback" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldClientFeedback(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientFeedback is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientFeedback requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientFeedback: %w", err)
	}
	return oldValue.ClientFeedback, nil
}

// ResetClientFeedback resets all changes to the "client_feedback" field.
func (m *WorkHistoryMutation) ResetClientFeedback() {
	m.client_feedback = nil
}

// SetOverallRating sets the "overall_rating" field.
func (m *WorkHistoryMutation) SetOverallRating(f float64) {
	m.overall_rating = &f
	m.addoverall_rating = nil
}

// OverallRating returns the value of the "overall_rating" field in the mutation.
func (m *WorkHistoryMutation) OverallRating() (r float64, exists bool) {
	v := m.overall_rating
	if v == nil {
		return
	}
	return *v, true
}

// OldOverallRating returns the old "overall_rating" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldOverallRating(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverallRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverallRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverallRating: %w", err)
	}
	return oldValue.OverallRating, nil
}

// AddOverallRating adds f to the "overall_rating" field.
func (m *WorkHistoryMutation) AddOverallRating(f float64) {
	if m.addoverall_rating != nil {
		*m.addoverall_rating += f
	} else {
		m.addoverall_rating = &f
	}
}

// AddedOverallRating returns the value that was added to the "overall_rating" field in this mutation.
func (m *WorkHistoryMutation) AddedOverallRating() (r float64, exists bool) {
	v := m.addoverall_rating
	if v == nil {
		return
	}
	return *v, true
}

// ResetOverallRating resets all changes to the "overall_rating" field.
func (m *WorkHistoryMutation) ResetOverallRating() {
	m.overall_rating = nil
	m.addoverall_rating = nil
}

// SetFixedChargeAmount sets the "fixed_charge_amount" field.
func (m *WorkHistoryMutation) SetFixedChargeAmount(i int) {
	m.fixed_charge_amount = &i
	m.addfixed_charge_amount = nil
}

// FixedChargeAmount returns the value of the "fixed_charge_amount" field in the mutation.
func (m *WorkHistoryMutation) FixedChargeAmount() (r int, exists bool) {
	v := m.fixed_charge_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldFixedChargeAmount returns the old "fixed_charge_amount" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldFixedChargeAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFixedChargeAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFixedChargeAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFixedChargeAmount: %w", err)
	}
	return oldValue.FixedChargeAmount, nil
}

// AddFixedChargeAmount adds i to the "fixed_charge_amount" field.
func (m *WorkHistoryMutation) AddFixedChargeAmount(i int) {
	if m.addfixed_charge_amount != nil {
		*m.addfixed_charge_amount += i
	} else {
		m.addfixed_charge_amount = &i
	}
}

// AddedFixedChargeAmount returns the value that was added to the "fixed_charge_amount" field in this mutation.
func (m *WorkHistoryMutation) AddedFixedChargeAmount() (r int, exists bool) {
	v := m.addfixed_charge_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearFixedChargeAmount clears the value of the "fixed_charge_amount" field.
func (m *WorkHistoryMutation) ClearFixedChargeAmount() {
	m.fixed_charge_amount = nil
	m.addfixed_charge_amount = nil
	m.clearedFields[workhistory.FieldFixedChargeAmount] = struct{}{}
}

// FixedChargeAmountCleared returns if the "fixed_charge_amount" field was cleared in this mutation.
func (m *WorkHistoryMutation) FixedChargeAmountCleared() bool {
	_, ok := m.clearedFields[workhistory.FieldFixedChargeAmount]
	return ok
}

// ResetFixedChargeAmount resets all changes to the "fixed_charge_amount" field.
func (m *WorkHistoryMutation) ResetFixedChargeAmount() {
	m.fixed_charge_amount = nil
	m.addfixed_charge_amount = nil
	delete(m.clearedFields, workhistory.FieldFixedChargeAmount)
}

// SetFixedChargeCurrency sets the "fixed_charge_currency" field.
func (m *WorkHistoryMutation) SetFixedChargeCurrency(s string) {
	m.fixed_charge_currency = &s
}

// FixedChargeCurrency returns the value of the "fixed_charge_currency" field in the mutation.
func (m *WorkHistoryMutation) FixedChargeCurrency() (r string, exists bool) {
	v := m.fixed_charge_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldFixedChargeCurrency returns the old "fixed_charge_currency" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldFixedChargeCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFixedChargeCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFixedChargeCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFixedChargeCurrency: %w", err)
	}
	return oldValue.FixedChargeCurrency, nil
}

// ClearFixedChargeCurrency clears the value of the "fixed_charge_currency" field.
func (m *WorkHistoryMutation) ClearFixedChargeCurrency() {
	m.fixed_charge_currency = nil
	m.clearedFields[workhistory.FieldFixedChargeCurrency] = struct{}{}
}

// FixedChargeCurrencyCleared returns if the "fixed_charge_currency" field was cleared in this mutation.
func (m *WorkHistoryMutation) FixedChargeCurrencyCleared() bool {
	_, ok := m.clearedFields[workhistory.FieldFixedChargeCurrency]
	return ok
}

// ResetFixedChargeCurrency resets all changes to the "fixed_charge_currency" field.
func (m *WorkHistoryMutation) ResetFixedChargeCurrency() {
	m.fixed_charge_currency = nil
	delete(m.clearedFields, workhistory.FieldFixedChargeCurrency)
}

// SetHourlyChargeAmount sets the "hourly_charge_amount" field.
func (m *WorkHistoryMutation) SetHourlyChargeAmount(i int) {
	m.hourly_charge_amount = &i
	m.addhourly_charge_amount = nil
}

// HourlyChargeAmount returns the value of the "hourly_charge_amount" field in the mutation.
func (m *WorkHistoryMutation) HourlyChargeAmount() (r int, exists bool) {
	v := m.hourly_charge_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldHourlyChargeAmount returns the old "hourly_charge_amount" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldHourlyChargeAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHourlyChargeAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHourlyChargeAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHourlyChargeAmount: %w", err)
	}
	return oldValue.HourlyChargeAmount, nil
}

// AddHourlyChargeAmount adds i to the "hourly_charge_amount" field.
func (m *WorkHistoryMutation) AddHourlyChargeAmount(i int) {
	if m.addhourly_charge_amount != nil {
		*m.addhourly_charge_amount += i
	} else {
		m.addhourly_charge_amount = &i
	}
}

// AddedHourlyChargeAmount returns the value that was added to the "hourly_charge_amount" field in this mutation.
func (m *WorkHistoryMutation) AddedHourlyChargeAmount() (r int, exists bool) {
	v := m.addhourly_charge_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearHourlyChargeAmount clears the value of the "hourly_charge_amount" field.
func (m *WorkHistoryMutation) ClearHourlyChargeAmount() {
	m.hourly_charge_amount = nil
	m.addhourly_charge_amount = nil
	m.clearedFields[workhistory.FieldHourlyChargeAmount] = struct{}{}
}

// HourlyChargeAmountCleared returns if the "hourly_charge_amount" field was cleared in this mutation.
func (m *WorkHistoryMutation) HourlyChargeAmountCleared() bool {
	_, ok := m.clearedFields[workhistory.FieldHourlyChargeAmount]
	return ok
}

// ResetHourlyChargeAmount resets all changes to the "hourly_charge_amount" field.
func (m *WorkHistoryMutation) ResetHourlyChargeAmount() {
	m.hourly_charge_amount = nil
	m.addhourly_charge_amount = nil
	delete(m.clearedFields, workhistory.FieldHourlyChargeAmount)
}

// SetHourlyChargeCurrency sets the "hourly_charge_currency" field.
func (m *WorkHistoryMutation) SetHourlyChargeCurrency(s string) {
	m.hourly_charge_currency = &s
}

// HourlyChargeCurrency returns the value of the "hourly_charge_currency" field in the mutation.
func (m *WorkHistoryMutation) HourlyChargeCurrency() (r string, exists bool) {
	v := m.hourly_charge_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldHourlyChargeCurrency returns the old "hourly_charge_currency" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldHourlyChargeCurrency(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHourlyChargeCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHourlyChargeCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHourlyChargeCurrency: %w", err)
	}
	return oldValue.HourlyChargeCurrency, nil
}

// ClearHourlyChargeCurrency clears the value of the "hourly_charge_currency" field.
func (m *WorkHistoryMutation) ClearHourlyChargeCurrency() {
	m.hourly_charge_currency = nil
	m.clearedFields[workhistory.FieldHourlyChargeCurrency] = struct{}{}
}

// HourlyChargeCurrencyCleared returns if the "hourly_charge_currency" field was cleared in this mutation.
func (m *WorkHistoryMutation) HourlyChargeCurrencyCleared() bool {
	_, ok := m.clearedFields[workhistory.FieldHourlyChargeCurrency]
	return ok
}

// ResetHourlyChargeCurrency resets all changes to the "hourly_charge_currency" field.
func (m *WorkHistoryMutation) ResetHourlyChargeCurrency() {
	m.hourly_charge_currency = nil
	delete(m.clearedFields, workhistory.FieldHourlyChargeCurrency)
}

// SetStartDate sets the "start_date" field.
func (m *WorkHistoryMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *WorkHistoryMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *WorkHistoryMutation) ResetStartDate() {
	m.start_date = nil
}

// SetEndDate sets the "end_date" field.
func (m *WorkHistoryMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *WorkHistoryMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *WorkHistoryMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[workhistory.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *WorkHistoryMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[workhistory.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *WorkHistoryMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, workhistory.FieldEndDate)
}

// SetJobDescription sets the "job_description" field.
func (m *WorkHistoryMutation) SetJobDescription(s string) {
	m.job_description = &s
}

// JobDescription returns the value of the "job_description" field in the mutation.
func (m *WorkHistoryMutation) JobDescription() (r string, exists bool) {
	v := m.job_description
	if v == nil {
		return
	}
	return *v, true
}

// OldJobDescription returns the old "job_description" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldJobDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobDescription: %w", err)
	}
	return oldValue.JobDescription, nil
}

// ResetJobDescription resets all changes to the "job_description" field.
func (m *WorkHistoryMutation) ResetJobDescription() {
	m.job_description = nil
}

// SetTotalProposals sets the "total_proposals" field.
func (m *WorkHistoryMutation) SetTotalProposals(i int) {
	m.total_proposals = &i
	m.addtotal_proposals = nil
}

// TotalProposals returns the value of the "total_proposals" field in the mutation.
func (m *WorkHistoryMutation) TotalProposals() (r int, exists bool) {
	v := m.total_proposals
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalProposals returns the old "total_proposals" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldTotalProposals(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalProposals is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalProposals requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalProposals: %w", err)
	}
	return oldValue.TotalProposals, nil
}

// AddTotalProposals adds i to the "total_proposals" field.
func (m *WorkHistoryMutation) AddTotalProposals(i int) {
	if m.addtotal_proposals != nil {
		*m.addtotal_proposals += i
	} else {
		m.addtotal_proposals = &i
	}
}

// AddedTotalProposals returns the value that was added to the "total_proposals" field in this mutation.
func (m *WorkHistoryMutation) AddedTotalProposals() (r int, exists bool) {
	v := m.addtotal_proposals
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalProposals resets all changes to the "total_proposals" field.
func (m *WorkHistoryMutation) ResetTotalProposals() {
	m.total_proposals = nil
	m.addtotal_proposals = nil
}

// SetNumberOfInterviews sets the "number_of_interviews" field.
func (m *WorkHistoryMutation) SetNumberOfInterviews(i int) {
	m.number_of_interviews = &i
	m.addnumber_of_interviews = nil
}

// NumberOfInterviews returns the value of the "number_of_interviews" field in the mutation.
func (m *WorkHistoryMutation) NumberOfInterviews() (r int, exists bool) {
	v := m.number_of_interviews
	if v == nil {
		return
	}
	return *v, true
}

// OldNumberOfInterviews returns the old "number_of_interviews" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldNumberOfInterviews(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumberOfInterviews is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumberOfInterviews requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumberOfInterviews: %w", err)
	}
	return oldValue.NumberOfInterviews, nil
}

// AddNumberOfInterviews adds i to the "number_of_interviews" field.
func (m *WorkHistoryMutation) AddNumberOfInterviews(i int) {
	if m.addnumber_of_interviews != nil {
		*m.addnumber_of_interviews += i
	} else {
		m.addnumber_of_interviews = &i
	}
}

// AddedNumberOfInterviews returns the value that was added to the "number_of_interviews" field in this mutation.
func (m *WorkHistoryMutation) AddedNumberOfInterviews() (r int, exists bool) {
	v := m.addnumber_of_interviews
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumberOfInterviews resets all changes to the "number_of_interviews" field.
func (m *WorkHistoryMutation) ResetNumberOfInterviews() {
	m.number_of_interviews = nil
	m.addnumber_of_interviews = nil
}

// SetSkills sets the "skills" field.
func (m *WorkHistoryMutation) SetSkills(s []string) {
	m.skills = &s
	m.appendskills = nil
}

// Skills returns the value of the "skills" field in the mutation.
func (m *WorkHistoryMutation) Skills() (r []string, exists bool) {
	v := m.skills
	if v == nil {
		return
	}
	return *v, true
}

// OldSkills returns the old "skills" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldSkills(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkills is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkills requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkills: %w", err)
	}
	return oldValue.Skills, nil
}

// AppendSkills adds s to the "skills" field.
func (m *WorkHistoryMutation) AppendSkills(s []string) {
	m.appendskills = append(m.appendskills, s...)
}

// AppendedSkills returns the list of values that were appended to the "skills" field in this mutation.
func (m *WorkHistoryMutation) AppendedSkills() ([]string, bool) {
	if len(m.appendskills) == 0 {
		return nil, false
	}
	return m.appendskills, true
}

// ResetSkills resets all changes to the "skills" field.
func (m *WorkHistoryMutation) ResetSkills() {
	m.skills = nil
	m.appendskills = nil
}

// SetClientRating sets the "client_rating" field.
func (m *WorkHistoryMutation) SetClientRating(f float64) {
	m.client_rating = &f
	m.addclient_rating = nil
}

// ClientRating returns the value of the "client_rating" field in the mutation.
func (m *WorkHistoryMutation) ClientRating() (r float64, exists bool) {
	v := m.client_rating
	if v == nil {
		return
	}
	return *v, true
}

// OldClientRating returns the old "client_rating" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldClientRating(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientRating is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientRating requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientRating: %w", err)
	}
	return oldValue.ClientRating, nil
}

// AddClientRating adds f to the "client_rating" field.
func (m *WorkHistoryMutation) AddClientRating(f float64) {
	if m.addclient_rating != nil {
		*m.addclient_rating += f
	} else {
		m.addclient_rating = &f
	}
}

// AddedClientRating returns the value that was added to the "client_rating" field in this mutation.
func (m *WorkHistoryMutation) AddedClientRating() (r float64, exists bool) {
	v := m.addclient_rating
	if v == nil {
		return
	}
	return *v, true
}

// ResetClientRating resets all changes to the "client_rating" field.
func (m *WorkHistoryMutation) ResetClientRating() {
	m.client_rating = nil
	m.addclient_rating = nil
}

// SetClientReviewCount sets the "client_review_count" field.
func (m *WorkHistoryMutation) SetClientReviewCount(i int) {
	m.client_review_count = &i
	m.addclient_review_count = nil
}

// ClientReviewCount returns the value of the "client_review_count" field in the mutation.
func (m *WorkHistoryMutation) ClientReviewCount() (r int, exists bool) {
	v := m.client_review_count
	if v == nil {
		return
	}
	return *v, true
}

// OldClientReviewCount returns the old "client_review_count" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldClientReviewCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientReviewCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientReviewCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientReviewCount: %w", err)
	}
	return oldValue.ClientReviewCount, nil
}

// AddClientReviewCount adds i to the "client_review_count" field.
func (m *WorkHistoryMutation) AddClientReviewCount(i int) {
	if m.addclient_review_count != nil {
		*m.addclient_review_count += i
	} else {
		m.addclient_review_count = &i
	}
}

// AddedClientReviewCount returns the value that was added to the "client_review_count" field in this mutation.
func (m *WorkHistoryMutation) AddedClientReviewCount() (r int, exists bool) {
	v := m.addclient_review_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetClientReviewCount resets all changes to the "client_review_count" field.
func (m *WorkHistoryMutation) ResetClientReviewCount() {
	m.client_review_count = nil
	m.addclient_review_count = nil
}

// SetClientCountry sets the "client_country" field.
func (m *WorkHistoryMutation) SetClientCountry(s string) {
	m.client_country = &s
}

// ClientCountry returns the value of the "client_country" field in the mutation.
func (m *WorkHistoryMutation) ClientCountry() (r string, exists bool) {
	v := m.client_country
	if v == nil {
		return
	}
	return *v, true
}

// OldClientCountry returns the old "client_country" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldClientCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientCountry: %w", err)
	}
	return oldValue.ClientCountry, nil
}

// ResetClientCountry resets all changes to the "client_country" field.
func (m *WorkHistoryMutation) ResetClientCountry() {
	m.client_country = nil
}

// SetClientTotalJobsPosted sets the "client_total_jobs_posted" field.
func (m *WorkHistoryMutation) SetClientTotalJobsPosted(i int) {
	m.client_total_jobs_posted = &i
	m.addclient_total_jobs_posted = nil
}

// ClientTotalJobsPosted returns the value of the "client_total_jobs_posted" field in the mutation.
func (m *WorkHistoryMutation) ClientTotalJobsPosted() (r int, exists bool) {
	v := m.client_total_jobs_posted
	if v == nil {
		return
	}
	return *v, true
}

// OldClientTotalJobsPosted returns the old "client_total_jobs_posted" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldClientTotalJobsPosted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientTotalJobsPosted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientTotalJobsPosted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientTotalJobsPosted: %w", err)
	}
	return oldValue.ClientTotalJobsPosted, nil
}

// AddClientTotalJobsPosted adds i to the "client_total_jobs_posted" field.
func (m *WorkHistoryMutation) AddClientTotalJobsPosted(i int) {
	if m.addclient_total_jobs_posted != nil {
		*m.addclient_total_jobs_posted += i
	} else {
		m.addclient_total_jobs_posted = &i
	}
}

// AddedClientTotalJobsPosted returns the value that was added to the "client_total_jobs_posted" field in this mutation.
func (m *WorkHistoryMutation) AddedClientTotalJobsPosted() (r int, exists bool) {
	v := m.addclient_total_jobs_posted
	if v == nil {
		return
	}
	return *v, true
}

// ResetClientTotalJobsPosted resets all changes to the "client_total_jobs_posted" field.
func (m *WorkHistoryMutation) ResetClientTotalJobsPosted() {
	m.client_total_jobs_posted = nil
	m.addclient_total_jobs_posted = nil
}

// SetClientTotalSpend sets the "client_total_spend" field.
func (m *WorkHistoryMutation) SetClientTotalSpend(f float64) {
	m.client_total_spend = &f
	m.addclient_total_spend = nil
}

// ClientTotalSpend returns the value of the "client_total_spend" field in the mutation.
func (m *WorkHistoryMutation) ClientTotalSpend() (r float64, exists bool) {
	v := m.client_total_spend
	if v == nil {
		return
	}
	return *v, true
}

// OldClientTotalSpend returns the old "client_total_spend" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldClientTotalSpend(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientTotalSpend is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientTotalSpend requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientTotalSpend: %w", err)
	}
	return oldValue.ClientTotalSpend, nil
}

// AddClientTotalSpend adds f to the "client_total_spend" field.
func (m *WorkHistoryMutation) AddClientTotalSpend(f float64) {
	if m.addclient_total_spend != nil {
		*m.addclient_total_spend += f
	} else {
		m.addclient_total_spend = &f
	}
}

// AddedClientTotalSpend returns the value that was added to the "client_total_spend" field in this mutation.
func (m *WorkHistoryMutation) AddedClientTotalSpend() (r float64, exists bool) {
	v := m.addclient_total_spend
	if v == nil {
		return
	}
	return *v, true
}

// ResetClientTotalSpend resets all changes to the "client_total_spend" field.
func (m *WorkHistoryMutation) ResetClientTotalSpend() {
	m.client_total_spend = nil
	m.addclient_total_spend = nil
}

// SetClientTotalHires sets the "client_total_hires" field.
func (m *WorkHistoryMutation) SetClientTotalHires(i int) {
	m.client_total_hires = &i
	m.addclient_total_hires = nil
}

// ClientTotalHires returns the value of the "client_total_hires" field in the mutation.
func (m *WorkHistoryMutation) ClientTotalHires() (r int, exists bool) {
	v := m.client_total_hires
	if v == nil {
		return
	}
	return *v, true
}

// OldClientTotalHires returns the old "client_total_hires" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldClientTotalHires(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientTotalHires is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientTotalHires requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientTotalHires: %w", err)
	}
	return oldValue.ClientTotalHires, nil
}

// AddClientTotalHires adds i to the "client_total_hires" field.
func (m *WorkHistoryMutation) AddClientTotalHires(i int) {
	if m.addclient_total_hires != nil {
		*m.addclient_total_hires += i
	} else {
		m.addclient_total_hires = &i
	}
}

// AddedClientTotalHires returns the value that was added to the "client_total_hires" field in this mutation.
func (m *WorkHistoryMutation) AddedClientTotalHires() (r int, exists bool) {
	v := m.addclient_total_hires
	if v == nil {
		return
	}
	return *v, true
}

// ClearClientTotalHires clears the value of the "client_total_hires" field.
func (m *WorkHistoryMutation) ClearClientTotalHires() {
	m.client_total_hires = nil
	m.addclient_total_hires = nil
	m.clearedFields[workhistory.FieldClientTotalHires] = struct{}{}
}

// ClientTotalHiresCleared returns if the "client_total_hires" field was cleared in this mutation.
func (m *WorkHistoryMutation) ClientTotalHiresCleared() bool {
	_, ok := m.clearedFields[workhistory.FieldClientTotalHires]
	return ok
}

// ResetClientTotalHires resets all changes to the "client_total_hires" field.
func (m *WorkHistoryMutation) ResetClientTotalHires() {
	m.client_total_hires = nil
	m.addclient_total_hires = nil
	delete(m.clearedFields, workhistory.FieldClientTotalHires)
}

// SetClientTotalPaidHours sets the "client_total_paid_hours" field.
func (m *WorkHistoryMutation) SetClientTotalPaidHours(i int) {
	m.client_total_paid_hours = &i
	m.addclient_total_paid_hours = nil
}

// ClientTotalPaidHours returns the value of the "client_total_paid_hours" field in the mutation.
func (m *WorkHistoryMutation) ClientTotalPaidHours() (r int, exists bool) {
	v := m.client_total_paid_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldClientTotalPaidHours returns the old "client_total_paid_hours" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldClientTotalPaidHours(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientTotalPaidHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientTotalPaidHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientTotalPaidHours: %w", err)
	}
	return oldValue.ClientTotalPaidHours, nil
}

// AddClientTotalPaidHours adds i to the "client_total_paid_hours" field.
func (m *WorkHistoryMutation) AddClientTotalPaidHours(i int) {
	if m.addclient_total_paid_hours != nil {
		*m.addclient_total_paid_hours += i
	} else {
		m.addclient_total_paid_hours = &i
	}
}

// AddedClientTotalPaidHours returns the value that was added to the "client_total_paid_hours" field in this mutation.
func (m *WorkHistoryMutation) AddedClientTotalPaidHours() (r int, exists bool) {
	v := m.addclient_total_paid_hours
	if v == nil {
		return
	}
	return *v, true
}

// ClearClientTotalPaidHours clears the value of the "client_total_paid_hours" field.
func (m *WorkHistoryMutation) ClearClientTotalPaidHours() {
	m.client_total_paid_hours = nil
	m.addclient_total_paid_hours = nil
	m.clearedFields[workhistory.FieldClientTotalPaidHours] = struct{}{}
}

// ClientTotalPaidHoursCleared returns if the "client_total_paid_hours" field was cleared in this mutation.
func (m *WorkHistoryMutation) ClientTotalPaidHoursCleared() bool {
	_, ok := m.clearedFields[workhistory.FieldClientTotalPaidHours]
	return ok
}

// ResetClientTotalPaidHours resets all changes to the "client_total_paid_hours" field.
func (m *WorkHistoryMutation) ResetClientTotalPaidHours() {
	m.client_total_paid_hours = nil
	m.addclient_total_paid_hours = nil
	delete(m.clearedFields, workhistory.FieldClientTotalPaidHours)
}

// SetClientAverageHourlyRatePaid sets the "client_average_hourly_rate_paid" field.
func (m *WorkHistoryMutation) SetClientAverageHourlyRatePaid(f float64) {
	m.client_average_hourly_rate_paid = &f
	m.addclient_average_hourly_rate_paid = nil
}

// ClientAverageHourlyRatePaid returns the value of the "client_average_hourly_rate_paid" field in the mutation.
func (m *WorkHistoryMutation) ClientAverageHourlyRatePaid() (r float64, exists bool) {
	v := m.client_average_hourly_rate_paid
	if v == nil {
		return
	}
	return *v, true
}

// OldClientAverageHourlyRatePaid returns the old "client_average_hourly_rate_paid" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldClientAverageHourlyRatePaid(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientAverageHourlyRatePaid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientAverageHourlyRatePaid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientAverageHourlyRatePaid: %w", err)
	}
	return oldValue.ClientAverageHourlyRatePaid, nil
}

// AddClientAverageHourlyRatePaid adds f to the "client_average_hourly_rate_paid" field.
func (m *WorkHistoryMutation) AddClientAverageHourlyRatePaid(f float64) {
	if m.addclient_average_hourly_rate_paid != nil {
		*m.addclient_average_hourly_rate_paid += f
	} else {
		m.addclient_average_hourly_rate_paid = &f
	}
}

// AddedClientAverageHourlyRatePaid returns the value that was added to the "client_average_hourly_rate_paid" field in this mutation.
func (m *WorkHistoryMutation) AddedClientAverageHourlyRatePaid() (r float64, exists bool) {
	v := m.addclient_average_hourly_rate_paid
	if v == nil {
		return
	}
	return *v, true
}

// ClearClientAverageHourlyRatePaid clears the value of the "client_average_hourly_rate_paid" field.
func (m *WorkHistoryMutation) ClearClientAverageHourlyRatePaid() {
	m.client_average_hourly_rate_paid = nil
	m.addclient_average_hourly_rate_paid = nil
	m.clearedFields[workhistory.FieldClientAverageHourlyRatePaid] = struct{}{}
}

// ClientAverageHourlyRatePaidCleared returns if the "client_average_hourly_rate_paid" field was cleared in this mutation.
func (m *WorkHistoryMutation) ClientAverageHourlyRatePaidCleared() bool {
	_, ok := m.clearedFields[workhistory.FieldClientAverageHourlyRatePaid]
	return ok
}

// ResetClientAverageHourlyRatePaid resets all changes to the "client_average_hourly_rate_paid" field.
func (m *WorkHistoryMutation) ResetClientAverageHourlyRatePaid() {
	m.client_average_hourly_rate_paid = nil
	m.addclient_average_hourly_rate_paid = nil
	delete(m.clearedFields, workhistory.FieldClientAverageHourlyRatePaid)
}

// SetClientCompanyCategory sets the "client_company_category" field.
func (m *WorkHistoryMutation) SetClientCompanyCategory(s string) {
	m.client_company_category = &s
}

// ClientCompanyCategory returns the value of the "client_company_category" field in the mutation.
func (m *WorkHistoryMutation) ClientCompanyCategory() (r string, exists bool) {
	v := m.client_company_category
	if v == nil {
		return
	}
	return *v, true
}

// OldClientCompanyCategory returns the old "client_company_category" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldClientCompanyCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientCompanyCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientCompanyCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientCompanyCategory: %w", err)
	}
	return oldValue.ClientCompanyCategory, nil
}

// ClearClientCompanyCategory clears the value of the "client_company_category" field.
func (m *WorkHistoryMutation) ClearClientCompanyCategory() {
	m.client_company_category = nil
	m.clearedFields[workhistory.FieldClientCompanyCategory] = struct{}{}
}

// ClientCompanyCategoryCleared returns if the "client_company_category" field was cleared in this mutation.
func (m *WorkHistoryMutation) ClientCompanyCategoryCleared() bool {
	_, ok := m.clearedFields[workhistory.FieldClientCompanyCategory]
	return ok
}

// ResetClientCompanyCategory resets all changes to the "client_company_category" field.
func (m *WorkHistoryMutation) ResetClientCompanyCategory() {
	m.client_company_category = nil
	delete(m.clearedFields, workhistory.FieldClientCompanyCategory)
}

// SetClientCompanySize sets the "client_company_size" field.
func (m *WorkHistoryMutation) SetClientCompanySize(s string) {
	m.client_company_size = &s
}

// ClientCompanySize returns the value of the "client_company_size" field in the mutation.
func (m *WorkHistoryMutation) ClientCompanySize() (r string, exists bool) {
	v := m.client_company_size
	if v == nil {
		return
	}
	return *v, true
}

// OldClientCompanySize returns the old "client_company_size" field's value of the WorkHistory entity.
// If the WorkHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkHistoryMutation) OldClientCompanySize(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientCompanySize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientCompanySize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientCompanySize: %w", err)
	}
	return oldValue.ClientCompanySize, nil
}

// ClearClientCompanySize clears the value of the "client_company_size" field.
func (m *WorkHistoryMutation) ClearClientCompanySize() {
	m.client_company_size = nil
	m.clearedFields[workhistory.FieldClientCompanySize] = struct{}{}
}

// ClientCompanySizeCleared returns if the "client_company_size" field was cleared in this mutation.
func (m *WorkHistoryMutation) ClientCompanySizeCleared() bool {
	_, ok := m.clearedFields[workhistory.FieldClientCompanySize]
	return ok
}

// ResetClientCompanySize resets all changes to the "client_company_size" field.
func (m *WorkHistoryMutation) ResetClientCompanySize() {
	m.client_company_size = nil
	delete(m.clearedFields, workhistory.FieldClientCompanySize)
}

// SetUpworkFreelancerProposalID sets the "upwork_Freelancer_Proposal" edge to the Freelancer entity by id.
func (m *WorkHistoryMutation) SetUpworkFreelancerProposalID(id uuid.UUID) {
	m.upwork_Freelancer_Proposal = &id
}

// ClearUpworkFreelancerProposal clears the "upwork_Freelancer_Proposal" edge to the Freelancer entity.
func (m *WorkHistoryMutation) ClearUpworkFreelancerProposal() {
	m.clearedupwork_Freelancer_Proposal = true
}

// UpworkFreelancerProposalCleared reports if the "upwork_Freelancer_Proposal" edge to the Freelancer entity was cleared.
func (m *WorkHistoryMutation) UpworkFreelancerProposalCleared() bool {
	return m.clearedupwork_Freelancer_Proposal
}

// UpworkFreelancerProposalID returns the "upwork_Freelancer_Proposal" edge ID in the mutation.
func (m *WorkHistoryMutation) UpworkFreelancerProposalID() (id uuid.UUID, exists bool) {
	if m.upwork_Freelancer_Proposal != nil {
		return *m.upwork_Freelancer_Proposal, true
	}
	return
}

// UpworkFreelancerProposalIDs returns the "upwork_Freelancer_Proposal" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpworkFreelancerProposalID instead. It exists only for internal usage by the builders.
func (m *WorkHistoryMutation) UpworkFreelancerProposalIDs() (ids []uuid.UUID) {
	if id := m.upwork_Freelancer_Proposal; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpworkFreelancerProposal resets all changes to the "upwork_Freelancer_Proposal" edge.
func (m *WorkHistoryMutation) ResetUpworkFreelancerProposal() {
	m.upwork_Freelancer_Proposal = nil
	m.clearedupwork_Freelancer_Proposal = false
}

// Where appends a list predicates to the WorkHistoryMutation builder.
func (m *WorkHistoryMutation) Where(ps ...predicate.WorkHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkHistory).
func (m *WorkHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkHistoryMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.title != nil {
		fields = append(fields, workhistory.FieldTitle)
	}
	if m.client_feedback != nil {
		fields = append(fields, workhistory.FieldClientFeedback)
	}
	if m.overall_rating != nil {
		fields = append(fields, workhistory.FieldOverallRating)
	}
	if m.fixed_charge_amount != nil {
		fields = append(fields, workhistory.FieldFixedChargeAmount)
	}
	if m.fixed_charge_currency != nil {
		fields = append(fields, workhistory.FieldFixedChargeCurrency)
	}
	if m.hourly_charge_amount != nil {
		fields = append(fields, workhistory.FieldHourlyChargeAmount)
	}
	if m.hourly_charge_currency != nil {
		fields = append(fields, workhistory.FieldHourlyChargeCurrency)
	}
	if m.start_date != nil {
		fields = append(fields, workhistory.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, workhistory.FieldEndDate)
	}
	if m.job_description != nil {
		fields = append(fields, workhistory.FieldJobDescription)
	}
	if m.total_proposals != nil {
		fields = append(fields, workhistory.FieldTotalProposals)
	}
	if m.number_of_interviews != nil {
		fields = append(fields, workhistory.FieldNumberOfInterviews)
	}
	if m.skills != nil {
		fields = append(fields, workhistory.FieldSkills)
	}
	if m.client_rating != nil {
		fields = append(fields, workhistory.FieldClientRating)
	}
	if m.client_review_count != nil {
		fields = append(fields, workhistory.FieldClientReviewCount)
	}
	if m.client_country != nil {
		fields = append(fields, workhistory.FieldClientCountry)
	}
	if m.client_total_jobs_posted != nil {
		fields = append(fields, workhistory.FieldClientTotalJobsPosted)
	}
	if m.client_total_spend != nil {
		fields = append(fields, workhistory.FieldClientTotalSpend)
	}
	if m.client_total_hires != nil {
		fields = append(fields, workhistory.FieldClientTotalHires)
	}
	if m.client_total_paid_hours != nil {
		fields = append(fields, workhistory.FieldClientTotalPaidHours)
	}
	if m.client_average_hourly_rate_paid != nil {
		fields = append(fields, workhistory.FieldClientAverageHourlyRatePaid)
	}
	if m.client_company_category != nil {
		fields = append(fields, workhistory.FieldClientCompanyCategory)
	}
	if m.client_company_size != nil {
		fields = append(fields, workhistory.FieldClientCompanySize)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workhistory.FieldTitle:
		return m.Title()
	case workhistory.FieldClientFeedback:
		return m.ClientFeedback()
	case workhistory.FieldOverallRating:
		return m.OverallRating()
	case workhistory.FieldFixedChargeAmount:
		return m.FixedChargeAmount()
	case workhistory.FieldFixedChargeCurrency:
		return m.FixedChargeCurrency()
	case workhistory.FieldHourlyChargeAmount:
		return m.HourlyChargeAmount()
	case workhistory.FieldHourlyChargeCurrency:
		return m.HourlyChargeCurrency()
	case workhistory.FieldStartDate:
		return m.StartDate()
	case workhistory.FieldEndDate:
		return m.EndDate()
	case workhistory.FieldJobDescription:
		return m.JobDescription()
	case workhistory.FieldTotalProposals:
		return m.TotalProposals()
	case workhistory.FieldNumberOfInterviews:
		return m.NumberOfInterviews()
	case workhistory.FieldSkills:
		return m.Skills()
	case workhistory.FieldClientRating:
		return m.ClientRating()
	case workhistory.FieldClientReviewCount:
		return m.ClientReviewCount()
	case workhistory.FieldClientCountry:
		return m.ClientCountry()
	case workhistory.FieldClientTotalJobsPosted:
		return m.ClientTotalJobsPosted()
	case workhistory.FieldClientTotalSpend:
		return m.ClientTotalSpend()
	case workhistory.FieldClientTotalHires:
		return m.ClientTotalHires()
	case workhistory.FieldClientTotalPaidHours:
		return m.ClientTotalPaidHours()
	case workhistory.FieldClientAverageHourlyRatePaid:
		return m.ClientAverageHourlyRatePaid()
	case workhistory.FieldClientCompanyCategory:
		return m.ClientCompanyCategory()
	case workhistory.FieldClientCompanySize:
		return m.ClientCompanySize()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workhistory.FieldTitle:
		return m.OldTitle(ctx)
	case workhistory.FieldClientFeedback:
		return m.OldClientFeedback(ctx)
	case workhistory.FieldOverallRating:
		return m.OldOverallRating(ctx)
	case workhistory.FieldFixedChargeAmount:
		return m.OldFixedChargeAmount(ctx)
	case workhistory.FieldFixedChargeCurrency:
		return m.OldFixedChargeCurrency(ctx)
	case workhistory.FieldHourlyChargeAmount:
		return m.OldHourlyChargeAmount(ctx)
	case workhistory.FieldHourlyChargeCurrency:
		return m.OldHourlyChargeCurrency(ctx)
	case workhistory.FieldStartDate:
		return m.OldStartDate(ctx)
	case workhistory.FieldEndDate:
		return m.OldEndDate(ctx)
	case workhistory.FieldJobDescription:
		return m.OldJobDescription(ctx)
	case workhistory.FieldTotalProposals:
		return m.OldTotalProposals(ctx)
	case workhistory.FieldNumberOfInterviews:
		return m.OldNumberOfInterviews(ctx)
	case workhistory.FieldSkills:
		return m.OldSkills(ctx)
	case workhistory.FieldClientRating:
		return m.OldClientRating(ctx)
	case workhistory.FieldClientReviewCount:
		return m.OldClientReviewCount(ctx)
	case workhistory.FieldClientCountry:
		return m.OldClientCountry(ctx)
	case workhistory.FieldClientTotalJobsPosted:
		return m.OldClientTotalJobsPosted(ctx)
	case workhistory.FieldClientTotalSpend:
		return m.OldClientTotalSpend(ctx)
	case workhistory.FieldClientTotalHires:
		return m.OldClientTotalHires(ctx)
	case workhistory.FieldClientTotalPaidHours:
		return m.OldClientTotalPaidHours(ctx)
	case workhistory.FieldClientAverageHourlyRatePaid:
		return m.OldClientAverageHourlyRatePaid(ctx)
	case workhistory.FieldClientCompanyCategory:
		return m.OldClientCompanyCategory(ctx)
	case workhistory.FieldClientCompanySize:
		return m.OldClientCompanySize(ctx)
	}
	return nil, fmt.Errorf("unknown WorkHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workhistory.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case workhistory.FieldClientFeedback:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientFeedback(v)
		return nil
	case workhistory.FieldOverallRating:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverallRating(v)
		return nil
	case workhistory.FieldFixedChargeAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFixedChargeAmount(v)
		return nil
	case workhistory.FieldFixedChargeCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFixedChargeCurrency(v)
		return nil
	case workhistory.FieldHourlyChargeAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHourlyChargeAmount(v)
		return nil
	case workhistory.FieldHourlyChargeCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHourlyChargeCurrency(v)
		return nil
	case workhistory.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case workhistory.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case workhistory.FieldJobDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobDescription(v)
		return nil
	case workhistory.FieldTotalProposals:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalProposals(v)
		return nil
	case workhistory.FieldNumberOfInterviews:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumberOfInterviews(v)
		return nil
	case workhistory.FieldSkills:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkills(v)
		return nil
	case workhistory.FieldClientRating:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientRating(v)
		return nil
	case workhistory.FieldClientReviewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientReviewCount(v)
		return nil
	case workhistory.FieldClientCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientCountry(v)
		return nil
	case workhistory.FieldClientTotalJobsPosted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientTotalJobsPosted(v)
		return nil
	case workhistory.FieldClientTotalSpend:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientTotalSpend(v)
		return nil
	case workhistory.FieldClientTotalHires:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientTotalHires(v)
		return nil
	case workhistory.FieldClientTotalPaidHours:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientTotalPaidHours(v)
		return nil
	case workhistory.FieldClientAverageHourlyRatePaid:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientAverageHourlyRatePaid(v)
		return nil
	case workhistory.FieldClientCompanyCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientCompanyCategory(v)
		return nil
	case workhistory.FieldClientCompanySize:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientCompanySize(v)
		return nil
	}
	return fmt.Errorf("unknown WorkHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addoverall_rating != nil {
		fields = append(fields, workhistory.FieldOverallRating)
	}
	if m.addfixed_charge_amount != nil {
		fields = append(fields, workhistory.FieldFixedChargeAmount)
	}
	if m.addhourly_charge_amount != nil {
		fields = append(fields, workhistory.FieldHourlyChargeAmount)
	}
	if m.addtotal_proposals != nil {
		fields = append(fields, workhistory.FieldTotalProposals)
	}
	if m.addnumber_of_interviews != nil {
		fields = append(fields, workhistory.FieldNumberOfInterviews)
	}
	if m.addclient_rating != nil {
		fields = append(fields, workhistory.FieldClientRating)
	}
	if m.addclient_review_count != nil {
		fields = append(fields, workhistory.FieldClientReviewCount)
	}
	if m.addclient_total_jobs_posted != nil {
		fields = append(fields, workhistory.FieldClientTotalJobsPosted)
	}
	if m.addclient_total_spend != nil {
		fields = append(fields, workhistory.FieldClientTotalSpend)
	}
	if m.addclient_total_hires != nil {
		fields = append(fields, workhistory.FieldClientTotalHires)
	}
	if m.addclient_total_paid_hours != nil {
		fields = append(fields, workhistory.FieldClientTotalPaidHours)
	}
	if m.addclient_average_hourly_rate_paid != nil {
		fields = append(fields, workhistory.FieldClientAverageHourlyRatePaid)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workhistory.FieldOverallRating:
		return m.AddedOverallRating()
	case workhistory.FieldFixedChargeAmount:
		return m.AddedFixedChargeAmount()
	case workhistory.FieldHourlyChargeAmount:
		return m.AddedHourlyChargeAmount()
	case workhistory.FieldTotalProposals:
		return m.AddedTotalProposals()
	case workhistory.FieldNumberOfInterviews:
		return m.AddedNumberOfInterviews()
	case workhistory.FieldClientRating:
		return m.AddedClientRating()
	case workhistory.FieldClientReviewCount:
		return m.AddedClientReviewCount()
	case workhistory.FieldClientTotalJobsPosted:
		return m.AddedClientTotalJobsPosted()
	case workhistory.FieldClientTotalSpend:
		return m.AddedClientTotalSpend()
	case workhistory.FieldClientTotalHires:
		return m.AddedClientTotalHires()
	case workhistory.FieldClientTotalPaidHours:
		return m.AddedClientTotalPaidHours()
	case workhistory.FieldClientAverageHourlyRatePaid:
		return m.AddedClientAverageHourlyRatePaid()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workhistory.FieldOverallRating:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOverallRating(v)
		return nil
	case workhistory.FieldFixedChargeAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFixedChargeAmount(v)
		return nil
	case workhistory.FieldHourlyChargeAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHourlyChargeAmount(v)
		return nil
	case workhistory.FieldTotalProposals:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalProposals(v)
		return nil
	case workhistory.FieldNumberOfInterviews:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumberOfInterviews(v)
		return nil
	case workhistory.FieldClientRating:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClientRating(v)
		return nil
	case workhistory.FieldClientReviewCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClientReviewCount(v)
		return nil
	case workhistory.FieldClientTotalJobsPosted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClientTotalJobsPosted(v)
		return nil
	case workhistory.FieldClientTotalSpend:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClientTotalSpend(v)
		return nil
	case workhistory.FieldClientTotalHires:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClientTotalHires(v)
		return nil
	case workhistory.FieldClientTotalPaidHours:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClientTotalPaidHours(v)
		return nil
	case workhistory.FieldClientAverageHourlyRatePaid:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClientAverageHourlyRatePaid(v)
		return nil
	}
	return fmt.Errorf("unknown WorkHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workhistory.FieldFixedChargeAmount) {
		fields = append(fields, workhistory.FieldFixedChargeAmount)
	}
	if m.FieldCleared(workhistory.FieldFixedChargeCurrency) {
		fields = append(fields, workhistory.FieldFixedChargeCurrency)
	}
	if m.FieldCleared(workhistory.FieldHourlyChargeAmount) {
		fields = append(fields, workhistory.FieldHourlyChargeAmount)
	}
	if m.FieldCleared(workhistory.FieldHourlyChargeCurrency) {
		fields = append(fields, workhistory.FieldHourlyChargeCurrency)
	}
	if m.FieldCleared(workhistory.FieldEndDate) {
		fields = append(fields, workhistory.FieldEndDate)
	}
	if m.FieldCleared(workhistory.FieldClientTotalHires) {
		fields = append(fields, workhistory.FieldClientTotalHires)
	}
	if m.FieldCleared(workhistory.FieldClientTotalPaidHours) {
		fields = append(fields, workhistory.FieldClientTotalPaidHours)
	}
	if m.FieldCleared(workhistory.FieldClientAverageHourlyRatePaid) {
		fields = append(fields, workhistory.FieldClientAverageHourlyRatePaid)
	}
	if m.FieldCleared(workhistory.FieldClientCompanyCategory) {
		fields = append(fields, workhistory.FieldClientCompanyCategory)
	}
	if m.FieldCleared(workhistory.FieldClientCompanySize) {
		fields = append(fields, workhistory.FieldClientCompanySize)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkHistoryMutation) ClearField(name string) error {
	switch name {
	case workhistory.FieldFixedChargeAmount:
		m.ClearFixedChargeAmount()
		return nil
	case workhistory.FieldFixedChargeCurrency:
		m.ClearFixedChargeCurrency()
		return nil
	case workhistory.FieldHourlyChargeAmount:
		m.ClearHourlyChargeAmount()
		return nil
	case workhistory.FieldHourlyChargeCurrency:
		m.ClearHourlyChargeCurrency()
		return nil
	case workhistory.FieldEndDate:
		m.ClearEndDate()
		return nil
	case workhistory.FieldClientTotalHires:
		m.ClearClientTotalHires()
		return nil
	case workhistory.FieldClientTotalPaidHours:
		m.ClearClientTotalPaidHours()
		return nil
	case workhistory.FieldClientAverageHourlyRatePaid:
		m.ClearClientAverageHourlyRatePaid()
		return nil
	case workhistory.FieldClientCompanyCategory:
		m.ClearClientCompanyCategory()
		return nil
	case workhistory.FieldClientCompanySize:
		m.ClearClientCompanySize()
		return nil
	}
	return fmt.Errorf("unknown WorkHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkHistoryMutation) ResetField(name string) error {
	switch name {
	case workhistory.FieldTitle:
		m.ResetTitle()
		return nil
	case workhistory.FieldClientFeedback:
		m.ResetClientFeedback()
		return nil
	case workhistory.FieldOverallRating:
		m.ResetOverallRating()
		return nil
	case workhistory.FieldFixedChargeAmount:
		m.ResetFixedChargeAmount()
		return nil
	case workhistory.FieldFixedChargeCurrency:
		m.ResetFixedChargeCurrency()
		return nil
	case workhistory.FieldHourlyChargeAmount:
		m.ResetHourlyChargeAmount()
		return nil
	case workhistory.FieldHourlyChargeCurrency:
		m.ResetHourlyChargeCurrency()
		return nil
	case workhistory.FieldStartDate:
		m.ResetStartDate()
		return nil
	case workhistory.FieldEndDate:
		m.ResetEndDate()
		return nil
	case workhistory.FieldJobDescription:
		m.ResetJobDescription()
		return nil
	case workhistory.FieldTotalProposals:
		m.ResetTotalProposals()
		return nil
	case workhistory.FieldNumberOfInterviews:
		m.ResetNumberOfInterviews()
		return nil
	case workhistory.FieldSkills:
		m.ResetSkills()
		return nil
	case workhistory.FieldClientRating:
		m.ResetClientRating()
		return nil
	case workhistory.FieldClientReviewCount:
		m.ResetClientReviewCount()
		return nil
	case workhistory.FieldClientCountry:
		m.ResetClientCountry()
		return nil
	case workhistory.FieldClientTotalJobsPosted:
		m.ResetClientTotalJobsPosted()
		return nil
	case workhistory.FieldClientTotalSpend:
		m.ResetClientTotalSpend()
		return nil
	case workhistory.FieldClientTotalHires:
		m.ResetClientTotalHires()
		return nil
	case workhistory.FieldClientTotalPaidHours:
		m.ResetClientTotalPaidHours()
		return nil
	case workhistory.FieldClientAverageHourlyRatePaid:
		m.ResetClientAverageHourlyRatePaid()
		return nil
	case workhistory.FieldClientCompanyCategory:
		m.ResetClientCompanyCategory()
		return nil
	case workhistory.FieldClientCompanySize:
		m.ResetClientCompanySize()
		return nil
	}
	return fmt.Errorf("unknown WorkHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.upwork_Freelancer_Proposal != nil {
		edges = append(edges, workhistory.EdgeUpworkFreelancerProposal)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkHistoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workhistory.EdgeUpworkFreelancerProposal:
		if id := m.upwork_Freelancer_Proposal; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedupwork_Freelancer_Proposal {
		edges = append(edges, workhistory.EdgeUpworkFreelancerProposal)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkHistoryMutation) EdgeCleared(name string) bool {
	switch name {
	case workhistory.EdgeUpworkFreelancerProposal:
		return m.clearedupwork_Freelancer_Proposal
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkHistoryMutation) ClearEdge(name string) error {
	switch name {
	case workhistory.EdgeUpworkFreelancerProposal:
		m.ClearUpworkFreelancerProposal()
		return nil
	}
	return fmt.Errorf("unknown WorkHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkHistoryMutation) ResetEdge(name string) error {
	switch name {
	case workhistory.EdgeUpworkFreelancerProposal:
		m.ResetUpworkFreelancerProposal()
		return nil
	}
	return fmt.Errorf("unknown WorkHistory edge %s", name)
}
